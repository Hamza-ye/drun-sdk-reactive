// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'app_database.dart';

// ignore_for_file: type=lint
class $UsersTable extends Users with TableInfo<$UsersTable, User> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UsersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _lastModifiedDateMeta =
      const VerificationMeta('lastModifiedDate');
  @override
  late final GeneratedColumn<DateTime> lastModifiedDate =
      GeneratedColumn<DateTime>('last_modified_date', aliasedName, true,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<DateTime> createdDate = GeneratedColumn<DateTime>(
      'created_date', aliasedName, true,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _usernameMeta =
      const VerificationMeta('username');
  @override
  late final GeneratedColumn<String> username = GeneratedColumn<String>(
      'username', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _firstNameMeta =
      const VerificationMeta('firstName');
  @override
  late final GeneratedColumn<String> firstName = GeneratedColumn<String>(
      'first_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _lastNameMeta =
      const VerificationMeta('lastName');
  @override
  late final GeneratedColumn<String> lastName = GeneratedColumn<String>(
      'last_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _mobileMeta = const VerificationMeta('mobile');
  @override
  late final GeneratedColumn<String> mobile = GeneratedColumn<String>(
      'mobile', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
      'email', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _langKeyMeta =
      const VerificationMeta('langKey');
  @override
  late final GeneratedColumn<String> langKey = GeneratedColumn<String>(
      'lang_key', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      clientDefault: () => 'ar');
  static const VerificationMeta _activatedMeta =
      const VerificationMeta('activated');
  @override
  late final GeneratedColumn<bool> activated = GeneratedColumn<bool>(
      'activated', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("activated" IN (0, 1))'),
      clientDefault: () => false);
  static const VerificationMeta _imageUrlMeta =
      const VerificationMeta('imageUrl');
  @override
  late final GeneratedColumn<String> imageUrl = GeneratedColumn<String>(
      'image_url', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<List<String>, String>
      authorities = GeneratedColumn<String>('authorities', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<List<String>>($UsersTable.$converterauthorities);
  static const VerificationMeta _submissionCountMeta =
      const VerificationMeta('submissionCount');
  @override
  late final GeneratedColumn<int> submissionCount = GeneratedColumn<int>(
      'submission_count', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      clientDefault: () => 0);
  static const VerificationMeta _assignmentCountMeta =
      const VerificationMeta('assignmentCount');
  @override
  late final GeneratedColumn<int> assignmentCount = GeneratedColumn<int>(
      'assignment_count', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      clientDefault: () => 0);
  static const VerificationMeta _orgUnitCountMeta =
      const VerificationMeta('orgUnitCount');
  @override
  late final GeneratedColumn<int> orgUnitCount = GeneratedColumn<int>(
      'org_unit_count', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      clientDefault: () => 0);
  @override
  late final GeneratedColumnWithTypeConverter<List<String>, String>
      activityUIDs = GeneratedColumn<String>(
              'activity_u_i_ds', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<List<String>>($UsersTable.$converteractivityUIDs);
  @override
  late final GeneratedColumnWithTypeConverter<List<String>, String>
      userTeamsUIDs = GeneratedColumn<String>(
              'user_teams_u_i_ds', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<List<String>>($UsersTable.$converteruserTeamsUIDs);
  @override
  late final GeneratedColumnWithTypeConverter<List<String>, String>
      managedTeamsUIDs = GeneratedColumn<String>(
              'managed_teams_u_i_ds', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<List<String>>($UsersTable.$convertermanagedTeamsUIDs);
  @override
  late final GeneratedColumnWithTypeConverter<List<String>, String>
      userGroupsUIDs = GeneratedColumn<String>(
              'user_groups_u_i_ds', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<List<String>>($UsersTable.$converteruserGroupsUIDs);
  @override
  late final GeneratedColumnWithTypeConverter<List<String>, String>
      userFormsUIDs = GeneratedColumn<String>(
              'user_forms_u_i_ds', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<List<String>>($UsersTable.$converteruserFormsUIDs);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        lastModifiedDate,
        createdDate,
        username,
        firstName,
        lastName,
        mobile,
        email,
        langKey,
        activated,
        imageUrl,
        authorities,
        submissionCount,
        assignmentCount,
        orgUnitCount,
        activityUIDs,
        userTeamsUIDs,
        managedTeamsUIDs,
        userGroupsUIDs,
        userFormsUIDs
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'users';
  @override
  VerificationContext validateIntegrity(Insertable<User> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('last_modified_date')) {
      context.handle(
          _lastModifiedDateMeta,
          lastModifiedDate.isAcceptableOrUnknown(
              data['last_modified_date']!, _lastModifiedDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('username')) {
      context.handle(_usernameMeta,
          username.isAcceptableOrUnknown(data['username']!, _usernameMeta));
    } else if (isInserting) {
      context.missing(_usernameMeta);
    }
    if (data.containsKey('first_name')) {
      context.handle(_firstNameMeta,
          firstName.isAcceptableOrUnknown(data['first_name']!, _firstNameMeta));
    }
    if (data.containsKey('last_name')) {
      context.handle(_lastNameMeta,
          lastName.isAcceptableOrUnknown(data['last_name']!, _lastNameMeta));
    }
    if (data.containsKey('mobile')) {
      context.handle(_mobileMeta,
          mobile.isAcceptableOrUnknown(data['mobile']!, _mobileMeta));
    }
    if (data.containsKey('email')) {
      context.handle(
          _emailMeta, email.isAcceptableOrUnknown(data['email']!, _emailMeta));
    }
    if (data.containsKey('lang_key')) {
      context.handle(_langKeyMeta,
          langKey.isAcceptableOrUnknown(data['lang_key']!, _langKeyMeta));
    }
    if (data.containsKey('activated')) {
      context.handle(_activatedMeta,
          activated.isAcceptableOrUnknown(data['activated']!, _activatedMeta));
    }
    if (data.containsKey('image_url')) {
      context.handle(_imageUrlMeta,
          imageUrl.isAcceptableOrUnknown(data['image_url']!, _imageUrlMeta));
    }
    if (data.containsKey('submission_count')) {
      context.handle(
          _submissionCountMeta,
          submissionCount.isAcceptableOrUnknown(
              data['submission_count']!, _submissionCountMeta));
    }
    if (data.containsKey('assignment_count')) {
      context.handle(
          _assignmentCountMeta,
          assignmentCount.isAcceptableOrUnknown(
              data['assignment_count']!, _assignmentCountMeta));
    }
    if (data.containsKey('org_unit_count')) {
      context.handle(
          _orgUnitCountMeta,
          orgUnitCount.isAcceptableOrUnknown(
              data['org_unit_count']!, _orgUnitCountMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  User map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return User(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      lastModifiedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_modified_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_date']),
      username: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}username'])!,
      firstName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}first_name']),
      lastName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}last_name']),
      mobile: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}mobile']),
      email: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email']),
      langKey: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}lang_key']),
      activated: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}activated'])!,
      imageUrl: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}image_url']),
      authorities: $UsersTable.$converterauthorities.fromSql(attachedDatabase
          .typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}authorities'])!),
      submissionCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}submission_count']),
      assignmentCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}assignment_count']),
      orgUnitCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}org_unit_count']),
      activityUIDs: $UsersTable.$converteractivityUIDs.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}activity_u_i_ds'])!),
      userTeamsUIDs: $UsersTable.$converteruserTeamsUIDs.fromSql(
          attachedDatabase.typeMapping.read(DriftSqlType.string,
              data['${effectivePrefix}user_teams_u_i_ds'])!),
      managedTeamsUIDs: $UsersTable.$convertermanagedTeamsUIDs.fromSql(
          attachedDatabase.typeMapping.read(DriftSqlType.string,
              data['${effectivePrefix}managed_teams_u_i_ds'])!),
      userGroupsUIDs: $UsersTable.$converteruserGroupsUIDs.fromSql(
          attachedDatabase.typeMapping.read(DriftSqlType.string,
              data['${effectivePrefix}user_groups_u_i_ds'])!),
      userFormsUIDs: $UsersTable.$converteruserFormsUIDs.fromSql(
          attachedDatabase.typeMapping.read(DriftSqlType.string,
              data['${effectivePrefix}user_forms_u_i_ds'])!),
    );
  }

  @override
  $UsersTable createAlias(String alias) {
    return $UsersTable(attachedDatabase, alias);
  }

  static TypeConverter<List<String>, String> $converterauthorities =
      const ListConverter<String>();
  static TypeConverter<List<String>, String> $converteractivityUIDs =
      const ListConverter<String>();
  static TypeConverter<List<String>, String> $converteruserTeamsUIDs =
      const ListConverter<String>();
  static TypeConverter<List<String>, String> $convertermanagedTeamsUIDs =
      const ListConverter<String>();
  static TypeConverter<List<String>, String> $converteruserGroupsUIDs =
      const ListConverter<String>();
  static TypeConverter<List<String>, String> $converteruserFormsUIDs =
      const ListConverter<String>();
}

class User extends DataClass implements Insertable<User> {
  final String id;
  final DateTime? lastModifiedDate;
  final DateTime? createdDate;
  final String username;
  final String? firstName;
  final String? lastName;
  final String? mobile;
  final String? email;
  final String? langKey;
  final bool activated;
  final String? imageUrl;
  final List<String> authorities;
  final int? submissionCount;
  final int? assignmentCount;
  final int? orgUnitCount;
  final List<String> activityUIDs;
  final List<String> userTeamsUIDs;
  final List<String> managedTeamsUIDs;
  final List<String> userGroupsUIDs;
  final List<String> userFormsUIDs;
  const User(
      {required this.id,
      this.lastModifiedDate,
      this.createdDate,
      required this.username,
      this.firstName,
      this.lastName,
      this.mobile,
      this.email,
      this.langKey,
      required this.activated,
      this.imageUrl,
      required this.authorities,
      this.submissionCount,
      this.assignmentCount,
      this.orgUnitCount,
      required this.activityUIDs,
      required this.userTeamsUIDs,
      required this.managedTeamsUIDs,
      required this.userGroupsUIDs,
      required this.userFormsUIDs});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || lastModifiedDate != null) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<DateTime>(createdDate);
    }
    map['username'] = Variable<String>(username);
    if (!nullToAbsent || firstName != null) {
      map['first_name'] = Variable<String>(firstName);
    }
    if (!nullToAbsent || lastName != null) {
      map['last_name'] = Variable<String>(lastName);
    }
    if (!nullToAbsent || mobile != null) {
      map['mobile'] = Variable<String>(mobile);
    }
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    if (!nullToAbsent || langKey != null) {
      map['lang_key'] = Variable<String>(langKey);
    }
    map['activated'] = Variable<bool>(activated);
    if (!nullToAbsent || imageUrl != null) {
      map['image_url'] = Variable<String>(imageUrl);
    }
    {
      map['authorities'] = Variable<String>(
          $UsersTable.$converterauthorities.toSql(authorities));
    }
    if (!nullToAbsent || submissionCount != null) {
      map['submission_count'] = Variable<int>(submissionCount);
    }
    if (!nullToAbsent || assignmentCount != null) {
      map['assignment_count'] = Variable<int>(assignmentCount);
    }
    if (!nullToAbsent || orgUnitCount != null) {
      map['org_unit_count'] = Variable<int>(orgUnitCount);
    }
    {
      map['activity_u_i_ds'] = Variable<String>(
          $UsersTable.$converteractivityUIDs.toSql(activityUIDs));
    }
    {
      map['user_teams_u_i_ds'] = Variable<String>(
          $UsersTable.$converteruserTeamsUIDs.toSql(userTeamsUIDs));
    }
    {
      map['managed_teams_u_i_ds'] = Variable<String>(
          $UsersTable.$convertermanagedTeamsUIDs.toSql(managedTeamsUIDs));
    }
    {
      map['user_groups_u_i_ds'] = Variable<String>(
          $UsersTable.$converteruserGroupsUIDs.toSql(userGroupsUIDs));
    }
    {
      map['user_forms_u_i_ds'] = Variable<String>(
          $UsersTable.$converteruserFormsUIDs.toSql(userFormsUIDs));
    }
    return map;
  }

  UsersCompanion toCompanion(bool nullToAbsent) {
    return UsersCompanion(
      id: Value(id),
      lastModifiedDate: lastModifiedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      username: Value(username),
      firstName: firstName == null && nullToAbsent
          ? const Value.absent()
          : Value(firstName),
      lastName: lastName == null && nullToAbsent
          ? const Value.absent()
          : Value(lastName),
      mobile:
          mobile == null && nullToAbsent ? const Value.absent() : Value(mobile),
      email:
          email == null && nullToAbsent ? const Value.absent() : Value(email),
      langKey: langKey == null && nullToAbsent
          ? const Value.absent()
          : Value(langKey),
      activated: Value(activated),
      imageUrl: imageUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(imageUrl),
      authorities: Value(authorities),
      submissionCount: submissionCount == null && nullToAbsent
          ? const Value.absent()
          : Value(submissionCount),
      assignmentCount: assignmentCount == null && nullToAbsent
          ? const Value.absent()
          : Value(assignmentCount),
      orgUnitCount: orgUnitCount == null && nullToAbsent
          ? const Value.absent()
          : Value(orgUnitCount),
      activityUIDs: Value(activityUIDs),
      userTeamsUIDs: Value(userTeamsUIDs),
      managedTeamsUIDs: Value(managedTeamsUIDs),
      userGroupsUIDs: Value(userGroupsUIDs),
      userFormsUIDs: Value(userFormsUIDs),
    );
  }

  factory User.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return User(
      id: serializer.fromJson<String>(json['id']),
      lastModifiedDate:
          serializer.fromJson<DateTime?>(json['lastModifiedDate']),
      createdDate: serializer.fromJson<DateTime?>(json['createdDate']),
      username: serializer.fromJson<String>(json['username']),
      firstName: serializer.fromJson<String?>(json['firstName']),
      lastName: serializer.fromJson<String?>(json['lastName']),
      mobile: serializer.fromJson<String?>(json['mobile']),
      email: serializer.fromJson<String?>(json['email']),
      langKey: serializer.fromJson<String?>(json['langKey']),
      activated: serializer.fromJson<bool>(json['activated']),
      imageUrl: serializer.fromJson<String?>(json['imageUrl']),
      authorities: serializer.fromJson<List<String>>(json['authorities']),
      submissionCount: serializer.fromJson<int?>(json['submissionCount']),
      assignmentCount: serializer.fromJson<int?>(json['assignmentCount']),
      orgUnitCount: serializer.fromJson<int?>(json['orgUnitCount']),
      activityUIDs: serializer.fromJson<List<String>>(json['activityUIDs']),
      userTeamsUIDs: serializer.fromJson<List<String>>(json['userTeamsUIDs']),
      managedTeamsUIDs:
          serializer.fromJson<List<String>>(json['managedTeamsUIDs']),
      userGroupsUIDs: serializer.fromJson<List<String>>(json['userGroupsUIDs']),
      userFormsUIDs: serializer.fromJson<List<String>>(json['userFormsUIDs']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'lastModifiedDate': serializer.toJson<DateTime?>(lastModifiedDate),
      'createdDate': serializer.toJson<DateTime?>(createdDate),
      'username': serializer.toJson<String>(username),
      'firstName': serializer.toJson<String?>(firstName),
      'lastName': serializer.toJson<String?>(lastName),
      'mobile': serializer.toJson<String?>(mobile),
      'email': serializer.toJson<String?>(email),
      'langKey': serializer.toJson<String?>(langKey),
      'activated': serializer.toJson<bool>(activated),
      'imageUrl': serializer.toJson<String?>(imageUrl),
      'authorities': serializer.toJson<List<String>>(authorities),
      'submissionCount': serializer.toJson<int?>(submissionCount),
      'assignmentCount': serializer.toJson<int?>(assignmentCount),
      'orgUnitCount': serializer.toJson<int?>(orgUnitCount),
      'activityUIDs': serializer.toJson<List<String>>(activityUIDs),
      'userTeamsUIDs': serializer.toJson<List<String>>(userTeamsUIDs),
      'managedTeamsUIDs': serializer.toJson<List<String>>(managedTeamsUIDs),
      'userGroupsUIDs': serializer.toJson<List<String>>(userGroupsUIDs),
      'userFormsUIDs': serializer.toJson<List<String>>(userFormsUIDs),
    };
  }

  User copyWith(
          {String? id,
          Value<DateTime?> lastModifiedDate = const Value.absent(),
          Value<DateTime?> createdDate = const Value.absent(),
          String? username,
          Value<String?> firstName = const Value.absent(),
          Value<String?> lastName = const Value.absent(),
          Value<String?> mobile = const Value.absent(),
          Value<String?> email = const Value.absent(),
          Value<String?> langKey = const Value.absent(),
          bool? activated,
          Value<String?> imageUrl = const Value.absent(),
          List<String>? authorities,
          Value<int?> submissionCount = const Value.absent(),
          Value<int?> assignmentCount = const Value.absent(),
          Value<int?> orgUnitCount = const Value.absent(),
          List<String>? activityUIDs,
          List<String>? userTeamsUIDs,
          List<String>? managedTeamsUIDs,
          List<String>? userGroupsUIDs,
          List<String>? userFormsUIDs}) =>
      User(
        id: id ?? this.id,
        lastModifiedDate: lastModifiedDate.present
            ? lastModifiedDate.value
            : this.lastModifiedDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        username: username ?? this.username,
        firstName: firstName.present ? firstName.value : this.firstName,
        lastName: lastName.present ? lastName.value : this.lastName,
        mobile: mobile.present ? mobile.value : this.mobile,
        email: email.present ? email.value : this.email,
        langKey: langKey.present ? langKey.value : this.langKey,
        activated: activated ?? this.activated,
        imageUrl: imageUrl.present ? imageUrl.value : this.imageUrl,
        authorities: authorities ?? this.authorities,
        submissionCount: submissionCount.present
            ? submissionCount.value
            : this.submissionCount,
        assignmentCount: assignmentCount.present
            ? assignmentCount.value
            : this.assignmentCount,
        orgUnitCount:
            orgUnitCount.present ? orgUnitCount.value : this.orgUnitCount,
        activityUIDs: activityUIDs ?? this.activityUIDs,
        userTeamsUIDs: userTeamsUIDs ?? this.userTeamsUIDs,
        managedTeamsUIDs: managedTeamsUIDs ?? this.managedTeamsUIDs,
        userGroupsUIDs: userGroupsUIDs ?? this.userGroupsUIDs,
        userFormsUIDs: userFormsUIDs ?? this.userFormsUIDs,
      );
  User copyWithCompanion(UsersCompanion data) {
    return User(
      id: data.id.present ? data.id.value : this.id,
      lastModifiedDate: data.lastModifiedDate.present
          ? data.lastModifiedDate.value
          : this.lastModifiedDate,
      createdDate:
          data.createdDate.present ? data.createdDate.value : this.createdDate,
      username: data.username.present ? data.username.value : this.username,
      firstName: data.firstName.present ? data.firstName.value : this.firstName,
      lastName: data.lastName.present ? data.lastName.value : this.lastName,
      mobile: data.mobile.present ? data.mobile.value : this.mobile,
      email: data.email.present ? data.email.value : this.email,
      langKey: data.langKey.present ? data.langKey.value : this.langKey,
      activated: data.activated.present ? data.activated.value : this.activated,
      imageUrl: data.imageUrl.present ? data.imageUrl.value : this.imageUrl,
      authorities:
          data.authorities.present ? data.authorities.value : this.authorities,
      submissionCount: data.submissionCount.present
          ? data.submissionCount.value
          : this.submissionCount,
      assignmentCount: data.assignmentCount.present
          ? data.assignmentCount.value
          : this.assignmentCount,
      orgUnitCount: data.orgUnitCount.present
          ? data.orgUnitCount.value
          : this.orgUnitCount,
      activityUIDs: data.activityUIDs.present
          ? data.activityUIDs.value
          : this.activityUIDs,
      userTeamsUIDs: data.userTeamsUIDs.present
          ? data.userTeamsUIDs.value
          : this.userTeamsUIDs,
      managedTeamsUIDs: data.managedTeamsUIDs.present
          ? data.managedTeamsUIDs.value
          : this.managedTeamsUIDs,
      userGroupsUIDs: data.userGroupsUIDs.present
          ? data.userGroupsUIDs.value
          : this.userGroupsUIDs,
      userFormsUIDs: data.userFormsUIDs.present
          ? data.userFormsUIDs.value
          : this.userFormsUIDs,
    );
  }

  @override
  String toString() {
    return (StringBuffer('User(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('username: $username, ')
          ..write('firstName: $firstName, ')
          ..write('lastName: $lastName, ')
          ..write('mobile: $mobile, ')
          ..write('email: $email, ')
          ..write('langKey: $langKey, ')
          ..write('activated: $activated, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('authorities: $authorities, ')
          ..write('submissionCount: $submissionCount, ')
          ..write('assignmentCount: $assignmentCount, ')
          ..write('orgUnitCount: $orgUnitCount, ')
          ..write('activityUIDs: $activityUIDs, ')
          ..write('userTeamsUIDs: $userTeamsUIDs, ')
          ..write('managedTeamsUIDs: $managedTeamsUIDs, ')
          ..write('userGroupsUIDs: $userGroupsUIDs, ')
          ..write('userFormsUIDs: $userFormsUIDs')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      lastModifiedDate,
      createdDate,
      username,
      firstName,
      lastName,
      mobile,
      email,
      langKey,
      activated,
      imageUrl,
      authorities,
      submissionCount,
      assignmentCount,
      orgUnitCount,
      activityUIDs,
      userTeamsUIDs,
      managedTeamsUIDs,
      userGroupsUIDs,
      userFormsUIDs);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is User &&
          other.id == this.id &&
          other.lastModifiedDate == this.lastModifiedDate &&
          other.createdDate == this.createdDate &&
          other.username == this.username &&
          other.firstName == this.firstName &&
          other.lastName == this.lastName &&
          other.mobile == this.mobile &&
          other.email == this.email &&
          other.langKey == this.langKey &&
          other.activated == this.activated &&
          other.imageUrl == this.imageUrl &&
          other.authorities == this.authorities &&
          other.submissionCount == this.submissionCount &&
          other.assignmentCount == this.assignmentCount &&
          other.orgUnitCount == this.orgUnitCount &&
          other.activityUIDs == this.activityUIDs &&
          other.userTeamsUIDs == this.userTeamsUIDs &&
          other.managedTeamsUIDs == this.managedTeamsUIDs &&
          other.userGroupsUIDs == this.userGroupsUIDs &&
          other.userFormsUIDs == this.userFormsUIDs);
}

class UsersCompanion extends UpdateCompanion<User> {
  final Value<String> id;
  final Value<DateTime?> lastModifiedDate;
  final Value<DateTime?> createdDate;
  final Value<String> username;
  final Value<String?> firstName;
  final Value<String?> lastName;
  final Value<String?> mobile;
  final Value<String?> email;
  final Value<String?> langKey;
  final Value<bool> activated;
  final Value<String?> imageUrl;
  final Value<List<String>> authorities;
  final Value<int?> submissionCount;
  final Value<int?> assignmentCount;
  final Value<int?> orgUnitCount;
  final Value<List<String>> activityUIDs;
  final Value<List<String>> userTeamsUIDs;
  final Value<List<String>> managedTeamsUIDs;
  final Value<List<String>> userGroupsUIDs;
  final Value<List<String>> userFormsUIDs;
  final Value<int> rowid;
  const UsersCompanion({
    this.id = const Value.absent(),
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.username = const Value.absent(),
    this.firstName = const Value.absent(),
    this.lastName = const Value.absent(),
    this.mobile = const Value.absent(),
    this.email = const Value.absent(),
    this.langKey = const Value.absent(),
    this.activated = const Value.absent(),
    this.imageUrl = const Value.absent(),
    this.authorities = const Value.absent(),
    this.submissionCount = const Value.absent(),
    this.assignmentCount = const Value.absent(),
    this.orgUnitCount = const Value.absent(),
    this.activityUIDs = const Value.absent(),
    this.userTeamsUIDs = const Value.absent(),
    this.managedTeamsUIDs = const Value.absent(),
    this.userGroupsUIDs = const Value.absent(),
    this.userFormsUIDs = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UsersCompanion.insert({
    required String id,
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    required String username,
    this.firstName = const Value.absent(),
    this.lastName = const Value.absent(),
    this.mobile = const Value.absent(),
    this.email = const Value.absent(),
    this.langKey = const Value.absent(),
    this.activated = const Value.absent(),
    this.imageUrl = const Value.absent(),
    required List<String> authorities,
    this.submissionCount = const Value.absent(),
    this.assignmentCount = const Value.absent(),
    this.orgUnitCount = const Value.absent(),
    required List<String> activityUIDs,
    required List<String> userTeamsUIDs,
    required List<String> managedTeamsUIDs,
    required List<String> userGroupsUIDs,
    required List<String> userFormsUIDs,
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        username = Value(username),
        authorities = Value(authorities),
        activityUIDs = Value(activityUIDs),
        userTeamsUIDs = Value(userTeamsUIDs),
        managedTeamsUIDs = Value(managedTeamsUIDs),
        userGroupsUIDs = Value(userGroupsUIDs),
        userFormsUIDs = Value(userFormsUIDs);
  static Insertable<User> custom({
    Expression<String>? id,
    Expression<DateTime>? lastModifiedDate,
    Expression<DateTime>? createdDate,
    Expression<String>? username,
    Expression<String>? firstName,
    Expression<String>? lastName,
    Expression<String>? mobile,
    Expression<String>? email,
    Expression<String>? langKey,
    Expression<bool>? activated,
    Expression<String>? imageUrl,
    Expression<String>? authorities,
    Expression<int>? submissionCount,
    Expression<int>? assignmentCount,
    Expression<int>? orgUnitCount,
    Expression<String>? activityUIDs,
    Expression<String>? userTeamsUIDs,
    Expression<String>? managedTeamsUIDs,
    Expression<String>? userGroupsUIDs,
    Expression<String>? userFormsUIDs,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (lastModifiedDate != null) 'last_modified_date': lastModifiedDate,
      if (createdDate != null) 'created_date': createdDate,
      if (username != null) 'username': username,
      if (firstName != null) 'first_name': firstName,
      if (lastName != null) 'last_name': lastName,
      if (mobile != null) 'mobile': mobile,
      if (email != null) 'email': email,
      if (langKey != null) 'lang_key': langKey,
      if (activated != null) 'activated': activated,
      if (imageUrl != null) 'image_url': imageUrl,
      if (authorities != null) 'authorities': authorities,
      if (submissionCount != null) 'submission_count': submissionCount,
      if (assignmentCount != null) 'assignment_count': assignmentCount,
      if (orgUnitCount != null) 'org_unit_count': orgUnitCount,
      if (activityUIDs != null) 'activity_u_i_ds': activityUIDs,
      if (userTeamsUIDs != null) 'user_teams_u_i_ds': userTeamsUIDs,
      if (managedTeamsUIDs != null) 'managed_teams_u_i_ds': managedTeamsUIDs,
      if (userGroupsUIDs != null) 'user_groups_u_i_ds': userGroupsUIDs,
      if (userFormsUIDs != null) 'user_forms_u_i_ds': userFormsUIDs,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UsersCompanion copyWith(
      {Value<String>? id,
      Value<DateTime?>? lastModifiedDate,
      Value<DateTime?>? createdDate,
      Value<String>? username,
      Value<String?>? firstName,
      Value<String?>? lastName,
      Value<String?>? mobile,
      Value<String?>? email,
      Value<String?>? langKey,
      Value<bool>? activated,
      Value<String?>? imageUrl,
      Value<List<String>>? authorities,
      Value<int?>? submissionCount,
      Value<int?>? assignmentCount,
      Value<int?>? orgUnitCount,
      Value<List<String>>? activityUIDs,
      Value<List<String>>? userTeamsUIDs,
      Value<List<String>>? managedTeamsUIDs,
      Value<List<String>>? userGroupsUIDs,
      Value<List<String>>? userFormsUIDs,
      Value<int>? rowid}) {
    return UsersCompanion(
      id: id ?? this.id,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      createdDate: createdDate ?? this.createdDate,
      username: username ?? this.username,
      firstName: firstName ?? this.firstName,
      lastName: lastName ?? this.lastName,
      mobile: mobile ?? this.mobile,
      email: email ?? this.email,
      langKey: langKey ?? this.langKey,
      activated: activated ?? this.activated,
      imageUrl: imageUrl ?? this.imageUrl,
      authorities: authorities ?? this.authorities,
      submissionCount: submissionCount ?? this.submissionCount,
      assignmentCount: assignmentCount ?? this.assignmentCount,
      orgUnitCount: orgUnitCount ?? this.orgUnitCount,
      activityUIDs: activityUIDs ?? this.activityUIDs,
      userTeamsUIDs: userTeamsUIDs ?? this.userTeamsUIDs,
      managedTeamsUIDs: managedTeamsUIDs ?? this.managedTeamsUIDs,
      userGroupsUIDs: userGroupsUIDs ?? this.userGroupsUIDs,
      userFormsUIDs: userFormsUIDs ?? this.userFormsUIDs,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (lastModifiedDate.present) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<DateTime>(createdDate.value);
    }
    if (username.present) {
      map['username'] = Variable<String>(username.value);
    }
    if (firstName.present) {
      map['first_name'] = Variable<String>(firstName.value);
    }
    if (lastName.present) {
      map['last_name'] = Variable<String>(lastName.value);
    }
    if (mobile.present) {
      map['mobile'] = Variable<String>(mobile.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (langKey.present) {
      map['lang_key'] = Variable<String>(langKey.value);
    }
    if (activated.present) {
      map['activated'] = Variable<bool>(activated.value);
    }
    if (imageUrl.present) {
      map['image_url'] = Variable<String>(imageUrl.value);
    }
    if (authorities.present) {
      map['authorities'] = Variable<String>(
          $UsersTable.$converterauthorities.toSql(authorities.value));
    }
    if (submissionCount.present) {
      map['submission_count'] = Variable<int>(submissionCount.value);
    }
    if (assignmentCount.present) {
      map['assignment_count'] = Variable<int>(assignmentCount.value);
    }
    if (orgUnitCount.present) {
      map['org_unit_count'] = Variable<int>(orgUnitCount.value);
    }
    if (activityUIDs.present) {
      map['activity_u_i_ds'] = Variable<String>(
          $UsersTable.$converteractivityUIDs.toSql(activityUIDs.value));
    }
    if (userTeamsUIDs.present) {
      map['user_teams_u_i_ds'] = Variable<String>(
          $UsersTable.$converteruserTeamsUIDs.toSql(userTeamsUIDs.value));
    }
    if (managedTeamsUIDs.present) {
      map['managed_teams_u_i_ds'] = Variable<String>(
          $UsersTable.$convertermanagedTeamsUIDs.toSql(managedTeamsUIDs.value));
    }
    if (userGroupsUIDs.present) {
      map['user_groups_u_i_ds'] = Variable<String>(
          $UsersTable.$converteruserGroupsUIDs.toSql(userGroupsUIDs.value));
    }
    if (userFormsUIDs.present) {
      map['user_forms_u_i_ds'] = Variable<String>(
          $UsersTable.$converteruserFormsUIDs.toSql(userFormsUIDs.value));
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UsersCompanion(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('username: $username, ')
          ..write('firstName: $firstName, ')
          ..write('lastName: $lastName, ')
          ..write('mobile: $mobile, ')
          ..write('email: $email, ')
          ..write('langKey: $langKey, ')
          ..write('activated: $activated, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('authorities: $authorities, ')
          ..write('submissionCount: $submissionCount, ')
          ..write('assignmentCount: $assignmentCount, ')
          ..write('orgUnitCount: $orgUnitCount, ')
          ..write('activityUIDs: $activityUIDs, ')
          ..write('userTeamsUIDs: $userTeamsUIDs, ')
          ..write('managedTeamsUIDs: $managedTeamsUIDs, ')
          ..write('userGroupsUIDs: $userGroupsUIDs, ')
          ..write('userFormsUIDs: $userFormsUIDs, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OrgUnitsTable extends OrgUnits with TableInfo<$OrgUnitsTable, OrgUnit> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OrgUnitsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _lastModifiedDateMeta =
      const VerificationMeta('lastModifiedDate');
  @override
  late final GeneratedColumn<DateTime> lastModifiedDate =
      GeneratedColumn<DateTime>('last_modified_date', aliasedName, true,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<DateTime> createdDate = GeneratedColumn<DateTime>(
      'created_date', aliasedName, true,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _displayNameMeta =
      const VerificationMeta('displayName');
  @override
  late final GeneratedColumn<String> displayName = GeneratedColumn<String>(
      'display_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
      label = GeneratedColumn<String>('label', aliasedName, true,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '{}')
          .withConverter<Map<String, dynamic>?>($OrgUnitsTable.$converterlabel);
  @override
  late final GeneratedColumnWithTypeConverter<List<Translation>, String>
      translations = GeneratedColumn<String>('translations', aliasedName, false,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '[]')
          .withConverter<List<Translation>>(
              $OrgUnitsTable.$convertertranslations);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _pathMeta = const VerificationMeta('path');
  @override
  late final GeneratedColumn<String> path = GeneratedColumn<String>(
      'path', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _levelMeta = const VerificationMeta('level');
  @override
  late final GeneratedColumn<int> level = GeneratedColumn<int>(
      'level', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _parentMeta = const VerificationMeta('parent');
  @override
  late final GeneratedColumn<String> parent = GeneratedColumn<String>(
      'parent', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES org_units (id)'));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        lastModifiedDate,
        createdDate,
        displayName,
        label,
        translations,
        name,
        code,
        path,
        level,
        parent
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'org_units';
  @override
  VerificationContext validateIntegrity(Insertable<OrgUnit> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('last_modified_date')) {
      context.handle(
          _lastModifiedDateMeta,
          lastModifiedDate.isAcceptableOrUnknown(
              data['last_modified_date']!, _lastModifiedDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('display_name')) {
      context.handle(
          _displayNameMeta,
          displayName.isAcceptableOrUnknown(
              data['display_name']!, _displayNameMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('path')) {
      context.handle(
          _pathMeta, path.isAcceptableOrUnknown(data['path']!, _pathMeta));
    } else if (isInserting) {
      context.missing(_pathMeta);
    }
    if (data.containsKey('level')) {
      context.handle(
          _levelMeta, level.isAcceptableOrUnknown(data['level']!, _levelMeta));
    } else if (isInserting) {
      context.missing(_levelMeta);
    }
    if (data.containsKey('parent')) {
      context.handle(_parentMeta,
          parent.isAcceptableOrUnknown(data['parent']!, _parentMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OrgUnit map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OrgUnit(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      lastModifiedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_modified_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_date']),
      displayName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}display_name']),
      label: $OrgUnitsTable.$converterlabel.fromSql(attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}label'])),
      translations: $OrgUnitsTable.$convertertranslations.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}translations'])!),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      path: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}path'])!,
      level: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}level'])!,
      parent: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}parent']),
    );
  }

  @override
  $OrgUnitsTable createAlias(String alias) {
    return $OrgUnitsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>?, String?> $converterlabel =
      const NullAwareMapConverter();
  static TypeConverter<List<Translation>, String> $convertertranslations =
      const TranslationConverter();
}

class OrgUnit extends DataClass implements Insertable<OrgUnit> {
  final String id;
  final DateTime? lastModifiedDate;
  final DateTime? createdDate;
  final String? displayName;
  final Map<String, dynamic>? label;
  final List<Translation> translations;
  final String name;
  final String? code;
  final String path;
  final int level;
  final String? parent;
  const OrgUnit(
      {required this.id,
      this.lastModifiedDate,
      this.createdDate,
      this.displayName,
      this.label,
      required this.translations,
      required this.name,
      this.code,
      required this.path,
      required this.level,
      this.parent});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || lastModifiedDate != null) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<DateTime>(createdDate);
    }
    if (!nullToAbsent || displayName != null) {
      map['display_name'] = Variable<String>(displayName);
    }
    if (!nullToAbsent || label != null) {
      map['label'] =
          Variable<String>($OrgUnitsTable.$converterlabel.toSql(label));
    }
    {
      map['translations'] = Variable<String>(
          $OrgUnitsTable.$convertertranslations.toSql(translations));
    }
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    map['path'] = Variable<String>(path);
    map['level'] = Variable<int>(level);
    if (!nullToAbsent || parent != null) {
      map['parent'] = Variable<String>(parent);
    }
    return map;
  }

  OrgUnitsCompanion toCompanion(bool nullToAbsent) {
    return OrgUnitsCompanion(
      id: Value(id),
      lastModifiedDate: lastModifiedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      displayName: displayName == null && nullToAbsent
          ? const Value.absent()
          : Value(displayName),
      label:
          label == null && nullToAbsent ? const Value.absent() : Value(label),
      translations: Value(translations),
      name: Value(name),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      path: Value(path),
      level: Value(level),
      parent:
          parent == null && nullToAbsent ? const Value.absent() : Value(parent),
    );
  }

  factory OrgUnit.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OrgUnit(
      id: serializer.fromJson<String>(json['id']),
      lastModifiedDate:
          serializer.fromJson<DateTime?>(json['lastModifiedDate']),
      createdDate: serializer.fromJson<DateTime?>(json['createdDate']),
      displayName: serializer.fromJson<String?>(json['displayName']),
      label: serializer.fromJson<Map<String, dynamic>?>(json['label']),
      translations:
          serializer.fromJson<List<Translation>>(json['translations']),
      name: serializer.fromJson<String>(json['name']),
      code: serializer.fromJson<String?>(json['code']),
      path: serializer.fromJson<String>(json['path']),
      level: serializer.fromJson<int>(json['level']),
      parent: serializer.fromJson<String?>(json['parent']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'lastModifiedDate': serializer.toJson<DateTime?>(lastModifiedDate),
      'createdDate': serializer.toJson<DateTime?>(createdDate),
      'displayName': serializer.toJson<String?>(displayName),
      'label': serializer.toJson<Map<String, dynamic>?>(label),
      'translations': serializer.toJson<List<Translation>>(translations),
      'name': serializer.toJson<String>(name),
      'code': serializer.toJson<String?>(code),
      'path': serializer.toJson<String>(path),
      'level': serializer.toJson<int>(level),
      'parent': serializer.toJson<String?>(parent),
    };
  }

  OrgUnit copyWith(
          {String? id,
          Value<DateTime?> lastModifiedDate = const Value.absent(),
          Value<DateTime?> createdDate = const Value.absent(),
          Value<String?> displayName = const Value.absent(),
          Value<Map<String, dynamic>?> label = const Value.absent(),
          List<Translation>? translations,
          String? name,
          Value<String?> code = const Value.absent(),
          String? path,
          int? level,
          Value<String?> parent = const Value.absent()}) =>
      OrgUnit(
        id: id ?? this.id,
        lastModifiedDate: lastModifiedDate.present
            ? lastModifiedDate.value
            : this.lastModifiedDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        displayName: displayName.present ? displayName.value : this.displayName,
        label: label.present ? label.value : this.label,
        translations: translations ?? this.translations,
        name: name ?? this.name,
        code: code.present ? code.value : this.code,
        path: path ?? this.path,
        level: level ?? this.level,
        parent: parent.present ? parent.value : this.parent,
      );
  OrgUnit copyWithCompanion(OrgUnitsCompanion data) {
    return OrgUnit(
      id: data.id.present ? data.id.value : this.id,
      lastModifiedDate: data.lastModifiedDate.present
          ? data.lastModifiedDate.value
          : this.lastModifiedDate,
      createdDate:
          data.createdDate.present ? data.createdDate.value : this.createdDate,
      displayName:
          data.displayName.present ? data.displayName.value : this.displayName,
      label: data.label.present ? data.label.value : this.label,
      translations: data.translations.present
          ? data.translations.value
          : this.translations,
      name: data.name.present ? data.name.value : this.name,
      code: data.code.present ? data.code.value : this.code,
      path: data.path.present ? data.path.value : this.path,
      level: data.level.present ? data.level.value : this.level,
      parent: data.parent.present ? data.parent.value : this.parent,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OrgUnit(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('displayName: $displayName, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('path: $path, ')
          ..write('level: $level, ')
          ..write('parent: $parent')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, lastModifiedDate, createdDate,
      displayName, label, translations, name, code, path, level, parent);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OrgUnit &&
          other.id == this.id &&
          other.lastModifiedDate == this.lastModifiedDate &&
          other.createdDate == this.createdDate &&
          other.displayName == this.displayName &&
          other.label == this.label &&
          other.translations == this.translations &&
          other.name == this.name &&
          other.code == this.code &&
          other.path == this.path &&
          other.level == this.level &&
          other.parent == this.parent);
}

class OrgUnitsCompanion extends UpdateCompanion<OrgUnit> {
  final Value<String> id;
  final Value<DateTime?> lastModifiedDate;
  final Value<DateTime?> createdDate;
  final Value<String?> displayName;
  final Value<Map<String, dynamic>?> label;
  final Value<List<Translation>> translations;
  final Value<String> name;
  final Value<String?> code;
  final Value<String> path;
  final Value<int> level;
  final Value<String?> parent;
  final Value<int> rowid;
  const OrgUnitsCompanion({
    this.id = const Value.absent(),
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.displayName = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    this.name = const Value.absent(),
    this.code = const Value.absent(),
    this.path = const Value.absent(),
    this.level = const Value.absent(),
    this.parent = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OrgUnitsCompanion.insert({
    required String id,
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.displayName = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    required String name,
    this.code = const Value.absent(),
    required String path,
    required int level,
    this.parent = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        name = Value(name),
        path = Value(path),
        level = Value(level);
  static Insertable<OrgUnit> custom({
    Expression<String>? id,
    Expression<DateTime>? lastModifiedDate,
    Expression<DateTime>? createdDate,
    Expression<String>? displayName,
    Expression<String>? label,
    Expression<String>? translations,
    Expression<String>? name,
    Expression<String>? code,
    Expression<String>? path,
    Expression<int>? level,
    Expression<String>? parent,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (lastModifiedDate != null) 'last_modified_date': lastModifiedDate,
      if (createdDate != null) 'created_date': createdDate,
      if (displayName != null) 'display_name': displayName,
      if (label != null) 'label': label,
      if (translations != null) 'translations': translations,
      if (name != null) 'name': name,
      if (code != null) 'code': code,
      if (path != null) 'path': path,
      if (level != null) 'level': level,
      if (parent != null) 'parent': parent,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OrgUnitsCompanion copyWith(
      {Value<String>? id,
      Value<DateTime?>? lastModifiedDate,
      Value<DateTime?>? createdDate,
      Value<String?>? displayName,
      Value<Map<String, dynamic>?>? label,
      Value<List<Translation>>? translations,
      Value<String>? name,
      Value<String?>? code,
      Value<String>? path,
      Value<int>? level,
      Value<String?>? parent,
      Value<int>? rowid}) {
    return OrgUnitsCompanion(
      id: id ?? this.id,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      createdDate: createdDate ?? this.createdDate,
      displayName: displayName ?? this.displayName,
      label: label ?? this.label,
      translations: translations ?? this.translations,
      name: name ?? this.name,
      code: code ?? this.code,
      path: path ?? this.path,
      level: level ?? this.level,
      parent: parent ?? this.parent,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (lastModifiedDate.present) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<DateTime>(createdDate.value);
    }
    if (displayName.present) {
      map['display_name'] = Variable<String>(displayName.value);
    }
    if (label.present) {
      map['label'] =
          Variable<String>($OrgUnitsTable.$converterlabel.toSql(label.value));
    }
    if (translations.present) {
      map['translations'] = Variable<String>(
          $OrgUnitsTable.$convertertranslations.toSql(translations.value));
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (path.present) {
      map['path'] = Variable<String>(path.value);
    }
    if (level.present) {
      map['level'] = Variable<int>(level.value);
    }
    if (parent.present) {
      map['parent'] = Variable<String>(parent.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OrgUnitsCompanion(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('displayName: $displayName, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('path: $path, ')
          ..write('level: $level, ')
          ..write('parent: $parent, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OuLevelsTable extends OuLevels with TableInfo<$OuLevelsTable, OuLevel> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OuLevelsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _lastModifiedDateMeta =
      const VerificationMeta('lastModifiedDate');
  @override
  late final GeneratedColumn<DateTime> lastModifiedDate =
      GeneratedColumn<DateTime>('last_modified_date', aliasedName, true,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<DateTime> createdDate = GeneratedColumn<DateTime>(
      'created_date', aliasedName, true,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _displayNameMeta =
      const VerificationMeta('displayName');
  @override
  late final GeneratedColumn<String> displayName = GeneratedColumn<String>(
      'display_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
      label = GeneratedColumn<String>('label', aliasedName, true,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '{}')
          .withConverter<Map<String, dynamic>?>($OuLevelsTable.$converterlabel);
  @override
  late final GeneratedColumnWithTypeConverter<List<Translation>, String>
      translations = GeneratedColumn<String>('translations', aliasedName, false,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '[]')
          .withConverter<List<Translation>>(
              $OuLevelsTable.$convertertranslations);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _levelMeta = const VerificationMeta('level');
  @override
  late final GeneratedColumn<int> level = GeneratedColumn<int>(
      'level', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _offlineLevelsMeta =
      const VerificationMeta('offlineLevels');
  @override
  late final GeneratedColumn<int> offlineLevels = GeneratedColumn<int>(
      'offline_levels', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        lastModifiedDate,
        createdDate,
        displayName,
        label,
        translations,
        name,
        code,
        level,
        offlineLevels
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ou_levels';
  @override
  VerificationContext validateIntegrity(Insertable<OuLevel> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('last_modified_date')) {
      context.handle(
          _lastModifiedDateMeta,
          lastModifiedDate.isAcceptableOrUnknown(
              data['last_modified_date']!, _lastModifiedDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('display_name')) {
      context.handle(
          _displayNameMeta,
          displayName.isAcceptableOrUnknown(
              data['display_name']!, _displayNameMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('level')) {
      context.handle(
          _levelMeta, level.isAcceptableOrUnknown(data['level']!, _levelMeta));
    } else if (isInserting) {
      context.missing(_levelMeta);
    }
    if (data.containsKey('offline_levels')) {
      context.handle(
          _offlineLevelsMeta,
          offlineLevels.isAcceptableOrUnknown(
              data['offline_levels']!, _offlineLevelsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OuLevel map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OuLevel(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      lastModifiedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_modified_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_date']),
      displayName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}display_name']),
      label: $OuLevelsTable.$converterlabel.fromSql(attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}label'])),
      translations: $OuLevelsTable.$convertertranslations.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}translations'])!),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      level: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}level'])!,
      offlineLevels: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}offline_levels']),
    );
  }

  @override
  $OuLevelsTable createAlias(String alias) {
    return $OuLevelsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>?, String?> $converterlabel =
      const NullAwareMapConverter();
  static TypeConverter<List<Translation>, String> $convertertranslations =
      const TranslationConverter();
}

class OuLevel extends DataClass implements Insertable<OuLevel> {
  final String id;
  final DateTime? lastModifiedDate;
  final DateTime? createdDate;
  final String? displayName;
  final Map<String, dynamic>? label;
  final List<Translation> translations;
  final String name;
  final String? code;
  final int level;
  final int? offlineLevels;
  const OuLevel(
      {required this.id,
      this.lastModifiedDate,
      this.createdDate,
      this.displayName,
      this.label,
      required this.translations,
      required this.name,
      this.code,
      required this.level,
      this.offlineLevels});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || lastModifiedDate != null) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<DateTime>(createdDate);
    }
    if (!nullToAbsent || displayName != null) {
      map['display_name'] = Variable<String>(displayName);
    }
    if (!nullToAbsent || label != null) {
      map['label'] =
          Variable<String>($OuLevelsTable.$converterlabel.toSql(label));
    }
    {
      map['translations'] = Variable<String>(
          $OuLevelsTable.$convertertranslations.toSql(translations));
    }
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    map['level'] = Variable<int>(level);
    if (!nullToAbsent || offlineLevels != null) {
      map['offline_levels'] = Variable<int>(offlineLevels);
    }
    return map;
  }

  OuLevelsCompanion toCompanion(bool nullToAbsent) {
    return OuLevelsCompanion(
      id: Value(id),
      lastModifiedDate: lastModifiedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      displayName: displayName == null && nullToAbsent
          ? const Value.absent()
          : Value(displayName),
      label:
          label == null && nullToAbsent ? const Value.absent() : Value(label),
      translations: Value(translations),
      name: Value(name),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      level: Value(level),
      offlineLevels: offlineLevels == null && nullToAbsent
          ? const Value.absent()
          : Value(offlineLevels),
    );
  }

  factory OuLevel.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OuLevel(
      id: serializer.fromJson<String>(json['id']),
      lastModifiedDate:
          serializer.fromJson<DateTime?>(json['lastModifiedDate']),
      createdDate: serializer.fromJson<DateTime?>(json['createdDate']),
      displayName: serializer.fromJson<String?>(json['displayName']),
      label: serializer.fromJson<Map<String, dynamic>?>(json['label']),
      translations:
          serializer.fromJson<List<Translation>>(json['translations']),
      name: serializer.fromJson<String>(json['name']),
      code: serializer.fromJson<String?>(json['code']),
      level: serializer.fromJson<int>(json['level']),
      offlineLevels: serializer.fromJson<int?>(json['offlineLevels']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'lastModifiedDate': serializer.toJson<DateTime?>(lastModifiedDate),
      'createdDate': serializer.toJson<DateTime?>(createdDate),
      'displayName': serializer.toJson<String?>(displayName),
      'label': serializer.toJson<Map<String, dynamic>?>(label),
      'translations': serializer.toJson<List<Translation>>(translations),
      'name': serializer.toJson<String>(name),
      'code': serializer.toJson<String?>(code),
      'level': serializer.toJson<int>(level),
      'offlineLevels': serializer.toJson<int?>(offlineLevels),
    };
  }

  OuLevel copyWith(
          {String? id,
          Value<DateTime?> lastModifiedDate = const Value.absent(),
          Value<DateTime?> createdDate = const Value.absent(),
          Value<String?> displayName = const Value.absent(),
          Value<Map<String, dynamic>?> label = const Value.absent(),
          List<Translation>? translations,
          String? name,
          Value<String?> code = const Value.absent(),
          int? level,
          Value<int?> offlineLevels = const Value.absent()}) =>
      OuLevel(
        id: id ?? this.id,
        lastModifiedDate: lastModifiedDate.present
            ? lastModifiedDate.value
            : this.lastModifiedDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        displayName: displayName.present ? displayName.value : this.displayName,
        label: label.present ? label.value : this.label,
        translations: translations ?? this.translations,
        name: name ?? this.name,
        code: code.present ? code.value : this.code,
        level: level ?? this.level,
        offlineLevels:
            offlineLevels.present ? offlineLevels.value : this.offlineLevels,
      );
  OuLevel copyWithCompanion(OuLevelsCompanion data) {
    return OuLevel(
      id: data.id.present ? data.id.value : this.id,
      lastModifiedDate: data.lastModifiedDate.present
          ? data.lastModifiedDate.value
          : this.lastModifiedDate,
      createdDate:
          data.createdDate.present ? data.createdDate.value : this.createdDate,
      displayName:
          data.displayName.present ? data.displayName.value : this.displayName,
      label: data.label.present ? data.label.value : this.label,
      translations: data.translations.present
          ? data.translations.value
          : this.translations,
      name: data.name.present ? data.name.value : this.name,
      code: data.code.present ? data.code.value : this.code,
      level: data.level.present ? data.level.value : this.level,
      offlineLevels: data.offlineLevels.present
          ? data.offlineLevels.value
          : this.offlineLevels,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OuLevel(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('displayName: $displayName, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('level: $level, ')
          ..write('offlineLevels: $offlineLevels')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, lastModifiedDate, createdDate,
      displayName, label, translations, name, code, level, offlineLevels);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OuLevel &&
          other.id == this.id &&
          other.lastModifiedDate == this.lastModifiedDate &&
          other.createdDate == this.createdDate &&
          other.displayName == this.displayName &&
          other.label == this.label &&
          other.translations == this.translations &&
          other.name == this.name &&
          other.code == this.code &&
          other.level == this.level &&
          other.offlineLevels == this.offlineLevels);
}

class OuLevelsCompanion extends UpdateCompanion<OuLevel> {
  final Value<String> id;
  final Value<DateTime?> lastModifiedDate;
  final Value<DateTime?> createdDate;
  final Value<String?> displayName;
  final Value<Map<String, dynamic>?> label;
  final Value<List<Translation>> translations;
  final Value<String> name;
  final Value<String?> code;
  final Value<int> level;
  final Value<int?> offlineLevels;
  final Value<int> rowid;
  const OuLevelsCompanion({
    this.id = const Value.absent(),
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.displayName = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    this.name = const Value.absent(),
    this.code = const Value.absent(),
    this.level = const Value.absent(),
    this.offlineLevels = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OuLevelsCompanion.insert({
    required String id,
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.displayName = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    required String name,
    this.code = const Value.absent(),
    required int level,
    this.offlineLevels = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        name = Value(name),
        level = Value(level);
  static Insertable<OuLevel> custom({
    Expression<String>? id,
    Expression<DateTime>? lastModifiedDate,
    Expression<DateTime>? createdDate,
    Expression<String>? displayName,
    Expression<String>? label,
    Expression<String>? translations,
    Expression<String>? name,
    Expression<String>? code,
    Expression<int>? level,
    Expression<int>? offlineLevels,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (lastModifiedDate != null) 'last_modified_date': lastModifiedDate,
      if (createdDate != null) 'created_date': createdDate,
      if (displayName != null) 'display_name': displayName,
      if (label != null) 'label': label,
      if (translations != null) 'translations': translations,
      if (name != null) 'name': name,
      if (code != null) 'code': code,
      if (level != null) 'level': level,
      if (offlineLevels != null) 'offline_levels': offlineLevels,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OuLevelsCompanion copyWith(
      {Value<String>? id,
      Value<DateTime?>? lastModifiedDate,
      Value<DateTime?>? createdDate,
      Value<String?>? displayName,
      Value<Map<String, dynamic>?>? label,
      Value<List<Translation>>? translations,
      Value<String>? name,
      Value<String?>? code,
      Value<int>? level,
      Value<int?>? offlineLevels,
      Value<int>? rowid}) {
    return OuLevelsCompanion(
      id: id ?? this.id,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      createdDate: createdDate ?? this.createdDate,
      displayName: displayName ?? this.displayName,
      label: label ?? this.label,
      translations: translations ?? this.translations,
      name: name ?? this.name,
      code: code ?? this.code,
      level: level ?? this.level,
      offlineLevels: offlineLevels ?? this.offlineLevels,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (lastModifiedDate.present) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<DateTime>(createdDate.value);
    }
    if (displayName.present) {
      map['display_name'] = Variable<String>(displayName.value);
    }
    if (label.present) {
      map['label'] =
          Variable<String>($OuLevelsTable.$converterlabel.toSql(label.value));
    }
    if (translations.present) {
      map['translations'] = Variable<String>(
          $OuLevelsTable.$convertertranslations.toSql(translations.value));
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (level.present) {
      map['level'] = Variable<int>(level.value);
    }
    if (offlineLevels.present) {
      map['offline_levels'] = Variable<int>(offlineLevels.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OuLevelsCompanion(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('displayName: $displayName, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('level: $level, ')
          ..write('offlineLevels: $offlineLevels, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProjectsTable extends Projects with TableInfo<$ProjectsTable, Project> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProjectsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _lastModifiedDateMeta =
      const VerificationMeta('lastModifiedDate');
  @override
  late final GeneratedColumn<DateTime> lastModifiedDate =
      GeneratedColumn<DateTime>('last_modified_date', aliasedName, true,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<DateTime> createdDate = GeneratedColumn<DateTime>(
      'created_date', aliasedName, true,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _displayNameMeta =
      const VerificationMeta('displayName');
  @override
  late final GeneratedColumn<String> displayName = GeneratedColumn<String>(
      'display_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
      label = GeneratedColumn<String>('label', aliasedName, true,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '{}')
          .withConverter<Map<String, dynamic>?>($ProjectsTable.$converterlabel);
  @override
  late final GeneratedColumnWithTypeConverter<List<Translation>, String>
      translations = GeneratedColumn<String>('translations', aliasedName, false,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '[]')
          .withConverter<List<Translation>>(
              $ProjectsTable.$convertertranslations);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _disabledMeta =
      const VerificationMeta('disabled');
  @override
  late final GeneratedColumn<bool> disabled = GeneratedColumn<bool>(
      'disabled', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("disabled" IN (0, 1))'),
      clientDefault: () => false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        lastModifiedDate,
        createdDate,
        displayName,
        label,
        translations,
        name,
        code,
        disabled
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'projects';
  @override
  VerificationContext validateIntegrity(Insertable<Project> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('last_modified_date')) {
      context.handle(
          _lastModifiedDateMeta,
          lastModifiedDate.isAcceptableOrUnknown(
              data['last_modified_date']!, _lastModifiedDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('display_name')) {
      context.handle(
          _displayNameMeta,
          displayName.isAcceptableOrUnknown(
              data['display_name']!, _displayNameMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('disabled')) {
      context.handle(_disabledMeta,
          disabled.isAcceptableOrUnknown(data['disabled']!, _disabledMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Project map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Project(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      lastModifiedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_modified_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_date']),
      displayName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}display_name']),
      label: $ProjectsTable.$converterlabel.fromSql(attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}label'])),
      translations: $ProjectsTable.$convertertranslations.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}translations'])!),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      disabled: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}disabled'])!,
    );
  }

  @override
  $ProjectsTable createAlias(String alias) {
    return $ProjectsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>?, String?> $converterlabel =
      const NullAwareMapConverter();
  static TypeConverter<List<Translation>, String> $convertertranslations =
      const TranslationConverter();
}

class Project extends DataClass implements Insertable<Project> {
  final String id;
  final DateTime? lastModifiedDate;
  final DateTime? createdDate;
  final String? displayName;
  final Map<String, dynamic>? label;
  final List<Translation> translations;
  final String name;
  final String? code;
  final bool disabled;
  const Project(
      {required this.id,
      this.lastModifiedDate,
      this.createdDate,
      this.displayName,
      this.label,
      required this.translations,
      required this.name,
      this.code,
      required this.disabled});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || lastModifiedDate != null) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<DateTime>(createdDate);
    }
    if (!nullToAbsent || displayName != null) {
      map['display_name'] = Variable<String>(displayName);
    }
    if (!nullToAbsent || label != null) {
      map['label'] =
          Variable<String>($ProjectsTable.$converterlabel.toSql(label));
    }
    {
      map['translations'] = Variable<String>(
          $ProjectsTable.$convertertranslations.toSql(translations));
    }
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    map['disabled'] = Variable<bool>(disabled);
    return map;
  }

  ProjectsCompanion toCompanion(bool nullToAbsent) {
    return ProjectsCompanion(
      id: Value(id),
      lastModifiedDate: lastModifiedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      displayName: displayName == null && nullToAbsent
          ? const Value.absent()
          : Value(displayName),
      label:
          label == null && nullToAbsent ? const Value.absent() : Value(label),
      translations: Value(translations),
      name: Value(name),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      disabled: Value(disabled),
    );
  }

  factory Project.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Project(
      id: serializer.fromJson<String>(json['id']),
      lastModifiedDate:
          serializer.fromJson<DateTime?>(json['lastModifiedDate']),
      createdDate: serializer.fromJson<DateTime?>(json['createdDate']),
      displayName: serializer.fromJson<String?>(json['displayName']),
      label: serializer.fromJson<Map<String, dynamic>?>(json['label']),
      translations:
          serializer.fromJson<List<Translation>>(json['translations']),
      name: serializer.fromJson<String>(json['name']),
      code: serializer.fromJson<String?>(json['code']),
      disabled: serializer.fromJson<bool>(json['disabled']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'lastModifiedDate': serializer.toJson<DateTime?>(lastModifiedDate),
      'createdDate': serializer.toJson<DateTime?>(createdDate),
      'displayName': serializer.toJson<String?>(displayName),
      'label': serializer.toJson<Map<String, dynamic>?>(label),
      'translations': serializer.toJson<List<Translation>>(translations),
      'name': serializer.toJson<String>(name),
      'code': serializer.toJson<String?>(code),
      'disabled': serializer.toJson<bool>(disabled),
    };
  }

  Project copyWith(
          {String? id,
          Value<DateTime?> lastModifiedDate = const Value.absent(),
          Value<DateTime?> createdDate = const Value.absent(),
          Value<String?> displayName = const Value.absent(),
          Value<Map<String, dynamic>?> label = const Value.absent(),
          List<Translation>? translations,
          String? name,
          Value<String?> code = const Value.absent(),
          bool? disabled}) =>
      Project(
        id: id ?? this.id,
        lastModifiedDate: lastModifiedDate.present
            ? lastModifiedDate.value
            : this.lastModifiedDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        displayName: displayName.present ? displayName.value : this.displayName,
        label: label.present ? label.value : this.label,
        translations: translations ?? this.translations,
        name: name ?? this.name,
        code: code.present ? code.value : this.code,
        disabled: disabled ?? this.disabled,
      );
  Project copyWithCompanion(ProjectsCompanion data) {
    return Project(
      id: data.id.present ? data.id.value : this.id,
      lastModifiedDate: data.lastModifiedDate.present
          ? data.lastModifiedDate.value
          : this.lastModifiedDate,
      createdDate:
          data.createdDate.present ? data.createdDate.value : this.createdDate,
      displayName:
          data.displayName.present ? data.displayName.value : this.displayName,
      label: data.label.present ? data.label.value : this.label,
      translations: data.translations.present
          ? data.translations.value
          : this.translations,
      name: data.name.present ? data.name.value : this.name,
      code: data.code.present ? data.code.value : this.code,
      disabled: data.disabled.present ? data.disabled.value : this.disabled,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Project(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('displayName: $displayName, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('disabled: $disabled')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, lastModifiedDate, createdDate,
      displayName, label, translations, name, code, disabled);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Project &&
          other.id == this.id &&
          other.lastModifiedDate == this.lastModifiedDate &&
          other.createdDate == this.createdDate &&
          other.displayName == this.displayName &&
          other.label == this.label &&
          other.translations == this.translations &&
          other.name == this.name &&
          other.code == this.code &&
          other.disabled == this.disabled);
}

class ProjectsCompanion extends UpdateCompanion<Project> {
  final Value<String> id;
  final Value<DateTime?> lastModifiedDate;
  final Value<DateTime?> createdDate;
  final Value<String?> displayName;
  final Value<Map<String, dynamic>?> label;
  final Value<List<Translation>> translations;
  final Value<String> name;
  final Value<String?> code;
  final Value<bool> disabled;
  final Value<int> rowid;
  const ProjectsCompanion({
    this.id = const Value.absent(),
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.displayName = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    this.name = const Value.absent(),
    this.code = const Value.absent(),
    this.disabled = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProjectsCompanion.insert({
    required String id,
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.displayName = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    required String name,
    this.code = const Value.absent(),
    this.disabled = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        name = Value(name);
  static Insertable<Project> custom({
    Expression<String>? id,
    Expression<DateTime>? lastModifiedDate,
    Expression<DateTime>? createdDate,
    Expression<String>? displayName,
    Expression<String>? label,
    Expression<String>? translations,
    Expression<String>? name,
    Expression<String>? code,
    Expression<bool>? disabled,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (lastModifiedDate != null) 'last_modified_date': lastModifiedDate,
      if (createdDate != null) 'created_date': createdDate,
      if (displayName != null) 'display_name': displayName,
      if (label != null) 'label': label,
      if (translations != null) 'translations': translations,
      if (name != null) 'name': name,
      if (code != null) 'code': code,
      if (disabled != null) 'disabled': disabled,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProjectsCompanion copyWith(
      {Value<String>? id,
      Value<DateTime?>? lastModifiedDate,
      Value<DateTime?>? createdDate,
      Value<String?>? displayName,
      Value<Map<String, dynamic>?>? label,
      Value<List<Translation>>? translations,
      Value<String>? name,
      Value<String?>? code,
      Value<bool>? disabled,
      Value<int>? rowid}) {
    return ProjectsCompanion(
      id: id ?? this.id,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      createdDate: createdDate ?? this.createdDate,
      displayName: displayName ?? this.displayName,
      label: label ?? this.label,
      translations: translations ?? this.translations,
      name: name ?? this.name,
      code: code ?? this.code,
      disabled: disabled ?? this.disabled,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (lastModifiedDate.present) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<DateTime>(createdDate.value);
    }
    if (displayName.present) {
      map['display_name'] = Variable<String>(displayName.value);
    }
    if (label.present) {
      map['label'] =
          Variable<String>($ProjectsTable.$converterlabel.toSql(label.value));
    }
    if (translations.present) {
      map['translations'] = Variable<String>(
          $ProjectsTable.$convertertranslations.toSql(translations.value));
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (disabled.present) {
      map['disabled'] = Variable<bool>(disabled.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProjectsCompanion(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('displayName: $displayName, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('disabled: $disabled, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ActivitiesTable extends Activities
    with TableInfo<$ActivitiesTable, Activity> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ActivitiesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _lastModifiedDateMeta =
      const VerificationMeta('lastModifiedDate');
  @override
  late final GeneratedColumn<DateTime> lastModifiedDate =
      GeneratedColumn<DateTime>('last_modified_date', aliasedName, true,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<DateTime> createdDate = GeneratedColumn<DateTime>(
      'created_date', aliasedName, true,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _displayNameMeta =
      const VerificationMeta('displayName');
  @override
  late final GeneratedColumn<String> displayName = GeneratedColumn<String>(
      'display_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
      label = GeneratedColumn<String>('label', aliasedName, true,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '{}')
          .withConverter<Map<String, dynamic>?>(
              $ActivitiesTable.$converterlabel);
  @override
  late final GeneratedColumnWithTypeConverter<List<Translation>, String>
      translations = GeneratedColumn<String>('translations', aliasedName, false,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '[]')
          .withConverter<List<Translation>>(
              $ActivitiesTable.$convertertranslations);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectMeta =
      const VerificationMeta('project');
  @override
  late final GeneratedColumn<String> project = GeneratedColumn<String>(
      'project', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES projects (id)'));
  static const VerificationMeta _disabledMeta =
      const VerificationMeta('disabled');
  @override
  late final GeneratedColumn<bool> disabled = GeneratedColumn<bool>(
      'disabled', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("disabled" IN (0, 1))'),
      clientDefault: () => false);
  static const VerificationMeta _startDateMeta =
      const VerificationMeta('startDate');
  @override
  late final GeneratedColumn<DateTime> startDate = GeneratedColumn<DateTime>(
      'start_date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _endDateMeta =
      const VerificationMeta('endDate');
  @override
  late final GeneratedColumn<DateTime> endDate = GeneratedColumn<DateTime>(
      'end_date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        lastModifiedDate,
        createdDate,
        displayName,
        label,
        translations,
        name,
        code,
        project,
        disabled,
        startDate,
        endDate,
        description
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'activities';
  @override
  VerificationContext validateIntegrity(Insertable<Activity> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('last_modified_date')) {
      context.handle(
          _lastModifiedDateMeta,
          lastModifiedDate.isAcceptableOrUnknown(
              data['last_modified_date']!, _lastModifiedDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('display_name')) {
      context.handle(
          _displayNameMeta,
          displayName.isAcceptableOrUnknown(
              data['display_name']!, _displayNameMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('project')) {
      context.handle(_projectMeta,
          project.isAcceptableOrUnknown(data['project']!, _projectMeta));
    } else if (isInserting) {
      context.missing(_projectMeta);
    }
    if (data.containsKey('disabled')) {
      context.handle(_disabledMeta,
          disabled.isAcceptableOrUnknown(data['disabled']!, _disabledMeta));
    }
    if (data.containsKey('start_date')) {
      context.handle(_startDateMeta,
          startDate.isAcceptableOrUnknown(data['start_date']!, _startDateMeta));
    }
    if (data.containsKey('end_date')) {
      context.handle(_endDateMeta,
          endDate.isAcceptableOrUnknown(data['end_date']!, _endDateMeta));
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Activity map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Activity(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      lastModifiedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_modified_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_date']),
      displayName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}display_name']),
      label: $ActivitiesTable.$converterlabel.fromSql(attachedDatabase
          .typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}label'])),
      translations: $ActivitiesTable.$convertertranslations.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}translations'])!),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      project: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project'])!,
      disabled: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}disabled'])!,
      startDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}start_date']),
      endDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}end_date']),
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
    );
  }

  @override
  $ActivitiesTable createAlias(String alias) {
    return $ActivitiesTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>?, String?> $converterlabel =
      const NullAwareMapConverter();
  static TypeConverter<List<Translation>, String> $convertertranslations =
      const TranslationConverter();
}

class Activity extends DataClass implements Insertable<Activity> {
  final String id;
  final DateTime? lastModifiedDate;
  final DateTime? createdDate;
  final String? displayName;
  final Map<String, dynamic>? label;
  final List<Translation> translations;
  final String name;
  final String? code;
  final String project;
  final bool disabled;
  final DateTime? startDate;
  final DateTime? endDate;
  final String? description;
  const Activity(
      {required this.id,
      this.lastModifiedDate,
      this.createdDate,
      this.displayName,
      this.label,
      required this.translations,
      required this.name,
      this.code,
      required this.project,
      required this.disabled,
      this.startDate,
      this.endDate,
      this.description});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || lastModifiedDate != null) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<DateTime>(createdDate);
    }
    if (!nullToAbsent || displayName != null) {
      map['display_name'] = Variable<String>(displayName);
    }
    if (!nullToAbsent || label != null) {
      map['label'] =
          Variable<String>($ActivitiesTable.$converterlabel.toSql(label));
    }
    {
      map['translations'] = Variable<String>(
          $ActivitiesTable.$convertertranslations.toSql(translations));
    }
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    map['project'] = Variable<String>(project);
    map['disabled'] = Variable<bool>(disabled);
    if (!nullToAbsent || startDate != null) {
      map['start_date'] = Variable<DateTime>(startDate);
    }
    if (!nullToAbsent || endDate != null) {
      map['end_date'] = Variable<DateTime>(endDate);
    }
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    return map;
  }

  ActivitiesCompanion toCompanion(bool nullToAbsent) {
    return ActivitiesCompanion(
      id: Value(id),
      lastModifiedDate: lastModifiedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      displayName: displayName == null && nullToAbsent
          ? const Value.absent()
          : Value(displayName),
      label:
          label == null && nullToAbsent ? const Value.absent() : Value(label),
      translations: Value(translations),
      name: Value(name),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      project: Value(project),
      disabled: Value(disabled),
      startDate: startDate == null && nullToAbsent
          ? const Value.absent()
          : Value(startDate),
      endDate: endDate == null && nullToAbsent
          ? const Value.absent()
          : Value(endDate),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
    );
  }

  factory Activity.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Activity(
      id: serializer.fromJson<String>(json['id']),
      lastModifiedDate:
          serializer.fromJson<DateTime?>(json['lastModifiedDate']),
      createdDate: serializer.fromJson<DateTime?>(json['createdDate']),
      displayName: serializer.fromJson<String?>(json['displayName']),
      label: serializer.fromJson<Map<String, dynamic>?>(json['label']),
      translations:
          serializer.fromJson<List<Translation>>(json['translations']),
      name: serializer.fromJson<String>(json['name']),
      code: serializer.fromJson<String?>(json['code']),
      project: serializer.fromJson<String>(json['project']),
      disabled: serializer.fromJson<bool>(json['disabled']),
      startDate: serializer.fromJson<DateTime?>(json['startDate']),
      endDate: serializer.fromJson<DateTime?>(json['endDate']),
      description: serializer.fromJson<String?>(json['description']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'lastModifiedDate': serializer.toJson<DateTime?>(lastModifiedDate),
      'createdDate': serializer.toJson<DateTime?>(createdDate),
      'displayName': serializer.toJson<String?>(displayName),
      'label': serializer.toJson<Map<String, dynamic>?>(label),
      'translations': serializer.toJson<List<Translation>>(translations),
      'name': serializer.toJson<String>(name),
      'code': serializer.toJson<String?>(code),
      'project': serializer.toJson<String>(project),
      'disabled': serializer.toJson<bool>(disabled),
      'startDate': serializer.toJson<DateTime?>(startDate),
      'endDate': serializer.toJson<DateTime?>(endDate),
      'description': serializer.toJson<String?>(description),
    };
  }

  Activity copyWith(
          {String? id,
          Value<DateTime?> lastModifiedDate = const Value.absent(),
          Value<DateTime?> createdDate = const Value.absent(),
          Value<String?> displayName = const Value.absent(),
          Value<Map<String, dynamic>?> label = const Value.absent(),
          List<Translation>? translations,
          String? name,
          Value<String?> code = const Value.absent(),
          String? project,
          bool? disabled,
          Value<DateTime?> startDate = const Value.absent(),
          Value<DateTime?> endDate = const Value.absent(),
          Value<String?> description = const Value.absent()}) =>
      Activity(
        id: id ?? this.id,
        lastModifiedDate: lastModifiedDate.present
            ? lastModifiedDate.value
            : this.lastModifiedDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        displayName: displayName.present ? displayName.value : this.displayName,
        label: label.present ? label.value : this.label,
        translations: translations ?? this.translations,
        name: name ?? this.name,
        code: code.present ? code.value : this.code,
        project: project ?? this.project,
        disabled: disabled ?? this.disabled,
        startDate: startDate.present ? startDate.value : this.startDate,
        endDate: endDate.present ? endDate.value : this.endDate,
        description: description.present ? description.value : this.description,
      );
  Activity copyWithCompanion(ActivitiesCompanion data) {
    return Activity(
      id: data.id.present ? data.id.value : this.id,
      lastModifiedDate: data.lastModifiedDate.present
          ? data.lastModifiedDate.value
          : this.lastModifiedDate,
      createdDate:
          data.createdDate.present ? data.createdDate.value : this.createdDate,
      displayName:
          data.displayName.present ? data.displayName.value : this.displayName,
      label: data.label.present ? data.label.value : this.label,
      translations: data.translations.present
          ? data.translations.value
          : this.translations,
      name: data.name.present ? data.name.value : this.name,
      code: data.code.present ? data.code.value : this.code,
      project: data.project.present ? data.project.value : this.project,
      disabled: data.disabled.present ? data.disabled.value : this.disabled,
      startDate: data.startDate.present ? data.startDate.value : this.startDate,
      endDate: data.endDate.present ? data.endDate.value : this.endDate,
      description:
          data.description.present ? data.description.value : this.description,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Activity(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('displayName: $displayName, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('project: $project, ')
          ..write('disabled: $disabled, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('description: $description')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      lastModifiedDate,
      createdDate,
      displayName,
      label,
      translations,
      name,
      code,
      project,
      disabled,
      startDate,
      endDate,
      description);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Activity &&
          other.id == this.id &&
          other.lastModifiedDate == this.lastModifiedDate &&
          other.createdDate == this.createdDate &&
          other.displayName == this.displayName &&
          other.label == this.label &&
          other.translations == this.translations &&
          other.name == this.name &&
          other.code == this.code &&
          other.project == this.project &&
          other.disabled == this.disabled &&
          other.startDate == this.startDate &&
          other.endDate == this.endDate &&
          other.description == this.description);
}

class ActivitiesCompanion extends UpdateCompanion<Activity> {
  final Value<String> id;
  final Value<DateTime?> lastModifiedDate;
  final Value<DateTime?> createdDate;
  final Value<String?> displayName;
  final Value<Map<String, dynamic>?> label;
  final Value<List<Translation>> translations;
  final Value<String> name;
  final Value<String?> code;
  final Value<String> project;
  final Value<bool> disabled;
  final Value<DateTime?> startDate;
  final Value<DateTime?> endDate;
  final Value<String?> description;
  final Value<int> rowid;
  const ActivitiesCompanion({
    this.id = const Value.absent(),
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.displayName = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    this.name = const Value.absent(),
    this.code = const Value.absent(),
    this.project = const Value.absent(),
    this.disabled = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.description = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ActivitiesCompanion.insert({
    required String id,
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.displayName = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    required String name,
    this.code = const Value.absent(),
    required String project,
    this.disabled = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.description = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        name = Value(name),
        project = Value(project);
  static Insertable<Activity> custom({
    Expression<String>? id,
    Expression<DateTime>? lastModifiedDate,
    Expression<DateTime>? createdDate,
    Expression<String>? displayName,
    Expression<String>? label,
    Expression<String>? translations,
    Expression<String>? name,
    Expression<String>? code,
    Expression<String>? project,
    Expression<bool>? disabled,
    Expression<DateTime>? startDate,
    Expression<DateTime>? endDate,
    Expression<String>? description,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (lastModifiedDate != null) 'last_modified_date': lastModifiedDate,
      if (createdDate != null) 'created_date': createdDate,
      if (displayName != null) 'display_name': displayName,
      if (label != null) 'label': label,
      if (translations != null) 'translations': translations,
      if (name != null) 'name': name,
      if (code != null) 'code': code,
      if (project != null) 'project': project,
      if (disabled != null) 'disabled': disabled,
      if (startDate != null) 'start_date': startDate,
      if (endDate != null) 'end_date': endDate,
      if (description != null) 'description': description,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ActivitiesCompanion copyWith(
      {Value<String>? id,
      Value<DateTime?>? lastModifiedDate,
      Value<DateTime?>? createdDate,
      Value<String?>? displayName,
      Value<Map<String, dynamic>?>? label,
      Value<List<Translation>>? translations,
      Value<String>? name,
      Value<String?>? code,
      Value<String>? project,
      Value<bool>? disabled,
      Value<DateTime?>? startDate,
      Value<DateTime?>? endDate,
      Value<String?>? description,
      Value<int>? rowid}) {
    return ActivitiesCompanion(
      id: id ?? this.id,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      createdDate: createdDate ?? this.createdDate,
      displayName: displayName ?? this.displayName,
      label: label ?? this.label,
      translations: translations ?? this.translations,
      name: name ?? this.name,
      code: code ?? this.code,
      project: project ?? this.project,
      disabled: disabled ?? this.disabled,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      description: description ?? this.description,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (lastModifiedDate.present) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<DateTime>(createdDate.value);
    }
    if (displayName.present) {
      map['display_name'] = Variable<String>(displayName.value);
    }
    if (label.present) {
      map['label'] =
          Variable<String>($ActivitiesTable.$converterlabel.toSql(label.value));
    }
    if (translations.present) {
      map['translations'] = Variable<String>(
          $ActivitiesTable.$convertertranslations.toSql(translations.value));
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (project.present) {
      map['project'] = Variable<String>(project.value);
    }
    if (disabled.present) {
      map['disabled'] = Variable<bool>(disabled.value);
    }
    if (startDate.present) {
      map['start_date'] = Variable<DateTime>(startDate.value);
    }
    if (endDate.present) {
      map['end_date'] = Variable<DateTime>(endDate.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ActivitiesCompanion(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('displayName: $displayName, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('project: $project, ')
          ..write('disabled: $disabled, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('description: $description, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $TeamsTable extends Teams with TableInfo<$TeamsTable, Team> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TeamsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _lastModifiedDateMeta =
      const VerificationMeta('lastModifiedDate');
  @override
  late final GeneratedColumn<DateTime> lastModifiedDate =
      GeneratedColumn<DateTime>('last_modified_date', aliasedName, true,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<DateTime> createdDate = GeneratedColumn<DateTime>(
      'created_date', aliasedName, true,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _disabledMeta =
      const VerificationMeta('disabled');
  @override
  late final GeneratedColumn<bool> disabled = GeneratedColumn<bool>(
      'disabled', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("disabled" IN (0, 1))'));
  static const VerificationMeta _activityMeta =
      const VerificationMeta('activity');
  @override
  late final GeneratedColumn<String> activity = GeneratedColumn<String>(
      'activity', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES activities (id)'));
  static const VerificationMeta _userMeta = const VerificationMeta('user');
  @override
  late final GeneratedColumn<String> user = GeneratedColumn<String>(
      'user', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES users (id)'));
  @override
  List<GeneratedColumn> get $columns =>
      [id, lastModifiedDate, createdDate, code, disabled, activity, user];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'teams';
  @override
  VerificationContext validateIntegrity(Insertable<Team> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('last_modified_date')) {
      context.handle(
          _lastModifiedDateMeta,
          lastModifiedDate.isAcceptableOrUnknown(
              data['last_modified_date']!, _lastModifiedDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('disabled')) {
      context.handle(_disabledMeta,
          disabled.isAcceptableOrUnknown(data['disabled']!, _disabledMeta));
    }
    if (data.containsKey('activity')) {
      context.handle(_activityMeta,
          activity.isAcceptableOrUnknown(data['activity']!, _activityMeta));
    } else if (isInserting) {
      context.missing(_activityMeta);
    }
    if (data.containsKey('user')) {
      context.handle(
          _userMeta, user.isAcceptableOrUnknown(data['user']!, _userMeta));
    } else if (isInserting) {
      context.missing(_userMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Team map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Team(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      lastModifiedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_modified_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_date']),
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      disabled: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}disabled']),
      activity: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}activity'])!,
      user: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user'])!,
    );
  }

  @override
  $TeamsTable createAlias(String alias) {
    return $TeamsTable(attachedDatabase, alias);
  }
}

class Team extends DataClass implements Insertable<Team> {
  final String id;
  final DateTime? lastModifiedDate;
  final DateTime? createdDate;
  final String? code;
  final bool? disabled;
  final String activity;
  final String user;
  const Team(
      {required this.id,
      this.lastModifiedDate,
      this.createdDate,
      this.code,
      this.disabled,
      required this.activity,
      required this.user});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || lastModifiedDate != null) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<DateTime>(createdDate);
    }
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    if (!nullToAbsent || disabled != null) {
      map['disabled'] = Variable<bool>(disabled);
    }
    map['activity'] = Variable<String>(activity);
    map['user'] = Variable<String>(user);
    return map;
  }

  TeamsCompanion toCompanion(bool nullToAbsent) {
    return TeamsCompanion(
      id: Value(id),
      lastModifiedDate: lastModifiedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      disabled: disabled == null && nullToAbsent
          ? const Value.absent()
          : Value(disabled),
      activity: Value(activity),
      user: Value(user),
    );
  }

  factory Team.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Team(
      id: serializer.fromJson<String>(json['id']),
      lastModifiedDate:
          serializer.fromJson<DateTime?>(json['lastModifiedDate']),
      createdDate: serializer.fromJson<DateTime?>(json['createdDate']),
      code: serializer.fromJson<String?>(json['code']),
      disabled: serializer.fromJson<bool?>(json['disabled']),
      activity: serializer.fromJson<String>(json['activity']),
      user: serializer.fromJson<String>(json['user']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'lastModifiedDate': serializer.toJson<DateTime?>(lastModifiedDate),
      'createdDate': serializer.toJson<DateTime?>(createdDate),
      'code': serializer.toJson<String?>(code),
      'disabled': serializer.toJson<bool?>(disabled),
      'activity': serializer.toJson<String>(activity),
      'user': serializer.toJson<String>(user),
    };
  }

  Team copyWith(
          {String? id,
          Value<DateTime?> lastModifiedDate = const Value.absent(),
          Value<DateTime?> createdDate = const Value.absent(),
          Value<String?> code = const Value.absent(),
          Value<bool?> disabled = const Value.absent(),
          String? activity,
          String? user}) =>
      Team(
        id: id ?? this.id,
        lastModifiedDate: lastModifiedDate.present
            ? lastModifiedDate.value
            : this.lastModifiedDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        code: code.present ? code.value : this.code,
        disabled: disabled.present ? disabled.value : this.disabled,
        activity: activity ?? this.activity,
        user: user ?? this.user,
      );
  Team copyWithCompanion(TeamsCompanion data) {
    return Team(
      id: data.id.present ? data.id.value : this.id,
      lastModifiedDate: data.lastModifiedDate.present
          ? data.lastModifiedDate.value
          : this.lastModifiedDate,
      createdDate:
          data.createdDate.present ? data.createdDate.value : this.createdDate,
      code: data.code.present ? data.code.value : this.code,
      disabled: data.disabled.present ? data.disabled.value : this.disabled,
      activity: data.activity.present ? data.activity.value : this.activity,
      user: data.user.present ? data.user.value : this.user,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Team(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('code: $code, ')
          ..write('disabled: $disabled, ')
          ..write('activity: $activity, ')
          ..write('user: $user')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, lastModifiedDate, createdDate, code, disabled, activity, user);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Team &&
          other.id == this.id &&
          other.lastModifiedDate == this.lastModifiedDate &&
          other.createdDate == this.createdDate &&
          other.code == this.code &&
          other.disabled == this.disabled &&
          other.activity == this.activity &&
          other.user == this.user);
}

class TeamsCompanion extends UpdateCompanion<Team> {
  final Value<String> id;
  final Value<DateTime?> lastModifiedDate;
  final Value<DateTime?> createdDate;
  final Value<String?> code;
  final Value<bool?> disabled;
  final Value<String> activity;
  final Value<String> user;
  final Value<int> rowid;
  const TeamsCompanion({
    this.id = const Value.absent(),
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.code = const Value.absent(),
    this.disabled = const Value.absent(),
    this.activity = const Value.absent(),
    this.user = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  TeamsCompanion.insert({
    required String id,
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.code = const Value.absent(),
    this.disabled = const Value.absent(),
    required String activity,
    required String user,
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        activity = Value(activity),
        user = Value(user);
  static Insertable<Team> custom({
    Expression<String>? id,
    Expression<DateTime>? lastModifiedDate,
    Expression<DateTime>? createdDate,
    Expression<String>? code,
    Expression<bool>? disabled,
    Expression<String>? activity,
    Expression<String>? user,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (lastModifiedDate != null) 'last_modified_date': lastModifiedDate,
      if (createdDate != null) 'created_date': createdDate,
      if (code != null) 'code': code,
      if (disabled != null) 'disabled': disabled,
      if (activity != null) 'activity': activity,
      if (user != null) 'user': user,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TeamsCompanion copyWith(
      {Value<String>? id,
      Value<DateTime?>? lastModifiedDate,
      Value<DateTime?>? createdDate,
      Value<String?>? code,
      Value<bool?>? disabled,
      Value<String>? activity,
      Value<String>? user,
      Value<int>? rowid}) {
    return TeamsCompanion(
      id: id ?? this.id,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      createdDate: createdDate ?? this.createdDate,
      code: code ?? this.code,
      disabled: disabled ?? this.disabled,
      activity: activity ?? this.activity,
      user: user ?? this.user,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (lastModifiedDate.present) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<DateTime>(createdDate.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (disabled.present) {
      map['disabled'] = Variable<bool>(disabled.value);
    }
    if (activity.present) {
      map['activity'] = Variable<String>(activity.value);
    }
    if (user.present) {
      map['user'] = Variable<String>(user.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TeamsCompanion(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('code: $code, ')
          ..write('disabled: $disabled, ')
          ..write('activity: $activity, ')
          ..write('user: $user, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ManagedTeamsTable extends ManagedTeams
    with TableInfo<$ManagedTeamsTable, ManagedTeam> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ManagedTeamsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _lastModifiedDateMeta =
      const VerificationMeta('lastModifiedDate');
  @override
  late final GeneratedColumn<DateTime> lastModifiedDate =
      GeneratedColumn<DateTime>('last_modified_date', aliasedName, true,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<DateTime> createdDate = GeneratedColumn<DateTime>(
      'created_date', aliasedName, true,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _disabledMeta =
      const VerificationMeta('disabled');
  @override
  late final GeneratedColumn<bool> disabled = GeneratedColumn<bool>(
      'disabled', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("disabled" IN (0, 1))'));
  static const VerificationMeta _activityMeta =
      const VerificationMeta('activity');
  @override
  late final GeneratedColumn<String> activity = GeneratedColumn<String>(
      'activity', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES activities (id)'));
  static const VerificationMeta _userMeta = const VerificationMeta('user');
  @override
  late final GeneratedColumn<String> user = GeneratedColumn<String>(
      'user', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES users (id)'));
  @override
  late final GeneratedColumnWithTypeConverter<List<dynamic>, String> teamUsers =
      GeneratedColumn<String>('team_users', aliasedName, false,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '[]')
          .withConverter<List<dynamic>>($ManagedTeamsTable.$converterteamUsers);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        lastModifiedDate,
        createdDate,
        code,
        disabled,
        activity,
        user,
        teamUsers
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'managed_teams';
  @override
  VerificationContext validateIntegrity(Insertable<ManagedTeam> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('last_modified_date')) {
      context.handle(
          _lastModifiedDateMeta,
          lastModifiedDate.isAcceptableOrUnknown(
              data['last_modified_date']!, _lastModifiedDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('disabled')) {
      context.handle(_disabledMeta,
          disabled.isAcceptableOrUnknown(data['disabled']!, _disabledMeta));
    }
    if (data.containsKey('activity')) {
      context.handle(_activityMeta,
          activity.isAcceptableOrUnknown(data['activity']!, _activityMeta));
    } else if (isInserting) {
      context.missing(_activityMeta);
    }
    if (data.containsKey('user')) {
      context.handle(
          _userMeta, user.isAcceptableOrUnknown(data['user']!, _userMeta));
    } else if (isInserting) {
      context.missing(_userMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ManagedTeam map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ManagedTeam(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      lastModifiedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_modified_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_date']),
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      disabled: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}disabled']),
      activity: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}activity'])!,
      user: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user'])!,
      teamUsers: $ManagedTeamsTable.$converterteamUsers.fromSql(attachedDatabase
          .typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}team_users'])!),
    );
  }

  @override
  $ManagedTeamsTable createAlias(String alias) {
    return $ManagedTeamsTable(attachedDatabase, alias);
  }

  static TypeConverter<List<dynamic>, String> $converterteamUsers =
      const TeamUsersConverter();
}

class ManagedTeam extends DataClass implements Insertable<ManagedTeam> {
  final String id;
  final DateTime? lastModifiedDate;
  final DateTime? createdDate;
  final String? code;
  final bool? disabled;
  final String activity;
  final String user;
  final List<dynamic> teamUsers;
  const ManagedTeam(
      {required this.id,
      this.lastModifiedDate,
      this.createdDate,
      this.code,
      this.disabled,
      required this.activity,
      required this.user,
      required this.teamUsers});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || lastModifiedDate != null) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<DateTime>(createdDate);
    }
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    if (!nullToAbsent || disabled != null) {
      map['disabled'] = Variable<bool>(disabled);
    }
    map['activity'] = Variable<String>(activity);
    map['user'] = Variable<String>(user);
    {
      map['team_users'] = Variable<String>(
          $ManagedTeamsTable.$converterteamUsers.toSql(teamUsers));
    }
    return map;
  }

  ManagedTeamsCompanion toCompanion(bool nullToAbsent) {
    return ManagedTeamsCompanion(
      id: Value(id),
      lastModifiedDate: lastModifiedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      disabled: disabled == null && nullToAbsent
          ? const Value.absent()
          : Value(disabled),
      activity: Value(activity),
      user: Value(user),
      teamUsers: Value(teamUsers),
    );
  }

  factory ManagedTeam.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ManagedTeam(
      id: serializer.fromJson<String>(json['id']),
      lastModifiedDate:
          serializer.fromJson<DateTime?>(json['lastModifiedDate']),
      createdDate: serializer.fromJson<DateTime?>(json['createdDate']),
      code: serializer.fromJson<String?>(json['code']),
      disabled: serializer.fromJson<bool?>(json['disabled']),
      activity: serializer.fromJson<String>(json['activity']),
      user: serializer.fromJson<String>(json['user']),
      teamUsers: serializer.fromJson<List<dynamic>>(json['teamUsers']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'lastModifiedDate': serializer.toJson<DateTime?>(lastModifiedDate),
      'createdDate': serializer.toJson<DateTime?>(createdDate),
      'code': serializer.toJson<String?>(code),
      'disabled': serializer.toJson<bool?>(disabled),
      'activity': serializer.toJson<String>(activity),
      'user': serializer.toJson<String>(user),
      'teamUsers': serializer.toJson<List<dynamic>>(teamUsers),
    };
  }

  ManagedTeam copyWith(
          {String? id,
          Value<DateTime?> lastModifiedDate = const Value.absent(),
          Value<DateTime?> createdDate = const Value.absent(),
          Value<String?> code = const Value.absent(),
          Value<bool?> disabled = const Value.absent(),
          String? activity,
          String? user,
          List<dynamic>? teamUsers}) =>
      ManagedTeam(
        id: id ?? this.id,
        lastModifiedDate: lastModifiedDate.present
            ? lastModifiedDate.value
            : this.lastModifiedDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        code: code.present ? code.value : this.code,
        disabled: disabled.present ? disabled.value : this.disabled,
        activity: activity ?? this.activity,
        user: user ?? this.user,
        teamUsers: teamUsers ?? this.teamUsers,
      );
  ManagedTeam copyWithCompanion(ManagedTeamsCompanion data) {
    return ManagedTeam(
      id: data.id.present ? data.id.value : this.id,
      lastModifiedDate: data.lastModifiedDate.present
          ? data.lastModifiedDate.value
          : this.lastModifiedDate,
      createdDate:
          data.createdDate.present ? data.createdDate.value : this.createdDate,
      code: data.code.present ? data.code.value : this.code,
      disabled: data.disabled.present ? data.disabled.value : this.disabled,
      activity: data.activity.present ? data.activity.value : this.activity,
      user: data.user.present ? data.user.value : this.user,
      teamUsers: data.teamUsers.present ? data.teamUsers.value : this.teamUsers,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ManagedTeam(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('code: $code, ')
          ..write('disabled: $disabled, ')
          ..write('activity: $activity, ')
          ..write('user: $user, ')
          ..write('teamUsers: $teamUsers')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, lastModifiedDate, createdDate, code,
      disabled, activity, user, teamUsers);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ManagedTeam &&
          other.id == this.id &&
          other.lastModifiedDate == this.lastModifiedDate &&
          other.createdDate == this.createdDate &&
          other.code == this.code &&
          other.disabled == this.disabled &&
          other.activity == this.activity &&
          other.user == this.user &&
          other.teamUsers == this.teamUsers);
}

class ManagedTeamsCompanion extends UpdateCompanion<ManagedTeam> {
  final Value<String> id;
  final Value<DateTime?> lastModifiedDate;
  final Value<DateTime?> createdDate;
  final Value<String?> code;
  final Value<bool?> disabled;
  final Value<String> activity;
  final Value<String> user;
  final Value<List<dynamic>> teamUsers;
  final Value<int> rowid;
  const ManagedTeamsCompanion({
    this.id = const Value.absent(),
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.code = const Value.absent(),
    this.disabled = const Value.absent(),
    this.activity = const Value.absent(),
    this.user = const Value.absent(),
    this.teamUsers = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ManagedTeamsCompanion.insert({
    required String id,
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.code = const Value.absent(),
    this.disabled = const Value.absent(),
    required String activity,
    required String user,
    this.teamUsers = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        activity = Value(activity),
        user = Value(user);
  static Insertable<ManagedTeam> custom({
    Expression<String>? id,
    Expression<DateTime>? lastModifiedDate,
    Expression<DateTime>? createdDate,
    Expression<String>? code,
    Expression<bool>? disabled,
    Expression<String>? activity,
    Expression<String>? user,
    Expression<String>? teamUsers,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (lastModifiedDate != null) 'last_modified_date': lastModifiedDate,
      if (createdDate != null) 'created_date': createdDate,
      if (code != null) 'code': code,
      if (disabled != null) 'disabled': disabled,
      if (activity != null) 'activity': activity,
      if (user != null) 'user': user,
      if (teamUsers != null) 'team_users': teamUsers,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ManagedTeamsCompanion copyWith(
      {Value<String>? id,
      Value<DateTime?>? lastModifiedDate,
      Value<DateTime?>? createdDate,
      Value<String?>? code,
      Value<bool?>? disabled,
      Value<String>? activity,
      Value<String>? user,
      Value<List<dynamic>>? teamUsers,
      Value<int>? rowid}) {
    return ManagedTeamsCompanion(
      id: id ?? this.id,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      createdDate: createdDate ?? this.createdDate,
      code: code ?? this.code,
      disabled: disabled ?? this.disabled,
      activity: activity ?? this.activity,
      user: user ?? this.user,
      teamUsers: teamUsers ?? this.teamUsers,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (lastModifiedDate.present) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<DateTime>(createdDate.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (disabled.present) {
      map['disabled'] = Variable<bool>(disabled.value);
    }
    if (activity.present) {
      map['activity'] = Variable<String>(activity.value);
    }
    if (user.present) {
      map['user'] = Variable<String>(user.value);
    }
    if (teamUsers.present) {
      map['team_users'] = Variable<String>(
          $ManagedTeamsTable.$converterteamUsers.toSql(teamUsers.value));
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ManagedTeamsCompanion(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('code: $code, ')
          ..write('disabled: $disabled, ')
          ..write('activity: $activity, ')
          ..write('user: $user, ')
          ..write('teamUsers: $teamUsers, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FlowTypesTable extends FlowTypes
    with TableInfo<$FlowTypesTable, FlowType> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FlowTypesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _lastModifiedDateMeta =
      const VerificationMeta('lastModifiedDate');
  @override
  late final GeneratedColumn<DateTime> lastModifiedDate =
      GeneratedColumn<DateTime>('last_modified_date', aliasedName, true,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<DateTime> createdDate = GeneratedColumn<DateTime>(
      'created_date', aliasedName, true,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _activityMeta =
      const VerificationMeta('activity');
  @override
  late final GeneratedColumn<String> activity = GeneratedColumn<String>(
      'activity', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES activities (id)'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<PlanningMode?, String>
      planningMode = GeneratedColumn<String>('planning_mode', aliasedName, true,
              type: DriftSqlType.string, requiredDuringInsert: false)
          .withConverter<PlanningMode?>(
              $FlowTypesTable.$converterplanningModen);
  @override
  late final GeneratedColumnWithTypeConverter<SubmissionMode?, String>
      submissionMode = GeneratedColumn<String>(
              'submission_mode', aliasedName, true,
              type: DriftSqlType.string, requiredDuringInsert: false)
          .withConverter<SubmissionMode?>(
              $FlowTypesTable.$convertersubmissionModen);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        lastModifiedDate,
        createdDate,
        activity,
        name,
        planningMode,
        submissionMode
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'flow_types';
  @override
  VerificationContext validateIntegrity(Insertable<FlowType> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('last_modified_date')) {
      context.handle(
          _lastModifiedDateMeta,
          lastModifiedDate.isAcceptableOrUnknown(
              data['last_modified_date']!, _lastModifiedDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('activity')) {
      context.handle(_activityMeta,
          activity.isAcceptableOrUnknown(data['activity']!, _activityMeta));
    } else if (isInserting) {
      context.missing(_activityMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FlowType map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FlowType(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      lastModifiedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_modified_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_date']),
      activity: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}activity'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name']),
      planningMode: $FlowTypesTable.$converterplanningModen.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}planning_mode'])),
      submissionMode: $FlowTypesTable.$convertersubmissionModen.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}submission_mode'])),
    );
  }

  @override
  $FlowTypesTable createAlias(String alias) {
    return $FlowTypesTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<PlanningMode, String, String>
      $converterplanningMode = const EnumNameConverter(PlanningMode.values);
  static JsonTypeConverter2<PlanningMode?, String?, String?>
      $converterplanningModen =
      JsonTypeConverter2.asNullable($converterplanningMode);
  static JsonTypeConverter2<SubmissionMode, String, String>
      $convertersubmissionMode = const EnumNameConverter(SubmissionMode.values);
  static JsonTypeConverter2<SubmissionMode?, String?, String?>
      $convertersubmissionModen =
      JsonTypeConverter2.asNullable($convertersubmissionMode);
}

class FlowType extends DataClass implements Insertable<FlowType> {
  final String id;
  final DateTime? lastModifiedDate;
  final DateTime? createdDate;
  final String activity;
  final String? name;
  final PlanningMode? planningMode;
  final SubmissionMode? submissionMode;
  const FlowType(
      {required this.id,
      this.lastModifiedDate,
      this.createdDate,
      required this.activity,
      this.name,
      this.planningMode,
      this.submissionMode});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || lastModifiedDate != null) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<DateTime>(createdDate);
    }
    map['activity'] = Variable<String>(activity);
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || planningMode != null) {
      map['planning_mode'] = Variable<String>(
          $FlowTypesTable.$converterplanningModen.toSql(planningMode));
    }
    if (!nullToAbsent || submissionMode != null) {
      map['submission_mode'] = Variable<String>(
          $FlowTypesTable.$convertersubmissionModen.toSql(submissionMode));
    }
    return map;
  }

  FlowTypesCompanion toCompanion(bool nullToAbsent) {
    return FlowTypesCompanion(
      id: Value(id),
      lastModifiedDate: lastModifiedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      activity: Value(activity),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      planningMode: planningMode == null && nullToAbsent
          ? const Value.absent()
          : Value(planningMode),
      submissionMode: submissionMode == null && nullToAbsent
          ? const Value.absent()
          : Value(submissionMode),
    );
  }

  factory FlowType.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FlowType(
      id: serializer.fromJson<String>(json['id']),
      lastModifiedDate:
          serializer.fromJson<DateTime?>(json['lastModifiedDate']),
      createdDate: serializer.fromJson<DateTime?>(json['createdDate']),
      activity: serializer.fromJson<String>(json['activity']),
      name: serializer.fromJson<String?>(json['name']),
      planningMode: $FlowTypesTable.$converterplanningModen
          .fromJson(serializer.fromJson<String?>(json['planningMode'])),
      submissionMode: $FlowTypesTable.$convertersubmissionModen
          .fromJson(serializer.fromJson<String?>(json['submissionMode'])),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'lastModifiedDate': serializer.toJson<DateTime?>(lastModifiedDate),
      'createdDate': serializer.toJson<DateTime?>(createdDate),
      'activity': serializer.toJson<String>(activity),
      'name': serializer.toJson<String?>(name),
      'planningMode': serializer.toJson<String?>(
          $FlowTypesTable.$converterplanningModen.toJson(planningMode)),
      'submissionMode': serializer.toJson<String?>(
          $FlowTypesTable.$convertersubmissionModen.toJson(submissionMode)),
    };
  }

  FlowType copyWith(
          {String? id,
          Value<DateTime?> lastModifiedDate = const Value.absent(),
          Value<DateTime?> createdDate = const Value.absent(),
          String? activity,
          Value<String?> name = const Value.absent(),
          Value<PlanningMode?> planningMode = const Value.absent(),
          Value<SubmissionMode?> submissionMode = const Value.absent()}) =>
      FlowType(
        id: id ?? this.id,
        lastModifiedDate: lastModifiedDate.present
            ? lastModifiedDate.value
            : this.lastModifiedDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        activity: activity ?? this.activity,
        name: name.present ? name.value : this.name,
        planningMode:
            planningMode.present ? planningMode.value : this.planningMode,
        submissionMode:
            submissionMode.present ? submissionMode.value : this.submissionMode,
      );
  FlowType copyWithCompanion(FlowTypesCompanion data) {
    return FlowType(
      id: data.id.present ? data.id.value : this.id,
      lastModifiedDate: data.lastModifiedDate.present
          ? data.lastModifiedDate.value
          : this.lastModifiedDate,
      createdDate:
          data.createdDate.present ? data.createdDate.value : this.createdDate,
      activity: data.activity.present ? data.activity.value : this.activity,
      name: data.name.present ? data.name.value : this.name,
      planningMode: data.planningMode.present
          ? data.planningMode.value
          : this.planningMode,
      submissionMode: data.submissionMode.present
          ? data.submissionMode.value
          : this.submissionMode,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FlowType(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('activity: $activity, ')
          ..write('name: $name, ')
          ..write('planningMode: $planningMode, ')
          ..write('submissionMode: $submissionMode')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, lastModifiedDate, createdDate, activity,
      name, planningMode, submissionMode);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FlowType &&
          other.id == this.id &&
          other.lastModifiedDate == this.lastModifiedDate &&
          other.createdDate == this.createdDate &&
          other.activity == this.activity &&
          other.name == this.name &&
          other.planningMode == this.planningMode &&
          other.submissionMode == this.submissionMode);
}

class FlowTypesCompanion extends UpdateCompanion<FlowType> {
  final Value<String> id;
  final Value<DateTime?> lastModifiedDate;
  final Value<DateTime?> createdDate;
  final Value<String> activity;
  final Value<String?> name;
  final Value<PlanningMode?> planningMode;
  final Value<SubmissionMode?> submissionMode;
  final Value<int> rowid;
  const FlowTypesCompanion({
    this.id = const Value.absent(),
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.activity = const Value.absent(),
    this.name = const Value.absent(),
    this.planningMode = const Value.absent(),
    this.submissionMode = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FlowTypesCompanion.insert({
    required String id,
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    required String activity,
    this.name = const Value.absent(),
    this.planningMode = const Value.absent(),
    this.submissionMode = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        activity = Value(activity);
  static Insertable<FlowType> custom({
    Expression<String>? id,
    Expression<DateTime>? lastModifiedDate,
    Expression<DateTime>? createdDate,
    Expression<String>? activity,
    Expression<String>? name,
    Expression<String>? planningMode,
    Expression<String>? submissionMode,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (lastModifiedDate != null) 'last_modified_date': lastModifiedDate,
      if (createdDate != null) 'created_date': createdDate,
      if (activity != null) 'activity': activity,
      if (name != null) 'name': name,
      if (planningMode != null) 'planning_mode': planningMode,
      if (submissionMode != null) 'submission_mode': submissionMode,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FlowTypesCompanion copyWith(
      {Value<String>? id,
      Value<DateTime?>? lastModifiedDate,
      Value<DateTime?>? createdDate,
      Value<String>? activity,
      Value<String?>? name,
      Value<PlanningMode?>? planningMode,
      Value<SubmissionMode?>? submissionMode,
      Value<int>? rowid}) {
    return FlowTypesCompanion(
      id: id ?? this.id,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      createdDate: createdDate ?? this.createdDate,
      activity: activity ?? this.activity,
      name: name ?? this.name,
      planningMode: planningMode ?? this.planningMode,
      submissionMode: submissionMode ?? this.submissionMode,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (lastModifiedDate.present) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<DateTime>(createdDate.value);
    }
    if (activity.present) {
      map['activity'] = Variable<String>(activity.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (planningMode.present) {
      map['planning_mode'] = Variable<String>(
          $FlowTypesTable.$converterplanningModen.toSql(planningMode.value));
    }
    if (submissionMode.present) {
      map['submission_mode'] = Variable<String>($FlowTypesTable
          .$convertersubmissionModen
          .toSql(submissionMode.value));
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FlowTypesCompanion(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('activity: $activity, ')
          ..write('name: $name, ')
          ..write('planningMode: $planningMode, ')
          ..write('submissionMode: $submissionMode, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $EntityTypesTable extends EntityTypes
    with TableInfo<$EntityTypesTable, EntityType> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EntityTypesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _lastModifiedDateMeta =
      const VerificationMeta('lastModifiedDate');
  @override
  late final GeneratedColumn<DateTime> lastModifiedDate =
      GeneratedColumn<DateTime>('last_modified_date', aliasedName, true,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<DateTime> createdDate = GeneratedColumn<DateTime>(
      'created_date', aliasedName, true,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _displayNameMeta =
      const VerificationMeta('displayName');
  @override
  late final GeneratedColumn<String> displayName = GeneratedColumn<String>(
      'display_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
      label = GeneratedColumn<String>('label', aliasedName, true,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '{}')
          .withConverter<Map<String, dynamic>?>(
              $EntityTypesTable.$converterlabel);
  @override
  late final GeneratedColumnWithTypeConverter<List<Translation>, String>
      translations = GeneratedColumn<String>('translations', aliasedName, false,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '[]')
          .withConverter<List<Translation>>(
              $EntityTypesTable.$convertertranslations);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<List<Template>, String>
      entityAttributes = GeneratedColumn<String>(
              'entity_attributes', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<List<Template>>(
              $EntityTypesTable.$converterentityAttributes);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        lastModifiedDate,
        createdDate,
        displayName,
        label,
        translations,
        code,
        name,
        entityAttributes
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'entity_types';
  @override
  VerificationContext validateIntegrity(Insertable<EntityType> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('last_modified_date')) {
      context.handle(
          _lastModifiedDateMeta,
          lastModifiedDate.isAcceptableOrUnknown(
              data['last_modified_date']!, _lastModifiedDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('display_name')) {
      context.handle(
          _displayNameMeta,
          displayName.isAcceptableOrUnknown(
              data['display_name']!, _displayNameMeta));
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  EntityType map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return EntityType(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      lastModifiedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_modified_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_date']),
      displayName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}display_name']),
      label: $EntityTypesTable.$converterlabel.fromSql(attachedDatabase
          .typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}label'])),
      translations: $EntityTypesTable.$convertertranslations.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}translations'])!),
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name']),
      entityAttributes: $EntityTypesTable.$converterentityAttributes.fromSql(
          attachedDatabase.typeMapping.read(DriftSqlType.string,
              data['${effectivePrefix}entity_attributes'])!),
    );
  }

  @override
  $EntityTypesTable createAlias(String alias) {
    return $EntityTypesTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>?, String?> $converterlabel =
      const NullAwareMapConverter();
  static TypeConverter<List<Translation>, String> $convertertranslations =
      const TranslationConverter();
  static TypeConverter<List<Template>, String> $converterentityAttributes =
      const TemplateListConverter();
}

class EntityType extends DataClass implements Insertable<EntityType> {
  final String id;
  final DateTime? lastModifiedDate;
  final DateTime? createdDate;
  final String? displayName;
  final Map<String, dynamic>? label;
  final List<Translation> translations;
  final String? code;
  final String? name;
  final List<Template> entityAttributes;
  const EntityType(
      {required this.id,
      this.lastModifiedDate,
      this.createdDate,
      this.displayName,
      this.label,
      required this.translations,
      this.code,
      this.name,
      required this.entityAttributes});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || lastModifiedDate != null) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<DateTime>(createdDate);
    }
    if (!nullToAbsent || displayName != null) {
      map['display_name'] = Variable<String>(displayName);
    }
    if (!nullToAbsent || label != null) {
      map['label'] =
          Variable<String>($EntityTypesTable.$converterlabel.toSql(label));
    }
    {
      map['translations'] = Variable<String>(
          $EntityTypesTable.$convertertranslations.toSql(translations));
    }
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    {
      map['entity_attributes'] = Variable<String>(
          $EntityTypesTable.$converterentityAttributes.toSql(entityAttributes));
    }
    return map;
  }

  EntityTypesCompanion toCompanion(bool nullToAbsent) {
    return EntityTypesCompanion(
      id: Value(id),
      lastModifiedDate: lastModifiedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      displayName: displayName == null && nullToAbsent
          ? const Value.absent()
          : Value(displayName),
      label:
          label == null && nullToAbsent ? const Value.absent() : Value(label),
      translations: Value(translations),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      entityAttributes: Value(entityAttributes),
    );
  }

  factory EntityType.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return EntityType(
      id: serializer.fromJson<String>(json['id']),
      lastModifiedDate:
          serializer.fromJson<DateTime?>(json['lastModifiedDate']),
      createdDate: serializer.fromJson<DateTime?>(json['createdDate']),
      displayName: serializer.fromJson<String?>(json['displayName']),
      label: serializer.fromJson<Map<String, dynamic>?>(json['label']),
      translations:
          serializer.fromJson<List<Translation>>(json['translations']),
      code: serializer.fromJson<String?>(json['code']),
      name: serializer.fromJson<String?>(json['name']),
      entityAttributes:
          serializer.fromJson<List<Template>>(json['entityAttributes']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'lastModifiedDate': serializer.toJson<DateTime?>(lastModifiedDate),
      'createdDate': serializer.toJson<DateTime?>(createdDate),
      'displayName': serializer.toJson<String?>(displayName),
      'label': serializer.toJson<Map<String, dynamic>?>(label),
      'translations': serializer.toJson<List<Translation>>(translations),
      'code': serializer.toJson<String?>(code),
      'name': serializer.toJson<String?>(name),
      'entityAttributes': serializer.toJson<List<Template>>(entityAttributes),
    };
  }

  EntityType copyWith(
          {String? id,
          Value<DateTime?> lastModifiedDate = const Value.absent(),
          Value<DateTime?> createdDate = const Value.absent(),
          Value<String?> displayName = const Value.absent(),
          Value<Map<String, dynamic>?> label = const Value.absent(),
          List<Translation>? translations,
          Value<String?> code = const Value.absent(),
          Value<String?> name = const Value.absent(),
          List<Template>? entityAttributes}) =>
      EntityType(
        id: id ?? this.id,
        lastModifiedDate: lastModifiedDate.present
            ? lastModifiedDate.value
            : this.lastModifiedDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        displayName: displayName.present ? displayName.value : this.displayName,
        label: label.present ? label.value : this.label,
        translations: translations ?? this.translations,
        code: code.present ? code.value : this.code,
        name: name.present ? name.value : this.name,
        entityAttributes: entityAttributes ?? this.entityAttributes,
      );
  EntityType copyWithCompanion(EntityTypesCompanion data) {
    return EntityType(
      id: data.id.present ? data.id.value : this.id,
      lastModifiedDate: data.lastModifiedDate.present
          ? data.lastModifiedDate.value
          : this.lastModifiedDate,
      createdDate:
          data.createdDate.present ? data.createdDate.value : this.createdDate,
      displayName:
          data.displayName.present ? data.displayName.value : this.displayName,
      label: data.label.present ? data.label.value : this.label,
      translations: data.translations.present
          ? data.translations.value
          : this.translations,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      entityAttributes: data.entityAttributes.present
          ? data.entityAttributes.value
          : this.entityAttributes,
    );
  }

  @override
  String toString() {
    return (StringBuffer('EntityType(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('displayName: $displayName, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('entityAttributes: $entityAttributes')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, lastModifiedDate, createdDate,
      displayName, label, translations, code, name, entityAttributes);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is EntityType &&
          other.id == this.id &&
          other.lastModifiedDate == this.lastModifiedDate &&
          other.createdDate == this.createdDate &&
          other.displayName == this.displayName &&
          other.label == this.label &&
          other.translations == this.translations &&
          other.code == this.code &&
          other.name == this.name &&
          other.entityAttributes == this.entityAttributes);
}

class EntityTypesCompanion extends UpdateCompanion<EntityType> {
  final Value<String> id;
  final Value<DateTime?> lastModifiedDate;
  final Value<DateTime?> createdDate;
  final Value<String?> displayName;
  final Value<Map<String, dynamic>?> label;
  final Value<List<Translation>> translations;
  final Value<String?> code;
  final Value<String?> name;
  final Value<List<Template>> entityAttributes;
  final Value<int> rowid;
  const EntityTypesCompanion({
    this.id = const Value.absent(),
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.displayName = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.entityAttributes = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  EntityTypesCompanion.insert({
    required String id,
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.displayName = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    required List<Template> entityAttributes,
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        entityAttributes = Value(entityAttributes);
  static Insertable<EntityType> custom({
    Expression<String>? id,
    Expression<DateTime>? lastModifiedDate,
    Expression<DateTime>? createdDate,
    Expression<String>? displayName,
    Expression<String>? label,
    Expression<String>? translations,
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? entityAttributes,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (lastModifiedDate != null) 'last_modified_date': lastModifiedDate,
      if (createdDate != null) 'created_date': createdDate,
      if (displayName != null) 'display_name': displayName,
      if (label != null) 'label': label,
      if (translations != null) 'translations': translations,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (entityAttributes != null) 'entity_attributes': entityAttributes,
      if (rowid != null) 'rowid': rowid,
    });
  }

  EntityTypesCompanion copyWith(
      {Value<String>? id,
      Value<DateTime?>? lastModifiedDate,
      Value<DateTime?>? createdDate,
      Value<String?>? displayName,
      Value<Map<String, dynamic>?>? label,
      Value<List<Translation>>? translations,
      Value<String?>? code,
      Value<String?>? name,
      Value<List<Template>>? entityAttributes,
      Value<int>? rowid}) {
    return EntityTypesCompanion(
      id: id ?? this.id,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      createdDate: createdDate ?? this.createdDate,
      displayName: displayName ?? this.displayName,
      label: label ?? this.label,
      translations: translations ?? this.translations,
      code: code ?? this.code,
      name: name ?? this.name,
      entityAttributes: entityAttributes ?? this.entityAttributes,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (lastModifiedDate.present) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<DateTime>(createdDate.value);
    }
    if (displayName.present) {
      map['display_name'] = Variable<String>(displayName.value);
    }
    if (label.present) {
      map['label'] = Variable<String>(
          $EntityTypesTable.$converterlabel.toSql(label.value));
    }
    if (translations.present) {
      map['translations'] = Variable<String>(
          $EntityTypesTable.$convertertranslations.toSql(translations.value));
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (entityAttributes.present) {
      map['entity_attributes'] = Variable<String>($EntityTypesTable
          .$converterentityAttributes
          .toSql(entityAttributes.value));
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EntityTypesCompanion(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('displayName: $displayName, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('entityAttributes: $entityAttributes, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $EntityInstancesTable extends EntityInstances
    with TableInfo<$EntityInstancesTable, EntityInstance> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EntityInstancesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _lastModifiedDateMeta =
      const VerificationMeta('lastModifiedDate');
  @override
  late final GeneratedColumn<DateTime> lastModifiedDate =
      GeneratedColumn<DateTime>('last_modified_date', aliasedName, true,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<DateTime> createdDate = GeneratedColumn<DateTime>(
      'created_date', aliasedName, true,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _displayNameMeta =
      const VerificationMeta('displayName');
  @override
  late final GeneratedColumn<String> displayName = GeneratedColumn<String>(
      'display_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
      label = GeneratedColumn<String>('label', aliasedName, true,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '{}')
          .withConverter<Map<String, dynamic>?>(
              $EntityInstancesTable.$converterlabel);
  @override
  late final GeneratedColumnWithTypeConverter<List<Translation>, String>
      translations = GeneratedColumn<String>('translations', aliasedName, false,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '[]')
          .withConverter<List<Translation>>(
              $EntityInstancesTable.$convertertranslations);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _entityTypeMeta =
      const VerificationMeta('entityType');
  @override
  late final GeneratedColumn<String> entityType = GeneratedColumn<String>(
      'entity_type', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES entity_types (id)'));
  @override
  late final GeneratedColumnWithTypeConverter<EntityStatus?, String> status =
      GeneratedColumn<String>('status', aliasedName, true,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => EntityStatus.ACTIVE.name)
          .withConverter<EntityStatus?>(
              $EntityInstancesTable.$converterstatusn);
  static const VerificationMeta _updatedAtClientMeta =
      const VerificationMeta('updatedAtClient');
  @override
  late final GeneratedColumn<DateTime> updatedAtClient =
      GeneratedColumn<DateTime>('updated_at_client', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtClientMeta =
      const VerificationMeta('createdAtClient');
  @override
  late final GeneratedColumn<DateTime> createdAtClient =
      GeneratedColumn<DateTime>('created_at_client', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
      identityAttributes = GeneratedColumn<String>(
              'identity_attributes', aliasedName, true,
              type: DriftSqlType.string, requiredDuringInsert: false)
          .withConverter<Map<String, dynamic>?>(
              $EntityInstancesTable.$converteridentityAttributes);
  @override
  late final GeneratedColumnWithTypeConverter<InstanceSyncStatus, String>
      syncState = GeneratedColumn<String>('sync_state', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<InstanceSyncStatus>(
              $EntityInstancesTable.$convertersyncState);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        lastModifiedDate,
        createdDate,
        displayName,
        label,
        translations,
        uuid,
        entityType,
        status,
        updatedAtClient,
        createdAtClient,
        identityAttributes,
        syncState
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'entity_instances';
  @override
  VerificationContext validateIntegrity(Insertable<EntityInstance> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('last_modified_date')) {
      context.handle(
          _lastModifiedDateMeta,
          lastModifiedDate.isAcceptableOrUnknown(
              data['last_modified_date']!, _lastModifiedDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('display_name')) {
      context.handle(
          _displayNameMeta,
          displayName.isAcceptableOrUnknown(
              data['display_name']!, _displayNameMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    }
    if (data.containsKey('entity_type')) {
      context.handle(
          _entityTypeMeta,
          entityType.isAcceptableOrUnknown(
              data['entity_type']!, _entityTypeMeta));
    } else if (isInserting) {
      context.missing(_entityTypeMeta);
    }
    if (data.containsKey('updated_at_client')) {
      context.handle(
          _updatedAtClientMeta,
          updatedAtClient.isAcceptableOrUnknown(
              data['updated_at_client']!, _updatedAtClientMeta));
    }
    if (data.containsKey('created_at_client')) {
      context.handle(
          _createdAtClientMeta,
          createdAtClient.isAcceptableOrUnknown(
              data['created_at_client']!, _createdAtClientMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  EntityInstance map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return EntityInstance(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      lastModifiedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_modified_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_date']),
      displayName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}display_name']),
      label: $EntityInstancesTable.$converterlabel.fromSql(attachedDatabase
          .typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}label'])),
      translations: $EntityInstancesTable.$convertertranslations.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}translations'])!),
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid']),
      entityType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}entity_type'])!,
      status: $EntityInstancesTable.$converterstatusn.fromSql(attachedDatabase
          .typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])),
      updatedAtClient: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}updated_at_client']),
      createdAtClient: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}created_at_client']),
      identityAttributes: $EntityInstancesTable.$converteridentityAttributes
          .fromSql(attachedDatabase.typeMapping.read(DriftSqlType.string,
              data['${effectivePrefix}identity_attributes'])),
      syncState: $EntityInstancesTable.$convertersyncState.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}sync_state'])!),
    );
  }

  @override
  $EntityInstancesTable createAlias(String alias) {
    return $EntityInstancesTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>?, String?> $converterlabel =
      const NullAwareMapConverter();
  static TypeConverter<List<Translation>, String> $convertertranslations =
      const TranslationConverter();
  static JsonTypeConverter2<EntityStatus, String, String> $converterstatus =
      const EnumNameConverter(EntityStatus.values);
  static JsonTypeConverter2<EntityStatus?, String?, String?> $converterstatusn =
      JsonTypeConverter2.asNullable($converterstatus);
  static TypeConverter<Map<String, dynamic>?, String?>
      $converteridentityAttributes = const NullAwareMapConverter();
  static JsonTypeConverter2<InstanceSyncStatus, String, String>
      $convertersyncState = const EnumNameConverter(InstanceSyncStatus.values);
}

class EntityInstance extends DataClass implements Insertable<EntityInstance> {
  final String id;
  final DateTime? lastModifiedDate;
  final DateTime? createdDate;
  final String? displayName;
  final Map<String, dynamic>? label;
  final List<Translation> translations;
  final String? uuid;
  final String entityType;
  final EntityStatus? status;
  final DateTime? updatedAtClient;
  final DateTime? createdAtClient;

  /// Identity attributes (JSON object of key → value)
  final Map<String, dynamic>? identityAttributes;
  final InstanceSyncStatus syncState;
  const EntityInstance(
      {required this.id,
      this.lastModifiedDate,
      this.createdDate,
      this.displayName,
      this.label,
      required this.translations,
      this.uuid,
      required this.entityType,
      this.status,
      this.updatedAtClient,
      this.createdAtClient,
      this.identityAttributes,
      required this.syncState});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || lastModifiedDate != null) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<DateTime>(createdDate);
    }
    if (!nullToAbsent || displayName != null) {
      map['display_name'] = Variable<String>(displayName);
    }
    if (!nullToAbsent || label != null) {
      map['label'] =
          Variable<String>($EntityInstancesTable.$converterlabel.toSql(label));
    }
    {
      map['translations'] = Variable<String>(
          $EntityInstancesTable.$convertertranslations.toSql(translations));
    }
    if (!nullToAbsent || uuid != null) {
      map['uuid'] = Variable<String>(uuid);
    }
    map['entity_type'] = Variable<String>(entityType);
    if (!nullToAbsent || status != null) {
      map['status'] = Variable<String>(
          $EntityInstancesTable.$converterstatusn.toSql(status));
    }
    if (!nullToAbsent || updatedAtClient != null) {
      map['updated_at_client'] = Variable<DateTime>(updatedAtClient);
    }
    if (!nullToAbsent || createdAtClient != null) {
      map['created_at_client'] = Variable<DateTime>(createdAtClient);
    }
    if (!nullToAbsent || identityAttributes != null) {
      map['identity_attributes'] = Variable<String>($EntityInstancesTable
          .$converteridentityAttributes
          .toSql(identityAttributes));
    }
    {
      map['sync_state'] = Variable<String>(
          $EntityInstancesTable.$convertersyncState.toSql(syncState));
    }
    return map;
  }

  EntityInstancesCompanion toCompanion(bool nullToAbsent) {
    return EntityInstancesCompanion(
      id: Value(id),
      lastModifiedDate: lastModifiedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      displayName: displayName == null && nullToAbsent
          ? const Value.absent()
          : Value(displayName),
      label:
          label == null && nullToAbsent ? const Value.absent() : Value(label),
      translations: Value(translations),
      uuid: uuid == null && nullToAbsent ? const Value.absent() : Value(uuid),
      entityType: Value(entityType),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      updatedAtClient: updatedAtClient == null && nullToAbsent
          ? const Value.absent()
          : Value(updatedAtClient),
      createdAtClient: createdAtClient == null && nullToAbsent
          ? const Value.absent()
          : Value(createdAtClient),
      identityAttributes: identityAttributes == null && nullToAbsent
          ? const Value.absent()
          : Value(identityAttributes),
      syncState: Value(syncState),
    );
  }

  factory EntityInstance.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return EntityInstance(
      id: serializer.fromJson<String>(json['id']),
      lastModifiedDate:
          serializer.fromJson<DateTime?>(json['lastModifiedDate']),
      createdDate: serializer.fromJson<DateTime?>(json['createdDate']),
      displayName: serializer.fromJson<String?>(json['displayName']),
      label: serializer.fromJson<Map<String, dynamic>?>(json['label']),
      translations:
          serializer.fromJson<List<Translation>>(json['translations']),
      uuid: serializer.fromJson<String?>(json['uuid']),
      entityType: serializer.fromJson<String>(json['entityType']),
      status: $EntityInstancesTable.$converterstatusn
          .fromJson(serializer.fromJson<String?>(json['status'])),
      updatedAtClient: serializer.fromJson<DateTime?>(json['updatedAtClient']),
      createdAtClient: serializer.fromJson<DateTime?>(json['createdAtClient']),
      identityAttributes: serializer
          .fromJson<Map<String, dynamic>?>(json['identityAttributes']),
      syncState: $EntityInstancesTable.$convertersyncState
          .fromJson(serializer.fromJson<String>(json['syncState'])),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'lastModifiedDate': serializer.toJson<DateTime?>(lastModifiedDate),
      'createdDate': serializer.toJson<DateTime?>(createdDate),
      'displayName': serializer.toJson<String?>(displayName),
      'label': serializer.toJson<Map<String, dynamic>?>(label),
      'translations': serializer.toJson<List<Translation>>(translations),
      'uuid': serializer.toJson<String?>(uuid),
      'entityType': serializer.toJson<String>(entityType),
      'status': serializer.toJson<String?>(
          $EntityInstancesTable.$converterstatusn.toJson(status)),
      'updatedAtClient': serializer.toJson<DateTime?>(updatedAtClient),
      'createdAtClient': serializer.toJson<DateTime?>(createdAtClient),
      'identityAttributes':
          serializer.toJson<Map<String, dynamic>?>(identityAttributes),
      'syncState': serializer.toJson<String>(
          $EntityInstancesTable.$convertersyncState.toJson(syncState)),
    };
  }

  EntityInstance copyWith(
          {String? id,
          Value<DateTime?> lastModifiedDate = const Value.absent(),
          Value<DateTime?> createdDate = const Value.absent(),
          Value<String?> displayName = const Value.absent(),
          Value<Map<String, dynamic>?> label = const Value.absent(),
          List<Translation>? translations,
          Value<String?> uuid = const Value.absent(),
          String? entityType,
          Value<EntityStatus?> status = const Value.absent(),
          Value<DateTime?> updatedAtClient = const Value.absent(),
          Value<DateTime?> createdAtClient = const Value.absent(),
          Value<Map<String, dynamic>?> identityAttributes =
              const Value.absent(),
          InstanceSyncStatus? syncState}) =>
      EntityInstance(
        id: id ?? this.id,
        lastModifiedDate: lastModifiedDate.present
            ? lastModifiedDate.value
            : this.lastModifiedDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        displayName: displayName.present ? displayName.value : this.displayName,
        label: label.present ? label.value : this.label,
        translations: translations ?? this.translations,
        uuid: uuid.present ? uuid.value : this.uuid,
        entityType: entityType ?? this.entityType,
        status: status.present ? status.value : this.status,
        updatedAtClient: updatedAtClient.present
            ? updatedAtClient.value
            : this.updatedAtClient,
        createdAtClient: createdAtClient.present
            ? createdAtClient.value
            : this.createdAtClient,
        identityAttributes: identityAttributes.present
            ? identityAttributes.value
            : this.identityAttributes,
        syncState: syncState ?? this.syncState,
      );
  EntityInstance copyWithCompanion(EntityInstancesCompanion data) {
    return EntityInstance(
      id: data.id.present ? data.id.value : this.id,
      lastModifiedDate: data.lastModifiedDate.present
          ? data.lastModifiedDate.value
          : this.lastModifiedDate,
      createdDate:
          data.createdDate.present ? data.createdDate.value : this.createdDate,
      displayName:
          data.displayName.present ? data.displayName.value : this.displayName,
      label: data.label.present ? data.label.value : this.label,
      translations: data.translations.present
          ? data.translations.value
          : this.translations,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      entityType:
          data.entityType.present ? data.entityType.value : this.entityType,
      status: data.status.present ? data.status.value : this.status,
      updatedAtClient: data.updatedAtClient.present
          ? data.updatedAtClient.value
          : this.updatedAtClient,
      createdAtClient: data.createdAtClient.present
          ? data.createdAtClient.value
          : this.createdAtClient,
      identityAttributes: data.identityAttributes.present
          ? data.identityAttributes.value
          : this.identityAttributes,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
    );
  }

  @override
  String toString() {
    return (StringBuffer('EntityInstance(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('displayName: $displayName, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('uuid: $uuid, ')
          ..write('entityType: $entityType, ')
          ..write('status: $status, ')
          ..write('updatedAtClient: $updatedAtClient, ')
          ..write('createdAtClient: $createdAtClient, ')
          ..write('identityAttributes: $identityAttributes, ')
          ..write('syncState: $syncState')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      lastModifiedDate,
      createdDate,
      displayName,
      label,
      translations,
      uuid,
      entityType,
      status,
      updatedAtClient,
      createdAtClient,
      identityAttributes,
      syncState);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is EntityInstance &&
          other.id == this.id &&
          other.lastModifiedDate == this.lastModifiedDate &&
          other.createdDate == this.createdDate &&
          other.displayName == this.displayName &&
          other.label == this.label &&
          other.translations == this.translations &&
          other.uuid == this.uuid &&
          other.entityType == this.entityType &&
          other.status == this.status &&
          other.updatedAtClient == this.updatedAtClient &&
          other.createdAtClient == this.createdAtClient &&
          other.identityAttributes == this.identityAttributes &&
          other.syncState == this.syncState);
}

class EntityInstancesCompanion extends UpdateCompanion<EntityInstance> {
  final Value<String> id;
  final Value<DateTime?> lastModifiedDate;
  final Value<DateTime?> createdDate;
  final Value<String?> displayName;
  final Value<Map<String, dynamic>?> label;
  final Value<List<Translation>> translations;
  final Value<String?> uuid;
  final Value<String> entityType;
  final Value<EntityStatus?> status;
  final Value<DateTime?> updatedAtClient;
  final Value<DateTime?> createdAtClient;
  final Value<Map<String, dynamic>?> identityAttributes;
  final Value<InstanceSyncStatus> syncState;
  final Value<int> rowid;
  const EntityInstancesCompanion({
    this.id = const Value.absent(),
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.displayName = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    this.uuid = const Value.absent(),
    this.entityType = const Value.absent(),
    this.status = const Value.absent(),
    this.updatedAtClient = const Value.absent(),
    this.createdAtClient = const Value.absent(),
    this.identityAttributes = const Value.absent(),
    this.syncState = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  EntityInstancesCompanion.insert({
    required String id,
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.displayName = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    this.uuid = const Value.absent(),
    required String entityType,
    this.status = const Value.absent(),
    this.updatedAtClient = const Value.absent(),
    this.createdAtClient = const Value.absent(),
    this.identityAttributes = const Value.absent(),
    required InstanceSyncStatus syncState,
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        entityType = Value(entityType),
        syncState = Value(syncState);
  static Insertable<EntityInstance> custom({
    Expression<String>? id,
    Expression<DateTime>? lastModifiedDate,
    Expression<DateTime>? createdDate,
    Expression<String>? displayName,
    Expression<String>? label,
    Expression<String>? translations,
    Expression<String>? uuid,
    Expression<String>? entityType,
    Expression<String>? status,
    Expression<DateTime>? updatedAtClient,
    Expression<DateTime>? createdAtClient,
    Expression<String>? identityAttributes,
    Expression<String>? syncState,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (lastModifiedDate != null) 'last_modified_date': lastModifiedDate,
      if (createdDate != null) 'created_date': createdDate,
      if (displayName != null) 'display_name': displayName,
      if (label != null) 'label': label,
      if (translations != null) 'translations': translations,
      if (uuid != null) 'uuid': uuid,
      if (entityType != null) 'entity_type': entityType,
      if (status != null) 'status': status,
      if (updatedAtClient != null) 'updated_at_client': updatedAtClient,
      if (createdAtClient != null) 'created_at_client': createdAtClient,
      if (identityAttributes != null) 'identity_attributes': identityAttributes,
      if (syncState != null) 'sync_state': syncState,
      if (rowid != null) 'rowid': rowid,
    });
  }

  EntityInstancesCompanion copyWith(
      {Value<String>? id,
      Value<DateTime?>? lastModifiedDate,
      Value<DateTime?>? createdDate,
      Value<String?>? displayName,
      Value<Map<String, dynamic>?>? label,
      Value<List<Translation>>? translations,
      Value<String?>? uuid,
      Value<String>? entityType,
      Value<EntityStatus?>? status,
      Value<DateTime?>? updatedAtClient,
      Value<DateTime?>? createdAtClient,
      Value<Map<String, dynamic>?>? identityAttributes,
      Value<InstanceSyncStatus>? syncState,
      Value<int>? rowid}) {
    return EntityInstancesCompanion(
      id: id ?? this.id,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      createdDate: createdDate ?? this.createdDate,
      displayName: displayName ?? this.displayName,
      label: label ?? this.label,
      translations: translations ?? this.translations,
      uuid: uuid ?? this.uuid,
      entityType: entityType ?? this.entityType,
      status: status ?? this.status,
      updatedAtClient: updatedAtClient ?? this.updatedAtClient,
      createdAtClient: createdAtClient ?? this.createdAtClient,
      identityAttributes: identityAttributes ?? this.identityAttributes,
      syncState: syncState ?? this.syncState,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (lastModifiedDate.present) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<DateTime>(createdDate.value);
    }
    if (displayName.present) {
      map['display_name'] = Variable<String>(displayName.value);
    }
    if (label.present) {
      map['label'] = Variable<String>(
          $EntityInstancesTable.$converterlabel.toSql(label.value));
    }
    if (translations.present) {
      map['translations'] = Variable<String>($EntityInstancesTable
          .$convertertranslations
          .toSql(translations.value));
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (entityType.present) {
      map['entity_type'] = Variable<String>(entityType.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(
          $EntityInstancesTable.$converterstatusn.toSql(status.value));
    }
    if (updatedAtClient.present) {
      map['updated_at_client'] = Variable<DateTime>(updatedAtClient.value);
    }
    if (createdAtClient.present) {
      map['created_at_client'] = Variable<DateTime>(createdAtClient.value);
    }
    if (identityAttributes.present) {
      map['identity_attributes'] = Variable<String>($EntityInstancesTable
          .$converteridentityAttributes
          .toSql(identityAttributes.value));
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(
          $EntityInstancesTable.$convertersyncState.toSql(syncState.value));
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EntityInstancesCompanion(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('displayName: $displayName, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('uuid: $uuid, ')
          ..write('entityType: $entityType, ')
          ..write('status: $status, ')
          ..write('updatedAtClient: $updatedAtClient, ')
          ..write('createdAtClient: $createdAtClient, ')
          ..write('identityAttributes: $identityAttributes, ')
          ..write('syncState: $syncState, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FlowInstancesTable extends FlowInstances
    with TableInfo<$FlowInstancesTable, FlowInstance> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FlowInstancesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _lastModifiedDateMeta =
      const VerificationMeta('lastModifiedDate');
  @override
  late final GeneratedColumn<DateTime> lastModifiedDate =
      GeneratedColumn<DateTime>('last_modified_date', aliasedName, true,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<DateTime> createdDate = GeneratedColumn<DateTime>(
      'created_date', aliasedName, true,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _flowTypeMeta =
      const VerificationMeta('flowType');
  @override
  late final GeneratedColumn<String> flowType = GeneratedColumn<String>(
      'flow_type', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES flow_types (id)'));
  static const VerificationMeta _activityMeta =
      const VerificationMeta('activity');
  @override
  late final GeneratedColumn<String> activity = GeneratedColumn<String>(
      'activity', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES activities (id)'));
  static const VerificationMeta _teamMeta = const VerificationMeta('team');
  @override
  late final GeneratedColumn<String> team = GeneratedColumn<String>(
      'team', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES teams (id)'));
  static const VerificationMeta _orgUnitMeta =
      const VerificationMeta('orgUnit');
  @override
  late final GeneratedColumn<String> orgUnit = GeneratedColumn<String>(
      'org_unit', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES org_units (id)'));
  static const VerificationMeta _flowInstanceDateMeta =
      const VerificationMeta('flowInstanceDate');
  @override
  late final GeneratedColumn<DateTime> flowInstanceDate =
      GeneratedColumn<DateTime>('flow_instance_date', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _entityInstanceMeta =
      const VerificationMeta('entityInstance');
  @override
  late final GeneratedColumn<String> entityInstance = GeneratedColumn<String>(
      'entity_instance', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES entity_instances (id)'));
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
      stepStates = GeneratedColumn<String>('step_states', aliasedName, true,
              type: DriftSqlType.string, requiredDuringInsert: false)
          .withConverter<Map<String, dynamic>?>(
              $FlowInstancesTable.$converterstepStates);
  @override
  late final GeneratedColumnWithTypeConverter<InstanceSyncStatus, String>
      syncState = GeneratedColumn<String>('sync_state', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<InstanceSyncStatus>(
              $FlowInstancesTable.$convertersyncState);
  @override
  late final GeneratedColumnWithTypeConverter<AssignmentStatus?, String>
      flowStatus = GeneratedColumn<String>('flow_status', aliasedName, true,
              type: DriftSqlType.string, requiredDuringInsert: false)
          .withConverter<AssignmentStatus?>(
              $FlowInstancesTable.$converterflowStatusn);
  static const VerificationMeta _completedDateMeta =
      const VerificationMeta('completedDate');
  @override
  late final GeneratedColumn<DateTime> completedDate =
      GeneratedColumn<DateTime>('completed_date', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _updatedAtClientMeta =
      const VerificationMeta('updatedAtClient');
  @override
  late final GeneratedColumn<DateTime> updatedAtClient =
      GeneratedColumn<DateTime>('updated_at_client', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        lastModifiedDate,
        createdDate,
        flowType,
        activity,
        team,
        orgUnit,
        flowInstanceDate,
        entityInstance,
        stepStates,
        syncState,
        flowStatus,
        completedDate,
        updatedAtClient
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'flow_instances';
  @override
  VerificationContext validateIntegrity(Insertable<FlowInstance> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('last_modified_date')) {
      context.handle(
          _lastModifiedDateMeta,
          lastModifiedDate.isAcceptableOrUnknown(
              data['last_modified_date']!, _lastModifiedDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('flow_type')) {
      context.handle(_flowTypeMeta,
          flowType.isAcceptableOrUnknown(data['flow_type']!, _flowTypeMeta));
    } else if (isInserting) {
      context.missing(_flowTypeMeta);
    }
    if (data.containsKey('activity')) {
      context.handle(_activityMeta,
          activity.isAcceptableOrUnknown(data['activity']!, _activityMeta));
    } else if (isInserting) {
      context.missing(_activityMeta);
    }
    if (data.containsKey('team')) {
      context.handle(
          _teamMeta, team.isAcceptableOrUnknown(data['team']!, _teamMeta));
    } else if (isInserting) {
      context.missing(_teamMeta);
    }
    if (data.containsKey('org_unit')) {
      context.handle(_orgUnitMeta,
          orgUnit.isAcceptableOrUnknown(data['org_unit']!, _orgUnitMeta));
    } else if (isInserting) {
      context.missing(_orgUnitMeta);
    }
    if (data.containsKey('flow_instance_date')) {
      context.handle(
          _flowInstanceDateMeta,
          flowInstanceDate.isAcceptableOrUnknown(
              data['flow_instance_date']!, _flowInstanceDateMeta));
    }
    if (data.containsKey('entity_instance')) {
      context.handle(
          _entityInstanceMeta,
          entityInstance.isAcceptableOrUnknown(
              data['entity_instance']!, _entityInstanceMeta));
    }
    if (data.containsKey('completed_date')) {
      context.handle(
          _completedDateMeta,
          completedDate.isAcceptableOrUnknown(
              data['completed_date']!, _completedDateMeta));
    }
    if (data.containsKey('updated_at_client')) {
      context.handle(
          _updatedAtClientMeta,
          updatedAtClient.isAcceptableOrUnknown(
              data['updated_at_client']!, _updatedAtClientMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FlowInstance map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FlowInstance(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      lastModifiedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_modified_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_date']),
      flowType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}flow_type'])!,
      activity: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}activity'])!,
      team: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}team'])!,
      orgUnit: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}org_unit'])!,
      flowInstanceDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}flow_instance_date']),
      entityInstance: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}entity_instance']),
      stepStates: $FlowInstancesTable.$converterstepStates.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}step_states'])),
      syncState: $FlowInstancesTable.$convertersyncState.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}sync_state'])!),
      flowStatus: $FlowInstancesTable.$converterflowStatusn.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}flow_status'])),
      completedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}completed_date']),
      updatedAtClient: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}updated_at_client']),
    );
  }

  @override
  $FlowInstancesTable createAlias(String alias) {
    return $FlowInstancesTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>?, String?> $converterstepStates =
      const NullAwareMapConverter();
  static JsonTypeConverter2<InstanceSyncStatus, String, String>
      $convertersyncState = const EnumNameConverter(InstanceSyncStatus.values);
  static JsonTypeConverter2<AssignmentStatus, String, String>
      $converterflowStatus = const EnumNameConverter(AssignmentStatus.values);
  static JsonTypeConverter2<AssignmentStatus?, String?, String?>
      $converterflowStatusn =
      JsonTypeConverter2.asNullable($converterflowStatus);
}

class FlowInstance extends DataClass implements Insertable<FlowInstance> {
  final String id;
  final DateTime? lastModifiedDate;
  final DateTime? createdDate;
  final String flowType;
  final String activity;
  final String team;
  final String orgUnit;
  final DateTime? flowInstanceDate;
/**
   * If you plan to pre-link an entity (e.g. a Household),
   * otherwise = null for “new” entities.
   */
  final String? entityInstance;

  /// A map of stageId → list of submissionIds (as JSON),
  /// or = null if SINGLE/SINGLE stage.
  /// not strictly required, just to Speed Up UI & Workflow Checks, Model the
  /// “Assignment State Machine” so it can store additional per‐stage metadata,
  /// and to avoid Joins Under Heavy Load
  final Map<String, dynamic>? stepStates;
  final InstanceSyncStatus syncState;
  final AssignmentStatus? flowStatus;
  final DateTime? completedDate;
  final DateTime? updatedAtClient;
  const FlowInstance(
      {required this.id,
      this.lastModifiedDate,
      this.createdDate,
      required this.flowType,
      required this.activity,
      required this.team,
      required this.orgUnit,
      this.flowInstanceDate,
      this.entityInstance,
      this.stepStates,
      required this.syncState,
      this.flowStatus,
      this.completedDate,
      this.updatedAtClient});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || lastModifiedDate != null) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<DateTime>(createdDate);
    }
    map['flow_type'] = Variable<String>(flowType);
    map['activity'] = Variable<String>(activity);
    map['team'] = Variable<String>(team);
    map['org_unit'] = Variable<String>(orgUnit);
    if (!nullToAbsent || flowInstanceDate != null) {
      map['flow_instance_date'] = Variable<DateTime>(flowInstanceDate);
    }
    if (!nullToAbsent || entityInstance != null) {
      map['entity_instance'] = Variable<String>(entityInstance);
    }
    if (!nullToAbsent || stepStates != null) {
      map['step_states'] = Variable<String>(
          $FlowInstancesTable.$converterstepStates.toSql(stepStates));
    }
    {
      map['sync_state'] = Variable<String>(
          $FlowInstancesTable.$convertersyncState.toSql(syncState));
    }
    if (!nullToAbsent || flowStatus != null) {
      map['flow_status'] = Variable<String>(
          $FlowInstancesTable.$converterflowStatusn.toSql(flowStatus));
    }
    if (!nullToAbsent || completedDate != null) {
      map['completed_date'] = Variable<DateTime>(completedDate);
    }
    if (!nullToAbsent || updatedAtClient != null) {
      map['updated_at_client'] = Variable<DateTime>(updatedAtClient);
    }
    return map;
  }

  FlowInstancesCompanion toCompanion(bool nullToAbsent) {
    return FlowInstancesCompanion(
      id: Value(id),
      lastModifiedDate: lastModifiedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      flowType: Value(flowType),
      activity: Value(activity),
      team: Value(team),
      orgUnit: Value(orgUnit),
      flowInstanceDate: flowInstanceDate == null && nullToAbsent
          ? const Value.absent()
          : Value(flowInstanceDate),
      entityInstance: entityInstance == null && nullToAbsent
          ? const Value.absent()
          : Value(entityInstance),
      stepStates: stepStates == null && nullToAbsent
          ? const Value.absent()
          : Value(stepStates),
      syncState: Value(syncState),
      flowStatus: flowStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(flowStatus),
      completedDate: completedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(completedDate),
      updatedAtClient: updatedAtClient == null && nullToAbsent
          ? const Value.absent()
          : Value(updatedAtClient),
    );
  }

  factory FlowInstance.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FlowInstance(
      id: serializer.fromJson<String>(json['id']),
      lastModifiedDate:
          serializer.fromJson<DateTime?>(json['lastModifiedDate']),
      createdDate: serializer.fromJson<DateTime?>(json['createdDate']),
      flowType: serializer.fromJson<String>(json['flowType']),
      activity: serializer.fromJson<String>(json['activity']),
      team: serializer.fromJson<String>(json['team']),
      orgUnit: serializer.fromJson<String>(json['orgUnit']),
      flowInstanceDate:
          serializer.fromJson<DateTime?>(json['flowInstanceDate']),
      entityInstance: serializer.fromJson<String?>(json['entityInstance']),
      stepStates:
          serializer.fromJson<Map<String, dynamic>?>(json['stepStates']),
      syncState: $FlowInstancesTable.$convertersyncState
          .fromJson(serializer.fromJson<String>(json['syncState'])),
      flowStatus: $FlowInstancesTable.$converterflowStatusn
          .fromJson(serializer.fromJson<String?>(json['flowStatus'])),
      completedDate: serializer.fromJson<DateTime?>(json['completedDate']),
      updatedAtClient: serializer.fromJson<DateTime?>(json['updatedAtClient']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'lastModifiedDate': serializer.toJson<DateTime?>(lastModifiedDate),
      'createdDate': serializer.toJson<DateTime?>(createdDate),
      'flowType': serializer.toJson<String>(flowType),
      'activity': serializer.toJson<String>(activity),
      'team': serializer.toJson<String>(team),
      'orgUnit': serializer.toJson<String>(orgUnit),
      'flowInstanceDate': serializer.toJson<DateTime?>(flowInstanceDate),
      'entityInstance': serializer.toJson<String?>(entityInstance),
      'stepStates': serializer.toJson<Map<String, dynamic>?>(stepStates),
      'syncState': serializer.toJson<String>(
          $FlowInstancesTable.$convertersyncState.toJson(syncState)),
      'flowStatus': serializer.toJson<String?>(
          $FlowInstancesTable.$converterflowStatusn.toJson(flowStatus)),
      'completedDate': serializer.toJson<DateTime?>(completedDate),
      'updatedAtClient': serializer.toJson<DateTime?>(updatedAtClient),
    };
  }

  FlowInstance copyWith(
          {String? id,
          Value<DateTime?> lastModifiedDate = const Value.absent(),
          Value<DateTime?> createdDate = const Value.absent(),
          String? flowType,
          String? activity,
          String? team,
          String? orgUnit,
          Value<DateTime?> flowInstanceDate = const Value.absent(),
          Value<String?> entityInstance = const Value.absent(),
          Value<Map<String, dynamic>?> stepStates = const Value.absent(),
          InstanceSyncStatus? syncState,
          Value<AssignmentStatus?> flowStatus = const Value.absent(),
          Value<DateTime?> completedDate = const Value.absent(),
          Value<DateTime?> updatedAtClient = const Value.absent()}) =>
      FlowInstance(
        id: id ?? this.id,
        lastModifiedDate: lastModifiedDate.present
            ? lastModifiedDate.value
            : this.lastModifiedDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        flowType: flowType ?? this.flowType,
        activity: activity ?? this.activity,
        team: team ?? this.team,
        orgUnit: orgUnit ?? this.orgUnit,
        flowInstanceDate: flowInstanceDate.present
            ? flowInstanceDate.value
            : this.flowInstanceDate,
        entityInstance:
            entityInstance.present ? entityInstance.value : this.entityInstance,
        stepStates: stepStates.present ? stepStates.value : this.stepStates,
        syncState: syncState ?? this.syncState,
        flowStatus: flowStatus.present ? flowStatus.value : this.flowStatus,
        completedDate:
            completedDate.present ? completedDate.value : this.completedDate,
        updatedAtClient: updatedAtClient.present
            ? updatedAtClient.value
            : this.updatedAtClient,
      );
  FlowInstance copyWithCompanion(FlowInstancesCompanion data) {
    return FlowInstance(
      id: data.id.present ? data.id.value : this.id,
      lastModifiedDate: data.lastModifiedDate.present
          ? data.lastModifiedDate.value
          : this.lastModifiedDate,
      createdDate:
          data.createdDate.present ? data.createdDate.value : this.createdDate,
      flowType: data.flowType.present ? data.flowType.value : this.flowType,
      activity: data.activity.present ? data.activity.value : this.activity,
      team: data.team.present ? data.team.value : this.team,
      orgUnit: data.orgUnit.present ? data.orgUnit.value : this.orgUnit,
      flowInstanceDate: data.flowInstanceDate.present
          ? data.flowInstanceDate.value
          : this.flowInstanceDate,
      entityInstance: data.entityInstance.present
          ? data.entityInstance.value
          : this.entityInstance,
      stepStates:
          data.stepStates.present ? data.stepStates.value : this.stepStates,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
      flowStatus:
          data.flowStatus.present ? data.flowStatus.value : this.flowStatus,
      completedDate: data.completedDate.present
          ? data.completedDate.value
          : this.completedDate,
      updatedAtClient: data.updatedAtClient.present
          ? data.updatedAtClient.value
          : this.updatedAtClient,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FlowInstance(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('flowType: $flowType, ')
          ..write('activity: $activity, ')
          ..write('team: $team, ')
          ..write('orgUnit: $orgUnit, ')
          ..write('flowInstanceDate: $flowInstanceDate, ')
          ..write('entityInstance: $entityInstance, ')
          ..write('stepStates: $stepStates, ')
          ..write('syncState: $syncState, ')
          ..write('flowStatus: $flowStatus, ')
          ..write('completedDate: $completedDate, ')
          ..write('updatedAtClient: $updatedAtClient')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      lastModifiedDate,
      createdDate,
      flowType,
      activity,
      team,
      orgUnit,
      flowInstanceDate,
      entityInstance,
      stepStates,
      syncState,
      flowStatus,
      completedDate,
      updatedAtClient);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FlowInstance &&
          other.id == this.id &&
          other.lastModifiedDate == this.lastModifiedDate &&
          other.createdDate == this.createdDate &&
          other.flowType == this.flowType &&
          other.activity == this.activity &&
          other.team == this.team &&
          other.orgUnit == this.orgUnit &&
          other.flowInstanceDate == this.flowInstanceDate &&
          other.entityInstance == this.entityInstance &&
          other.stepStates == this.stepStates &&
          other.syncState == this.syncState &&
          other.flowStatus == this.flowStatus &&
          other.completedDate == this.completedDate &&
          other.updatedAtClient == this.updatedAtClient);
}

class FlowInstancesCompanion extends UpdateCompanion<FlowInstance> {
  final Value<String> id;
  final Value<DateTime?> lastModifiedDate;
  final Value<DateTime?> createdDate;
  final Value<String> flowType;
  final Value<String> activity;
  final Value<String> team;
  final Value<String> orgUnit;
  final Value<DateTime?> flowInstanceDate;
  final Value<String?> entityInstance;
  final Value<Map<String, dynamic>?> stepStates;
  final Value<InstanceSyncStatus> syncState;
  final Value<AssignmentStatus?> flowStatus;
  final Value<DateTime?> completedDate;
  final Value<DateTime?> updatedAtClient;
  final Value<int> rowid;
  const FlowInstancesCompanion({
    this.id = const Value.absent(),
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.flowType = const Value.absent(),
    this.activity = const Value.absent(),
    this.team = const Value.absent(),
    this.orgUnit = const Value.absent(),
    this.flowInstanceDate = const Value.absent(),
    this.entityInstance = const Value.absent(),
    this.stepStates = const Value.absent(),
    this.syncState = const Value.absent(),
    this.flowStatus = const Value.absent(),
    this.completedDate = const Value.absent(),
    this.updatedAtClient = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FlowInstancesCompanion.insert({
    required String id,
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    required String flowType,
    required String activity,
    required String team,
    required String orgUnit,
    this.flowInstanceDate = const Value.absent(),
    this.entityInstance = const Value.absent(),
    this.stepStates = const Value.absent(),
    required InstanceSyncStatus syncState,
    this.flowStatus = const Value.absent(),
    this.completedDate = const Value.absent(),
    this.updatedAtClient = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        flowType = Value(flowType),
        activity = Value(activity),
        team = Value(team),
        orgUnit = Value(orgUnit),
        syncState = Value(syncState);
  static Insertable<FlowInstance> custom({
    Expression<String>? id,
    Expression<DateTime>? lastModifiedDate,
    Expression<DateTime>? createdDate,
    Expression<String>? flowType,
    Expression<String>? activity,
    Expression<String>? team,
    Expression<String>? orgUnit,
    Expression<DateTime>? flowInstanceDate,
    Expression<String>? entityInstance,
    Expression<String>? stepStates,
    Expression<String>? syncState,
    Expression<String>? flowStatus,
    Expression<DateTime>? completedDate,
    Expression<DateTime>? updatedAtClient,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (lastModifiedDate != null) 'last_modified_date': lastModifiedDate,
      if (createdDate != null) 'created_date': createdDate,
      if (flowType != null) 'flow_type': flowType,
      if (activity != null) 'activity': activity,
      if (team != null) 'team': team,
      if (orgUnit != null) 'org_unit': orgUnit,
      if (flowInstanceDate != null) 'flow_instance_date': flowInstanceDate,
      if (entityInstance != null) 'entity_instance': entityInstance,
      if (stepStates != null) 'step_states': stepStates,
      if (syncState != null) 'sync_state': syncState,
      if (flowStatus != null) 'flow_status': flowStatus,
      if (completedDate != null) 'completed_date': completedDate,
      if (updatedAtClient != null) 'updated_at_client': updatedAtClient,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FlowInstancesCompanion copyWith(
      {Value<String>? id,
      Value<DateTime?>? lastModifiedDate,
      Value<DateTime?>? createdDate,
      Value<String>? flowType,
      Value<String>? activity,
      Value<String>? team,
      Value<String>? orgUnit,
      Value<DateTime?>? flowInstanceDate,
      Value<String?>? entityInstance,
      Value<Map<String, dynamic>?>? stepStates,
      Value<InstanceSyncStatus>? syncState,
      Value<AssignmentStatus?>? flowStatus,
      Value<DateTime?>? completedDate,
      Value<DateTime?>? updatedAtClient,
      Value<int>? rowid}) {
    return FlowInstancesCompanion(
      id: id ?? this.id,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      createdDate: createdDate ?? this.createdDate,
      flowType: flowType ?? this.flowType,
      activity: activity ?? this.activity,
      team: team ?? this.team,
      orgUnit: orgUnit ?? this.orgUnit,
      flowInstanceDate: flowInstanceDate ?? this.flowInstanceDate,
      entityInstance: entityInstance ?? this.entityInstance,
      stepStates: stepStates ?? this.stepStates,
      syncState: syncState ?? this.syncState,
      flowStatus: flowStatus ?? this.flowStatus,
      completedDate: completedDate ?? this.completedDate,
      updatedAtClient: updatedAtClient ?? this.updatedAtClient,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (lastModifiedDate.present) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<DateTime>(createdDate.value);
    }
    if (flowType.present) {
      map['flow_type'] = Variable<String>(flowType.value);
    }
    if (activity.present) {
      map['activity'] = Variable<String>(activity.value);
    }
    if (team.present) {
      map['team'] = Variable<String>(team.value);
    }
    if (orgUnit.present) {
      map['org_unit'] = Variable<String>(orgUnit.value);
    }
    if (flowInstanceDate.present) {
      map['flow_instance_date'] = Variable<DateTime>(flowInstanceDate.value);
    }
    if (entityInstance.present) {
      map['entity_instance'] = Variable<String>(entityInstance.value);
    }
    if (stepStates.present) {
      map['step_states'] = Variable<String>(
          $FlowInstancesTable.$converterstepStates.toSql(stepStates.value));
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(
          $FlowInstancesTable.$convertersyncState.toSql(syncState.value));
    }
    if (flowStatus.present) {
      map['flow_status'] = Variable<String>(
          $FlowInstancesTable.$converterflowStatusn.toSql(flowStatus.value));
    }
    if (completedDate.present) {
      map['completed_date'] = Variable<DateTime>(completedDate.value);
    }
    if (updatedAtClient.present) {
      map['updated_at_client'] = Variable<DateTime>(updatedAtClient.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FlowInstancesCompanion(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('flowType: $flowType, ')
          ..write('activity: $activity, ')
          ..write('team: $team, ')
          ..write('orgUnit: $orgUnit, ')
          ..write('flowInstanceDate: $flowInstanceDate, ')
          ..write('entityInstance: $entityInstance, ')
          ..write('stepStates: $stepStates, ')
          ..write('syncState: $syncState, ')
          ..write('flowStatus: $flowStatus, ')
          ..write('completedDate: $completedDate, ')
          ..write('updatedAtClient: $updatedAtClient, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FormTemplatesTable extends FormTemplates
    with TableInfo<$FormTemplatesTable, FormTemplate> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FormTemplatesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _formVersionMeta =
      const VerificationMeta('formVersion');
  @override
  late final GeneratedColumn<String> formVersion = GeneratedColumn<String>(
      'form_version', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _versionNumberMeta =
      const VerificationMeta('versionNumber');
  @override
  late final GeneratedColumn<int> versionNumber = GeneratedColumn<int>(
      'version_number', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
      label = GeneratedColumn<String>('label', aliasedName, true,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '{}')
          .withConverter<Map<String, dynamic>?>(
              $FormTemplatesTable.$converterlabel);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [id, formVersion, versionNumber, name, label, description];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'form_templates';
  @override
  VerificationContext validateIntegrity(Insertable<FormTemplate> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('form_version')) {
      context.handle(
          _formVersionMeta,
          formVersion.isAcceptableOrUnknown(
              data['form_version']!, _formVersionMeta));
    } else if (isInserting) {
      context.missing(_formVersionMeta);
    }
    if (data.containsKey('version_number')) {
      context.handle(
          _versionNumberMeta,
          versionNumber.isAcceptableOrUnknown(
              data['version_number']!, _versionNumberMeta));
    } else if (isInserting) {
      context.missing(_versionNumberMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FormTemplate map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FormTemplate(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      formVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}form_version'])!,
      versionNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}version_number'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      label: $FormTemplatesTable.$converterlabel.fromSql(attachedDatabase
          .typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}label'])),
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
    );
  }

  @override
  $FormTemplatesTable createAlias(String alias) {
    return $FormTemplatesTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>?, String?> $converterlabel =
      const NullAwareMapConverter();
}

class FormTemplate extends DataClass implements Insertable<FormTemplate> {
  final String id;

  /// current form version uid
  final String formVersion;

  /// current form version number
  final int versionNumber;
  final String name;
  final Map<String, dynamic>? label;
  final String? description;
  const FormTemplate(
      {required this.id,
      required this.formVersion,
      required this.versionNumber,
      required this.name,
      this.label,
      this.description});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['form_version'] = Variable<String>(formVersion);
    map['version_number'] = Variable<int>(versionNumber);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || label != null) {
      map['label'] =
          Variable<String>($FormTemplatesTable.$converterlabel.toSql(label));
    }
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    return map;
  }

  FormTemplatesCompanion toCompanion(bool nullToAbsent) {
    return FormTemplatesCompanion(
      id: Value(id),
      formVersion: Value(formVersion),
      versionNumber: Value(versionNumber),
      name: Value(name),
      label:
          label == null && nullToAbsent ? const Value.absent() : Value(label),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
    );
  }

  factory FormTemplate.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FormTemplate(
      id: serializer.fromJson<String>(json['id']),
      formVersion: serializer.fromJson<String>(json['formVersion']),
      versionNumber: serializer.fromJson<int>(json['versionNumber']),
      name: serializer.fromJson<String>(json['name']),
      label: serializer.fromJson<Map<String, dynamic>?>(json['label']),
      description: serializer.fromJson<String?>(json['description']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'formVersion': serializer.toJson<String>(formVersion),
      'versionNumber': serializer.toJson<int>(versionNumber),
      'name': serializer.toJson<String>(name),
      'label': serializer.toJson<Map<String, dynamic>?>(label),
      'description': serializer.toJson<String?>(description),
    };
  }

  FormTemplate copyWith(
          {String? id,
          String? formVersion,
          int? versionNumber,
          String? name,
          Value<Map<String, dynamic>?> label = const Value.absent(),
          Value<String?> description = const Value.absent()}) =>
      FormTemplate(
        id: id ?? this.id,
        formVersion: formVersion ?? this.formVersion,
        versionNumber: versionNumber ?? this.versionNumber,
        name: name ?? this.name,
        label: label.present ? label.value : this.label,
        description: description.present ? description.value : this.description,
      );
  FormTemplate copyWithCompanion(FormTemplatesCompanion data) {
    return FormTemplate(
      id: data.id.present ? data.id.value : this.id,
      formVersion:
          data.formVersion.present ? data.formVersion.value : this.formVersion,
      versionNumber: data.versionNumber.present
          ? data.versionNumber.value
          : this.versionNumber,
      name: data.name.present ? data.name.value : this.name,
      label: data.label.present ? data.label.value : this.label,
      description:
          data.description.present ? data.description.value : this.description,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FormTemplate(')
          ..write('id: $id, ')
          ..write('formVersion: $formVersion, ')
          ..write('versionNumber: $versionNumber, ')
          ..write('name: $name, ')
          ..write('label: $label, ')
          ..write('description: $description')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, formVersion, versionNumber, name, label, description);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FormTemplate &&
          other.id == this.id &&
          other.formVersion == this.formVersion &&
          other.versionNumber == this.versionNumber &&
          other.name == this.name &&
          other.label == this.label &&
          other.description == this.description);
}

class FormTemplatesCompanion extends UpdateCompanion<FormTemplate> {
  final Value<String> id;
  final Value<String> formVersion;
  final Value<int> versionNumber;
  final Value<String> name;
  final Value<Map<String, dynamic>?> label;
  final Value<String?> description;
  final Value<int> rowid;
  const FormTemplatesCompanion({
    this.id = const Value.absent(),
    this.formVersion = const Value.absent(),
    this.versionNumber = const Value.absent(),
    this.name = const Value.absent(),
    this.label = const Value.absent(),
    this.description = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FormTemplatesCompanion.insert({
    required String id,
    required String formVersion,
    required int versionNumber,
    required String name,
    this.label = const Value.absent(),
    this.description = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        formVersion = Value(formVersion),
        versionNumber = Value(versionNumber),
        name = Value(name);
  static Insertable<FormTemplate> custom({
    Expression<String>? id,
    Expression<String>? formVersion,
    Expression<int>? versionNumber,
    Expression<String>? name,
    Expression<String>? label,
    Expression<String>? description,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (formVersion != null) 'form_version': formVersion,
      if (versionNumber != null) 'version_number': versionNumber,
      if (name != null) 'name': name,
      if (label != null) 'label': label,
      if (description != null) 'description': description,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FormTemplatesCompanion copyWith(
      {Value<String>? id,
      Value<String>? formVersion,
      Value<int>? versionNumber,
      Value<String>? name,
      Value<Map<String, dynamic>?>? label,
      Value<String?>? description,
      Value<int>? rowid}) {
    return FormTemplatesCompanion(
      id: id ?? this.id,
      formVersion: formVersion ?? this.formVersion,
      versionNumber: versionNumber ?? this.versionNumber,
      name: name ?? this.name,
      label: label ?? this.label,
      description: description ?? this.description,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (formVersion.present) {
      map['form_version'] = Variable<String>(formVersion.value);
    }
    if (versionNumber.present) {
      map['version_number'] = Variable<int>(versionNumber.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (label.present) {
      map['label'] = Variable<String>(
          $FormTemplatesTable.$converterlabel.toSql(label.value));
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FormTemplatesCompanion(')
          ..write('id: $id, ')
          ..write('formVersion: $formVersion, ')
          ..write('versionNumber: $versionNumber, ')
          ..write('name: $name, ')
          ..write('label: $label, ')
          ..write('description: $description, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AssignmentFormsTable extends AssignmentForms
    with TableInfo<$AssignmentFormsTable, AssignmentForm> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AssignmentFormsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _assignmentMeta =
      const VerificationMeta('assignment');
  @override
  late final GeneratedColumn<String> assignment = GeneratedColumn<String>(
      'assignment', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES flow_instances (id) ON UPDATE CASCADE'));
  static const VerificationMeta _formMeta = const VerificationMeta('form');
  @override
  late final GeneratedColumn<String> form = GeneratedColumn<String>(
      'form', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES form_templates (id)'));
  static const VerificationMeta _canAddSubmissionsMeta =
      const VerificationMeta('canAddSubmissions');
  @override
  late final GeneratedColumn<bool> canAddSubmissions = GeneratedColumn<bool>(
      'can_add_submissions', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("can_add_submissions" IN (0, 1))'),
      clientDefault: () => false);
  static const VerificationMeta _canViewSubmissionsMeta =
      const VerificationMeta('canViewSubmissions');
  @override
  late final GeneratedColumn<bool> canViewSubmissions = GeneratedColumn<bool>(
      'can_view_submissions', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("can_view_submissions" IN (0, 1))'),
      clientDefault: () => false);
  static const VerificationMeta _canEditSubmissionsMeta =
      const VerificationMeta('canEditSubmissions');
  @override
  late final GeneratedColumn<bool> canEditSubmissions = GeneratedColumn<bool>(
      'can_edit_submissions', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("can_edit_submissions" IN (0, 1))'),
      clientDefault: () => false);
  static const VerificationMeta _canDeleteSubmissionsMeta =
      const VerificationMeta('canDeleteSubmissions');
  @override
  late final GeneratedColumn<bool> canDeleteSubmissions = GeneratedColumn<bool>(
      'can_delete_submissions', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("can_delete_submissions" IN (0, 1))'),
      clientDefault: () => false);
  @override
  List<GeneratedColumn> get $columns => [
        assignment,
        form,
        canAddSubmissions,
        canViewSubmissions,
        canEditSubmissions,
        canDeleteSubmissions
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'assignment_forms';
  @override
  VerificationContext validateIntegrity(Insertable<AssignmentForm> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('assignment')) {
      context.handle(
          _assignmentMeta,
          assignment.isAcceptableOrUnknown(
              data['assignment']!, _assignmentMeta));
    } else if (isInserting) {
      context.missing(_assignmentMeta);
    }
    if (data.containsKey('form')) {
      context.handle(
          _formMeta, form.isAcceptableOrUnknown(data['form']!, _formMeta));
    } else if (isInserting) {
      context.missing(_formMeta);
    }
    if (data.containsKey('can_add_submissions')) {
      context.handle(
          _canAddSubmissionsMeta,
          canAddSubmissions.isAcceptableOrUnknown(
              data['can_add_submissions']!, _canAddSubmissionsMeta));
    }
    if (data.containsKey('can_view_submissions')) {
      context.handle(
          _canViewSubmissionsMeta,
          canViewSubmissions.isAcceptableOrUnknown(
              data['can_view_submissions']!, _canViewSubmissionsMeta));
    }
    if (data.containsKey('can_edit_submissions')) {
      context.handle(
          _canEditSubmissionsMeta,
          canEditSubmissions.isAcceptableOrUnknown(
              data['can_edit_submissions']!, _canEditSubmissionsMeta));
    }
    if (data.containsKey('can_delete_submissions')) {
      context.handle(
          _canDeleteSubmissionsMeta,
          canDeleteSubmissions.isAcceptableOrUnknown(
              data['can_delete_submissions']!, _canDeleteSubmissionsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {assignment, form};
  @override
  AssignmentForm map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AssignmentForm(
      assignment: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}assignment'])!,
      form: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}form'])!,
      canAddSubmissions: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}can_add_submissions']),
      canViewSubmissions: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}can_view_submissions']),
      canEditSubmissions: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}can_edit_submissions']),
      canDeleteSubmissions: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}can_delete_submissions']),
    );
  }

  @override
  $AssignmentFormsTable createAlias(String alias) {
    return $AssignmentFormsTable(attachedDatabase, alias);
  }
}

class AssignmentForm extends DataClass implements Insertable<AssignmentForm> {
  final String assignment;
  final String form;
  final bool? canAddSubmissions;
  final bool? canViewSubmissions;
  final bool? canEditSubmissions;
  final bool? canDeleteSubmissions;
  const AssignmentForm(
      {required this.assignment,
      required this.form,
      this.canAddSubmissions,
      this.canViewSubmissions,
      this.canEditSubmissions,
      this.canDeleteSubmissions});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['assignment'] = Variable<String>(assignment);
    map['form'] = Variable<String>(form);
    if (!nullToAbsent || canAddSubmissions != null) {
      map['can_add_submissions'] = Variable<bool>(canAddSubmissions);
    }
    if (!nullToAbsent || canViewSubmissions != null) {
      map['can_view_submissions'] = Variable<bool>(canViewSubmissions);
    }
    if (!nullToAbsent || canEditSubmissions != null) {
      map['can_edit_submissions'] = Variable<bool>(canEditSubmissions);
    }
    if (!nullToAbsent || canDeleteSubmissions != null) {
      map['can_delete_submissions'] = Variable<bool>(canDeleteSubmissions);
    }
    return map;
  }

  AssignmentFormsCompanion toCompanion(bool nullToAbsent) {
    return AssignmentFormsCompanion(
      assignment: Value(assignment),
      form: Value(form),
      canAddSubmissions: canAddSubmissions == null && nullToAbsent
          ? const Value.absent()
          : Value(canAddSubmissions),
      canViewSubmissions: canViewSubmissions == null && nullToAbsent
          ? const Value.absent()
          : Value(canViewSubmissions),
      canEditSubmissions: canEditSubmissions == null && nullToAbsent
          ? const Value.absent()
          : Value(canEditSubmissions),
      canDeleteSubmissions: canDeleteSubmissions == null && nullToAbsent
          ? const Value.absent()
          : Value(canDeleteSubmissions),
    );
  }

  factory AssignmentForm.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AssignmentForm(
      assignment: serializer.fromJson<String>(json['assignment']),
      form: serializer.fromJson<String>(json['form']),
      canAddSubmissions: serializer.fromJson<bool?>(json['canAddSubmissions']),
      canViewSubmissions:
          serializer.fromJson<bool?>(json['canViewSubmissions']),
      canEditSubmissions:
          serializer.fromJson<bool?>(json['canEditSubmissions']),
      canDeleteSubmissions:
          serializer.fromJson<bool?>(json['canDeleteSubmissions']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'assignment': serializer.toJson<String>(assignment),
      'form': serializer.toJson<String>(form),
      'canAddSubmissions': serializer.toJson<bool?>(canAddSubmissions),
      'canViewSubmissions': serializer.toJson<bool?>(canViewSubmissions),
      'canEditSubmissions': serializer.toJson<bool?>(canEditSubmissions),
      'canDeleteSubmissions': serializer.toJson<bool?>(canDeleteSubmissions),
    };
  }

  AssignmentForm copyWith(
          {String? assignment,
          String? form,
          Value<bool?> canAddSubmissions = const Value.absent(),
          Value<bool?> canViewSubmissions = const Value.absent(),
          Value<bool?> canEditSubmissions = const Value.absent(),
          Value<bool?> canDeleteSubmissions = const Value.absent()}) =>
      AssignmentForm(
        assignment: assignment ?? this.assignment,
        form: form ?? this.form,
        canAddSubmissions: canAddSubmissions.present
            ? canAddSubmissions.value
            : this.canAddSubmissions,
        canViewSubmissions: canViewSubmissions.present
            ? canViewSubmissions.value
            : this.canViewSubmissions,
        canEditSubmissions: canEditSubmissions.present
            ? canEditSubmissions.value
            : this.canEditSubmissions,
        canDeleteSubmissions: canDeleteSubmissions.present
            ? canDeleteSubmissions.value
            : this.canDeleteSubmissions,
      );
  AssignmentForm copyWithCompanion(AssignmentFormsCompanion data) {
    return AssignmentForm(
      assignment:
          data.assignment.present ? data.assignment.value : this.assignment,
      form: data.form.present ? data.form.value : this.form,
      canAddSubmissions: data.canAddSubmissions.present
          ? data.canAddSubmissions.value
          : this.canAddSubmissions,
      canViewSubmissions: data.canViewSubmissions.present
          ? data.canViewSubmissions.value
          : this.canViewSubmissions,
      canEditSubmissions: data.canEditSubmissions.present
          ? data.canEditSubmissions.value
          : this.canEditSubmissions,
      canDeleteSubmissions: data.canDeleteSubmissions.present
          ? data.canDeleteSubmissions.value
          : this.canDeleteSubmissions,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AssignmentForm(')
          ..write('assignment: $assignment, ')
          ..write('form: $form, ')
          ..write('canAddSubmissions: $canAddSubmissions, ')
          ..write('canViewSubmissions: $canViewSubmissions, ')
          ..write('canEditSubmissions: $canEditSubmissions, ')
          ..write('canDeleteSubmissions: $canDeleteSubmissions')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(assignment, form, canAddSubmissions,
      canViewSubmissions, canEditSubmissions, canDeleteSubmissions);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AssignmentForm &&
          other.assignment == this.assignment &&
          other.form == this.form &&
          other.canAddSubmissions == this.canAddSubmissions &&
          other.canViewSubmissions == this.canViewSubmissions &&
          other.canEditSubmissions == this.canEditSubmissions &&
          other.canDeleteSubmissions == this.canDeleteSubmissions);
}

class AssignmentFormsCompanion extends UpdateCompanion<AssignmentForm> {
  final Value<String> assignment;
  final Value<String> form;
  final Value<bool?> canAddSubmissions;
  final Value<bool?> canViewSubmissions;
  final Value<bool?> canEditSubmissions;
  final Value<bool?> canDeleteSubmissions;
  final Value<int> rowid;
  const AssignmentFormsCompanion({
    this.assignment = const Value.absent(),
    this.form = const Value.absent(),
    this.canAddSubmissions = const Value.absent(),
    this.canViewSubmissions = const Value.absent(),
    this.canEditSubmissions = const Value.absent(),
    this.canDeleteSubmissions = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AssignmentFormsCompanion.insert({
    required String assignment,
    required String form,
    this.canAddSubmissions = const Value.absent(),
    this.canViewSubmissions = const Value.absent(),
    this.canEditSubmissions = const Value.absent(),
    this.canDeleteSubmissions = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : assignment = Value(assignment),
        form = Value(form);
  static Insertable<AssignmentForm> custom({
    Expression<String>? assignment,
    Expression<String>? form,
    Expression<bool>? canAddSubmissions,
    Expression<bool>? canViewSubmissions,
    Expression<bool>? canEditSubmissions,
    Expression<bool>? canDeleteSubmissions,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (assignment != null) 'assignment': assignment,
      if (form != null) 'form': form,
      if (canAddSubmissions != null) 'can_add_submissions': canAddSubmissions,
      if (canViewSubmissions != null)
        'can_view_submissions': canViewSubmissions,
      if (canEditSubmissions != null)
        'can_edit_submissions': canEditSubmissions,
      if (canDeleteSubmissions != null)
        'can_delete_submissions': canDeleteSubmissions,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AssignmentFormsCompanion copyWith(
      {Value<String>? assignment,
      Value<String>? form,
      Value<bool?>? canAddSubmissions,
      Value<bool?>? canViewSubmissions,
      Value<bool?>? canEditSubmissions,
      Value<bool?>? canDeleteSubmissions,
      Value<int>? rowid}) {
    return AssignmentFormsCompanion(
      assignment: assignment ?? this.assignment,
      form: form ?? this.form,
      canAddSubmissions: canAddSubmissions ?? this.canAddSubmissions,
      canViewSubmissions: canViewSubmissions ?? this.canViewSubmissions,
      canEditSubmissions: canEditSubmissions ?? this.canEditSubmissions,
      canDeleteSubmissions: canDeleteSubmissions ?? this.canDeleteSubmissions,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (assignment.present) {
      map['assignment'] = Variable<String>(assignment.value);
    }
    if (form.present) {
      map['form'] = Variable<String>(form.value);
    }
    if (canAddSubmissions.present) {
      map['can_add_submissions'] = Variable<bool>(canAddSubmissions.value);
    }
    if (canViewSubmissions.present) {
      map['can_view_submissions'] = Variable<bool>(canViewSubmissions.value);
    }
    if (canEditSubmissions.present) {
      map['can_edit_submissions'] = Variable<bool>(canEditSubmissions.value);
    }
    if (canDeleteSubmissions.present) {
      map['can_delete_submissions'] =
          Variable<bool>(canDeleteSubmissions.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AssignmentFormsCompanion(')
          ..write('assignment: $assignment, ')
          ..write('form: $form, ')
          ..write('canAddSubmissions: $canAddSubmissions, ')
          ..write('canViewSubmissions: $canViewSubmissions, ')
          ..write('canEditSubmissions: $canEditSubmissions, ')
          ..write('canDeleteSubmissions: $canDeleteSubmissions, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $MetadataSubmissionsTable extends MetadataSubmissions
    with TableInfo<$MetadataSubmissionsTable, MetadataSubmission> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MetadataSubmissionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _lastModifiedDateMeta =
      const VerificationMeta('lastModifiedDate');
  @override
  late final GeneratedColumn<DateTime> lastModifiedDate =
      GeneratedColumn<DateTime>('last_modified_date', aliasedName, true,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<DateTime> createdDate = GeneratedColumn<DateTime>(
      'created_date', aliasedName, true,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      clientDefault: () => DateTime.now().toUtc());
  @override
  late final GeneratedColumnWithTypeConverter<MetadataResourceType, String>
      resourceType = GeneratedColumn<String>(
              'resource_type', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<MetadataResourceType>(
              $MetadataSubmissionsTable.$converterresourceType);
  static const VerificationMeta _metadataSchemaMeta =
      const VerificationMeta('metadataSchema');
  @override
  late final GeneratedColumn<String> metadataSchema = GeneratedColumn<String>(
      'metadata_schema', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _serialNumberMeta =
      const VerificationMeta('serialNumber');
  @override
  late final GeneratedColumn<int> serialNumber = GeneratedColumn<int>(
      'serial_number', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _versionMeta =
      const VerificationMeta('version');
  @override
  late final GeneratedColumn<int> version = GeneratedColumn<int>(
      'version', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _resourceIdMeta =
      const VerificationMeta('resourceId');
  @override
  late final GeneratedColumn<String> resourceId = GeneratedColumn<String>(
      'resource_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
      formData = GeneratedColumn<String>('form_data', aliasedName, true,
              type: DriftSqlType.string, requiredDuringInsert: false)
          .withConverter<Map<String, dynamic>?>(
              $MetadataSubmissionsTable.$converterformData);
  static const VerificationMeta _createdByMeta =
      const VerificationMeta('createdBy');
  @override
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
      'created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _lastModifiedByMeta =
      const VerificationMeta('lastModifiedBy');
  @override
  late final GeneratedColumn<String> lastModifiedBy = GeneratedColumn<String>(
      'last_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        lastModifiedDate,
        createdDate,
        resourceType,
        metadataSchema,
        serialNumber,
        version,
        resourceId,
        formData,
        createdBy,
        lastModifiedBy
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'metadata_submissions';
  @override
  VerificationContext validateIntegrity(Insertable<MetadataSubmission> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('last_modified_date')) {
      context.handle(
          _lastModifiedDateMeta,
          lastModifiedDate.isAcceptableOrUnknown(
              data['last_modified_date']!, _lastModifiedDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('metadata_schema')) {
      context.handle(
          _metadataSchemaMeta,
          metadataSchema.isAcceptableOrUnknown(
              data['metadata_schema']!, _metadataSchemaMeta));
    } else if (isInserting) {
      context.missing(_metadataSchemaMeta);
    }
    if (data.containsKey('serial_number')) {
      context.handle(
          _serialNumberMeta,
          serialNumber.isAcceptableOrUnknown(
              data['serial_number']!, _serialNumberMeta));
    } else if (isInserting) {
      context.missing(_serialNumberMeta);
    }
    if (data.containsKey('version')) {
      context.handle(_versionMeta,
          version.isAcceptableOrUnknown(data['version']!, _versionMeta));
    } else if (isInserting) {
      context.missing(_versionMeta);
    }
    if (data.containsKey('resource_id')) {
      context.handle(
          _resourceIdMeta,
          resourceId.isAcceptableOrUnknown(
              data['resource_id']!, _resourceIdMeta));
    } else if (isInserting) {
      context.missing(_resourceIdMeta);
    }
    if (data.containsKey('created_by')) {
      context.handle(_createdByMeta,
          createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta));
    }
    if (data.containsKey('last_modified_by')) {
      context.handle(
          _lastModifiedByMeta,
          lastModifiedBy.isAcceptableOrUnknown(
              data['last_modified_by']!, _lastModifiedByMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  MetadataSubmission map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MetadataSubmission(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      lastModifiedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_modified_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_date']),
      resourceType: $MetadataSubmissionsTable.$converterresourceType.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}resource_type'])!),
      metadataSchema: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}metadata_schema'])!,
      serialNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}serial_number'])!,
      version: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}version'])!,
      resourceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}resource_id'])!,
      formData: $MetadataSubmissionsTable.$converterformData.fromSql(
          attachedDatabase.typeMapping
              .read(DriftSqlType.string, data['${effectivePrefix}form_data'])),
      createdBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}created_by']),
      lastModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}last_modified_by']),
    );
  }

  @override
  $MetadataSubmissionsTable createAlias(String alias) {
    return $MetadataSubmissionsTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<MetadataResourceType, String, String>
      $converterresourceType =
      const EnumNameConverter(MetadataResourceType.values);
  static TypeConverter<Map<String, dynamic>?, String?> $converterformData =
      const NullAwareMapConverter();
}

class MetadataSubmission extends DataClass
    implements Insertable<MetadataSubmission> {
  final String id;
  final DateTime? lastModifiedDate;
  final DateTime? createdDate;
  final MetadataResourceType resourceType;
  final String metadataSchema;
  final int serialNumber;
  final int version;
  final String resourceId;
  final Map<String, dynamic>? formData;
  final String? createdBy;
  final String? lastModifiedBy;
  const MetadataSubmission(
      {required this.id,
      this.lastModifiedDate,
      this.createdDate,
      required this.resourceType,
      required this.metadataSchema,
      required this.serialNumber,
      required this.version,
      required this.resourceId,
      this.formData,
      this.createdBy,
      this.lastModifiedBy});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || lastModifiedDate != null) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<DateTime>(createdDate);
    }
    {
      map['resource_type'] = Variable<String>(
          $MetadataSubmissionsTable.$converterresourceType.toSql(resourceType));
    }
    map['metadata_schema'] = Variable<String>(metadataSchema);
    map['serial_number'] = Variable<int>(serialNumber);
    map['version'] = Variable<int>(version);
    map['resource_id'] = Variable<String>(resourceId);
    if (!nullToAbsent || formData != null) {
      map['form_data'] = Variable<String>(
          $MetadataSubmissionsTable.$converterformData.toSql(formData));
    }
    if (!nullToAbsent || createdBy != null) {
      map['created_by'] = Variable<String>(createdBy);
    }
    if (!nullToAbsent || lastModifiedBy != null) {
      map['last_modified_by'] = Variable<String>(lastModifiedBy);
    }
    return map;
  }

  MetadataSubmissionsCompanion toCompanion(bool nullToAbsent) {
    return MetadataSubmissionsCompanion(
      id: Value(id),
      lastModifiedDate: lastModifiedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      resourceType: Value(resourceType),
      metadataSchema: Value(metadataSchema),
      serialNumber: Value(serialNumber),
      version: Value(version),
      resourceId: Value(resourceId),
      formData: formData == null && nullToAbsent
          ? const Value.absent()
          : Value(formData),
      createdBy: createdBy == null && nullToAbsent
          ? const Value.absent()
          : Value(createdBy),
      lastModifiedBy: lastModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedBy),
    );
  }

  factory MetadataSubmission.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MetadataSubmission(
      id: serializer.fromJson<String>(json['id']),
      lastModifiedDate:
          serializer.fromJson<DateTime?>(json['lastModifiedDate']),
      createdDate: serializer.fromJson<DateTime?>(json['createdDate']),
      resourceType: $MetadataSubmissionsTable.$converterresourceType
          .fromJson(serializer.fromJson<String>(json['resourceType'])),
      metadataSchema: serializer.fromJson<String>(json['metadataSchema']),
      serialNumber: serializer.fromJson<int>(json['serialNumber']),
      version: serializer.fromJson<int>(json['version']),
      resourceId: serializer.fromJson<String>(json['resourceId']),
      formData: serializer.fromJson<Map<String, dynamic>?>(json['formData']),
      createdBy: serializer.fromJson<String?>(json['createdBy']),
      lastModifiedBy: serializer.fromJson<String?>(json['lastModifiedBy']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'lastModifiedDate': serializer.toJson<DateTime?>(lastModifiedDate),
      'createdDate': serializer.toJson<DateTime?>(createdDate),
      'resourceType': serializer.toJson<String>($MetadataSubmissionsTable
          .$converterresourceType
          .toJson(resourceType)),
      'metadataSchema': serializer.toJson<String>(metadataSchema),
      'serialNumber': serializer.toJson<int>(serialNumber),
      'version': serializer.toJson<int>(version),
      'resourceId': serializer.toJson<String>(resourceId),
      'formData': serializer.toJson<Map<String, dynamic>?>(formData),
      'createdBy': serializer.toJson<String?>(createdBy),
      'lastModifiedBy': serializer.toJson<String?>(lastModifiedBy),
    };
  }

  MetadataSubmission copyWith(
          {String? id,
          Value<DateTime?> lastModifiedDate = const Value.absent(),
          Value<DateTime?> createdDate = const Value.absent(),
          MetadataResourceType? resourceType,
          String? metadataSchema,
          int? serialNumber,
          int? version,
          String? resourceId,
          Value<Map<String, dynamic>?> formData = const Value.absent(),
          Value<String?> createdBy = const Value.absent(),
          Value<String?> lastModifiedBy = const Value.absent()}) =>
      MetadataSubmission(
        id: id ?? this.id,
        lastModifiedDate: lastModifiedDate.present
            ? lastModifiedDate.value
            : this.lastModifiedDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        resourceType: resourceType ?? this.resourceType,
        metadataSchema: metadataSchema ?? this.metadataSchema,
        serialNumber: serialNumber ?? this.serialNumber,
        version: version ?? this.version,
        resourceId: resourceId ?? this.resourceId,
        formData: formData.present ? formData.value : this.formData,
        createdBy: createdBy.present ? createdBy.value : this.createdBy,
        lastModifiedBy:
            lastModifiedBy.present ? lastModifiedBy.value : this.lastModifiedBy,
      );
  MetadataSubmission copyWithCompanion(MetadataSubmissionsCompanion data) {
    return MetadataSubmission(
      id: data.id.present ? data.id.value : this.id,
      lastModifiedDate: data.lastModifiedDate.present
          ? data.lastModifiedDate.value
          : this.lastModifiedDate,
      createdDate:
          data.createdDate.present ? data.createdDate.value : this.createdDate,
      resourceType: data.resourceType.present
          ? data.resourceType.value
          : this.resourceType,
      metadataSchema: data.metadataSchema.present
          ? data.metadataSchema.value
          : this.metadataSchema,
      serialNumber: data.serialNumber.present
          ? data.serialNumber.value
          : this.serialNumber,
      version: data.version.present ? data.version.value : this.version,
      resourceId:
          data.resourceId.present ? data.resourceId.value : this.resourceId,
      formData: data.formData.present ? data.formData.value : this.formData,
      createdBy: data.createdBy.present ? data.createdBy.value : this.createdBy,
      lastModifiedBy: data.lastModifiedBy.present
          ? data.lastModifiedBy.value
          : this.lastModifiedBy,
    );
  }

  @override
  String toString() {
    return (StringBuffer('MetadataSubmission(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('resourceType: $resourceType, ')
          ..write('metadataSchema: $metadataSchema, ')
          ..write('serialNumber: $serialNumber, ')
          ..write('version: $version, ')
          ..write('resourceId: $resourceId, ')
          ..write('formData: $formData, ')
          ..write('createdBy: $createdBy, ')
          ..write('lastModifiedBy: $lastModifiedBy')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      lastModifiedDate,
      createdDate,
      resourceType,
      metadataSchema,
      serialNumber,
      version,
      resourceId,
      formData,
      createdBy,
      lastModifiedBy);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MetadataSubmission &&
          other.id == this.id &&
          other.lastModifiedDate == this.lastModifiedDate &&
          other.createdDate == this.createdDate &&
          other.resourceType == this.resourceType &&
          other.metadataSchema == this.metadataSchema &&
          other.serialNumber == this.serialNumber &&
          other.version == this.version &&
          other.resourceId == this.resourceId &&
          other.formData == this.formData &&
          other.createdBy == this.createdBy &&
          other.lastModifiedBy == this.lastModifiedBy);
}

class MetadataSubmissionsCompanion extends UpdateCompanion<MetadataSubmission> {
  final Value<String> id;
  final Value<DateTime?> lastModifiedDate;
  final Value<DateTime?> createdDate;
  final Value<MetadataResourceType> resourceType;
  final Value<String> metadataSchema;
  final Value<int> serialNumber;
  final Value<int> version;
  final Value<String> resourceId;
  final Value<Map<String, dynamic>?> formData;
  final Value<String?> createdBy;
  final Value<String?> lastModifiedBy;
  final Value<int> rowid;
  const MetadataSubmissionsCompanion({
    this.id = const Value.absent(),
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.resourceType = const Value.absent(),
    this.metadataSchema = const Value.absent(),
    this.serialNumber = const Value.absent(),
    this.version = const Value.absent(),
    this.resourceId = const Value.absent(),
    this.formData = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.lastModifiedBy = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  MetadataSubmissionsCompanion.insert({
    required String id,
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    required MetadataResourceType resourceType,
    required String metadataSchema,
    required int serialNumber,
    required int version,
    required String resourceId,
    this.formData = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.lastModifiedBy = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        resourceType = Value(resourceType),
        metadataSchema = Value(metadataSchema),
        serialNumber = Value(serialNumber),
        version = Value(version),
        resourceId = Value(resourceId);
  static Insertable<MetadataSubmission> custom({
    Expression<String>? id,
    Expression<DateTime>? lastModifiedDate,
    Expression<DateTime>? createdDate,
    Expression<String>? resourceType,
    Expression<String>? metadataSchema,
    Expression<int>? serialNumber,
    Expression<int>? version,
    Expression<String>? resourceId,
    Expression<String>? formData,
    Expression<String>? createdBy,
    Expression<String>? lastModifiedBy,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (lastModifiedDate != null) 'last_modified_date': lastModifiedDate,
      if (createdDate != null) 'created_date': createdDate,
      if (resourceType != null) 'resource_type': resourceType,
      if (metadataSchema != null) 'metadata_schema': metadataSchema,
      if (serialNumber != null) 'serial_number': serialNumber,
      if (version != null) 'version': version,
      if (resourceId != null) 'resource_id': resourceId,
      if (formData != null) 'form_data': formData,
      if (createdBy != null) 'created_by': createdBy,
      if (lastModifiedBy != null) 'last_modified_by': lastModifiedBy,
      if (rowid != null) 'rowid': rowid,
    });
  }

  MetadataSubmissionsCompanion copyWith(
      {Value<String>? id,
      Value<DateTime?>? lastModifiedDate,
      Value<DateTime?>? createdDate,
      Value<MetadataResourceType>? resourceType,
      Value<String>? metadataSchema,
      Value<int>? serialNumber,
      Value<int>? version,
      Value<String>? resourceId,
      Value<Map<String, dynamic>?>? formData,
      Value<String?>? createdBy,
      Value<String?>? lastModifiedBy,
      Value<int>? rowid}) {
    return MetadataSubmissionsCompanion(
      id: id ?? this.id,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      createdDate: createdDate ?? this.createdDate,
      resourceType: resourceType ?? this.resourceType,
      metadataSchema: metadataSchema ?? this.metadataSchema,
      serialNumber: serialNumber ?? this.serialNumber,
      version: version ?? this.version,
      resourceId: resourceId ?? this.resourceId,
      formData: formData ?? this.formData,
      createdBy: createdBy ?? this.createdBy,
      lastModifiedBy: lastModifiedBy ?? this.lastModifiedBy,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (lastModifiedDate.present) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<DateTime>(createdDate.value);
    }
    if (resourceType.present) {
      map['resource_type'] = Variable<String>($MetadataSubmissionsTable
          .$converterresourceType
          .toSql(resourceType.value));
    }
    if (metadataSchema.present) {
      map['metadata_schema'] = Variable<String>(metadataSchema.value);
    }
    if (serialNumber.present) {
      map['serial_number'] = Variable<int>(serialNumber.value);
    }
    if (version.present) {
      map['version'] = Variable<int>(version.value);
    }
    if (resourceId.present) {
      map['resource_id'] = Variable<String>(resourceId.value);
    }
    if (formData.present) {
      map['form_data'] = Variable<String>(
          $MetadataSubmissionsTable.$converterformData.toSql(formData.value));
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (lastModifiedBy.present) {
      map['last_modified_by'] = Variable<String>(lastModifiedBy.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MetadataSubmissionsCompanion(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('resourceType: $resourceType, ')
          ..write('metadataSchema: $metadataSchema, ')
          ..write('serialNumber: $serialNumber, ')
          ..write('version: $version, ')
          ..write('resourceId: $resourceId, ')
          ..write('formData: $formData, ')
          ..write('createdBy: $createdBy, ')
          ..write('lastModifiedBy: $lastModifiedBy, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FormTemplateVersionsTable extends FormTemplateVersions
    with TableInfo<$FormTemplateVersionsTable, FormTemplateVersion> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FormTemplateVersionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _templateMeta =
      const VerificationMeta('template');
  @override
  late final GeneratedColumn<String> template = GeneratedColumn<String>(
      'template', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES form_templates (id)'));
  static const VerificationMeta _versionNumberMeta =
      const VerificationMeta('versionNumber');
  @override
  late final GeneratedColumn<int> versionNumber = GeneratedColumn<int>(
      'version_number', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  late final GeneratedColumnWithTypeConverter<List<Template>, String> fields =
      GeneratedColumn<String>('fields', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<List<Template>>(
              $FormTemplateVersionsTable.$converterfields);
  @override
  late final GeneratedColumnWithTypeConverter<List<Template>, String> sections =
      GeneratedColumn<String>('sections', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<List<Template>>(
              $FormTemplateVersionsTable.$convertersections);
  @override
  List<GeneratedColumn> get $columns =>
      [id, template, versionNumber, fields, sections];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'form_template_versions';
  @override
  VerificationContext validateIntegrity(
      Insertable<FormTemplateVersion> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('template')) {
      context.handle(_templateMeta,
          template.isAcceptableOrUnknown(data['template']!, _templateMeta));
    } else if (isInserting) {
      context.missing(_templateMeta);
    }
    if (data.containsKey('version_number')) {
      context.handle(
          _versionNumberMeta,
          versionNumber.isAcceptableOrUnknown(
              data['version_number']!, _versionNumberMeta));
    } else if (isInserting) {
      context.missing(_versionNumberMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FormTemplateVersion map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FormTemplateVersion(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      template: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}template'])!,
      versionNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}version_number'])!,
      fields: $FormTemplateVersionsTable.$converterfields.fromSql(
          attachedDatabase.typeMapping
              .read(DriftSqlType.string, data['${effectivePrefix}fields'])!),
      sections: $FormTemplateVersionsTable.$convertersections.fromSql(
          attachedDatabase.typeMapping
              .read(DriftSqlType.string, data['${effectivePrefix}sections'])!),
    );
  }

  @override
  $FormTemplateVersionsTable createAlias(String alias) {
    return $FormTemplateVersionsTable(attachedDatabase, alias);
  }

  static TypeConverter<List<Template>, String> $converterfields =
      const TemplateListConverter();
  static TypeConverter<List<Template>, String> $convertersections =
      const TemplateListConverter();
}

class FormTemplateVersion extends DataClass
    implements Insertable<FormTemplateVersion> {
  final String id;
  final String template;
  final int versionNumber;
  final List<Template> fields;
  final List<Template> sections;
  const FormTemplateVersion(
      {required this.id,
      required this.template,
      required this.versionNumber,
      required this.fields,
      required this.sections});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['template'] = Variable<String>(template);
    map['version_number'] = Variable<int>(versionNumber);
    {
      map['fields'] = Variable<String>(
          $FormTemplateVersionsTable.$converterfields.toSql(fields));
    }
    {
      map['sections'] = Variable<String>(
          $FormTemplateVersionsTable.$convertersections.toSql(sections));
    }
    return map;
  }

  FormTemplateVersionsCompanion toCompanion(bool nullToAbsent) {
    return FormTemplateVersionsCompanion(
      id: Value(id),
      template: Value(template),
      versionNumber: Value(versionNumber),
      fields: Value(fields),
      sections: Value(sections),
    );
  }

  factory FormTemplateVersion.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FormTemplateVersion(
      id: serializer.fromJson<String>(json['id']),
      template: serializer.fromJson<String>(json['template']),
      versionNumber: serializer.fromJson<int>(json['versionNumber']),
      fields: serializer.fromJson<List<Template>>(json['fields']),
      sections: serializer.fromJson<List<Template>>(json['sections']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'template': serializer.toJson<String>(template),
      'versionNumber': serializer.toJson<int>(versionNumber),
      'fields': serializer.toJson<List<Template>>(fields),
      'sections': serializer.toJson<List<Template>>(sections),
    };
  }

  FormTemplateVersion copyWith(
          {String? id,
          String? template,
          int? versionNumber,
          List<Template>? fields,
          List<Template>? sections}) =>
      FormTemplateVersion(
        id: id ?? this.id,
        template: template ?? this.template,
        versionNumber: versionNumber ?? this.versionNumber,
        fields: fields ?? this.fields,
        sections: sections ?? this.sections,
      );
  FormTemplateVersion copyWithCompanion(FormTemplateVersionsCompanion data) {
    return FormTemplateVersion(
      id: data.id.present ? data.id.value : this.id,
      template: data.template.present ? data.template.value : this.template,
      versionNumber: data.versionNumber.present
          ? data.versionNumber.value
          : this.versionNumber,
      fields: data.fields.present ? data.fields.value : this.fields,
      sections: data.sections.present ? data.sections.value : this.sections,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FormTemplateVersion(')
          ..write('id: $id, ')
          ..write('template: $template, ')
          ..write('versionNumber: $versionNumber, ')
          ..write('fields: $fields, ')
          ..write('sections: $sections')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, template, versionNumber, fields, sections);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FormTemplateVersion &&
          other.id == this.id &&
          other.template == this.template &&
          other.versionNumber == this.versionNumber &&
          other.fields == this.fields &&
          other.sections == this.sections);
}

class FormTemplateVersionsCompanion
    extends UpdateCompanion<FormTemplateVersion> {
  final Value<String> id;
  final Value<String> template;
  final Value<int> versionNumber;
  final Value<List<Template>> fields;
  final Value<List<Template>> sections;
  final Value<int> rowid;
  const FormTemplateVersionsCompanion({
    this.id = const Value.absent(),
    this.template = const Value.absent(),
    this.versionNumber = const Value.absent(),
    this.fields = const Value.absent(),
    this.sections = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FormTemplateVersionsCompanion.insert({
    required String id,
    required String template,
    required int versionNumber,
    required List<Template> fields,
    required List<Template> sections,
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        template = Value(template),
        versionNumber = Value(versionNumber),
        fields = Value(fields),
        sections = Value(sections);
  static Insertable<FormTemplateVersion> custom({
    Expression<String>? id,
    Expression<String>? template,
    Expression<int>? versionNumber,
    Expression<String>? fields,
    Expression<String>? sections,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (template != null) 'template': template,
      if (versionNumber != null) 'version_number': versionNumber,
      if (fields != null) 'fields': fields,
      if (sections != null) 'sections': sections,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FormTemplateVersionsCompanion copyWith(
      {Value<String>? id,
      Value<String>? template,
      Value<int>? versionNumber,
      Value<List<Template>>? fields,
      Value<List<Template>>? sections,
      Value<int>? rowid}) {
    return FormTemplateVersionsCompanion(
      id: id ?? this.id,
      template: template ?? this.template,
      versionNumber: versionNumber ?? this.versionNumber,
      fields: fields ?? this.fields,
      sections: sections ?? this.sections,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (template.present) {
      map['template'] = Variable<String>(template.value);
    }
    if (versionNumber.present) {
      map['version_number'] = Variable<int>(versionNumber.value);
    }
    if (fields.present) {
      map['fields'] = Variable<String>(
          $FormTemplateVersionsTable.$converterfields.toSql(fields.value));
    }
    if (sections.present) {
      map['sections'] = Variable<String>(
          $FormTemplateVersionsTable.$convertersections.toSql(sections.value));
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FormTemplateVersionsCompanion(')
          ..write('id: $id, ')
          ..write('template: $template, ')
          ..write('versionNumber: $versionNumber, ')
          ..write('fields: $fields, ')
          ..write('sections: $sections, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $StageDefinitionsTable extends StageDefinitions
    with TableInfo<$StageDefinitionsTable, StageDefinition> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StageDefinitionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _stepLabelMeta =
      const VerificationMeta('stepLabel');
  @override
  late final GeneratedColumn<String> stepLabel = GeneratedColumn<String>(
      'step_label', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _openAfterFLowRunMeta =
      const VerificationMeta('openAfterFLowRun');
  @override
  late final GeneratedColumn<bool> openAfterFLowRun = GeneratedColumn<bool>(
      'open_after_f_low_run', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("open_after_f_low_run" IN (0, 1))'));
  static const VerificationMeta _repeatableMeta =
      const VerificationMeta('repeatable');
  @override
  late final GeneratedColumn<bool> repeatable = GeneratedColumn<bool>(
      'repeatable', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("repeatable" IN (0, 1))'));
  static const VerificationMeta _stepOrderMeta =
      const VerificationMeta('stepOrder');
  @override
  late final GeneratedColumn<int> stepOrder = GeneratedColumn<int>(
      'step_order', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _flowTypeMeta =
      const VerificationMeta('flowType');
  @override
  late final GeneratedColumn<String> flowType = GeneratedColumn<String>(
      'flow_type', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES flow_types (id)'));
  static const VerificationMeta _dataTemplateMeta =
      const VerificationMeta('dataTemplate');
  @override
  late final GeneratedColumn<String> dataTemplate = GeneratedColumn<String>(
      'data_template', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES form_templates (id)'));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        name,
        code,
        stepLabel,
        description,
        openAfterFLowRun,
        repeatable,
        stepOrder,
        flowType,
        dataTemplate
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stage_definitions';
  @override
  VerificationContext validateIntegrity(Insertable<StageDefinition> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('step_label')) {
      context.handle(_stepLabelMeta,
          stepLabel.isAcceptableOrUnknown(data['step_label']!, _stepLabelMeta));
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    if (data.containsKey('open_after_f_low_run')) {
      context.handle(
          _openAfterFLowRunMeta,
          openAfterFLowRun.isAcceptableOrUnknown(
              data['open_after_f_low_run']!, _openAfterFLowRunMeta));
    }
    if (data.containsKey('repeatable')) {
      context.handle(
          _repeatableMeta,
          repeatable.isAcceptableOrUnknown(
              data['repeatable']!, _repeatableMeta));
    } else if (isInserting) {
      context.missing(_repeatableMeta);
    }
    if (data.containsKey('step_order')) {
      context.handle(_stepOrderMeta,
          stepOrder.isAcceptableOrUnknown(data['step_order']!, _stepOrderMeta));
    } else if (isInserting) {
      context.missing(_stepOrderMeta);
    }
    if (data.containsKey('flow_type')) {
      context.handle(_flowTypeMeta,
          flowType.isAcceptableOrUnknown(data['flow_type']!, _flowTypeMeta));
    } else if (isInserting) {
      context.missing(_flowTypeMeta);
    }
    if (data.containsKey('data_template')) {
      context.handle(
          _dataTemplateMeta,
          dataTemplate.isAcceptableOrUnknown(
              data['data_template']!, _dataTemplateMeta));
    } else if (isInserting) {
      context.missing(_dataTemplateMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  StageDefinition map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StageDefinition(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      stepLabel: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}step_label']),
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
      openAfterFLowRun: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}open_after_f_low_run']),
      repeatable: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}repeatable'])!,
      stepOrder: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}step_order'])!,
      flowType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}flow_type'])!,
      dataTemplate: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}data_template'])!,
    );
  }

  @override
  $StageDefinitionsTable createAlias(String alias) {
    return $StageDefinitionsTable(attachedDatabase, alias);
  }
}

class StageDefinition extends DataClass implements Insertable<StageDefinition> {
  final String id;
  final String name;
  final String? code;
  final String? stepLabel;
  final String? description;
  final bool? openAfterFLowRun;
  final bool repeatable;
  final int stepOrder;
  final String flowType;
  final String dataTemplate;
  const StageDefinition(
      {required this.id,
      required this.name,
      this.code,
      this.stepLabel,
      this.description,
      this.openAfterFLowRun,
      required this.repeatable,
      required this.stepOrder,
      required this.flowType,
      required this.dataTemplate});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    if (!nullToAbsent || stepLabel != null) {
      map['step_label'] = Variable<String>(stepLabel);
    }
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || openAfterFLowRun != null) {
      map['open_after_f_low_run'] = Variable<bool>(openAfterFLowRun);
    }
    map['repeatable'] = Variable<bool>(repeatable);
    map['step_order'] = Variable<int>(stepOrder);
    map['flow_type'] = Variable<String>(flowType);
    map['data_template'] = Variable<String>(dataTemplate);
    return map;
  }

  StageDefinitionsCompanion toCompanion(bool nullToAbsent) {
    return StageDefinitionsCompanion(
      id: Value(id),
      name: Value(name),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      stepLabel: stepLabel == null && nullToAbsent
          ? const Value.absent()
          : Value(stepLabel),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      openAfterFLowRun: openAfterFLowRun == null && nullToAbsent
          ? const Value.absent()
          : Value(openAfterFLowRun),
      repeatable: Value(repeatable),
      stepOrder: Value(stepOrder),
      flowType: Value(flowType),
      dataTemplate: Value(dataTemplate),
    );
  }

  factory StageDefinition.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StageDefinition(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      code: serializer.fromJson<String?>(json['code']),
      stepLabel: serializer.fromJson<String?>(json['stepLabel']),
      description: serializer.fromJson<String?>(json['description']),
      openAfterFLowRun: serializer.fromJson<bool?>(json['openAfterFLowRun']),
      repeatable: serializer.fromJson<bool>(json['repeatable']),
      stepOrder: serializer.fromJson<int>(json['stepOrder']),
      flowType: serializer.fromJson<String>(json['flowType']),
      dataTemplate: serializer.fromJson<String>(json['dataTemplate']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'code': serializer.toJson<String?>(code),
      'stepLabel': serializer.toJson<String?>(stepLabel),
      'description': serializer.toJson<String?>(description),
      'openAfterFLowRun': serializer.toJson<bool?>(openAfterFLowRun),
      'repeatable': serializer.toJson<bool>(repeatable),
      'stepOrder': serializer.toJson<int>(stepOrder),
      'flowType': serializer.toJson<String>(flowType),
      'dataTemplate': serializer.toJson<String>(dataTemplate),
    };
  }

  StageDefinition copyWith(
          {String? id,
          String? name,
          Value<String?> code = const Value.absent(),
          Value<String?> stepLabel = const Value.absent(),
          Value<String?> description = const Value.absent(),
          Value<bool?> openAfterFLowRun = const Value.absent(),
          bool? repeatable,
          int? stepOrder,
          String? flowType,
          String? dataTemplate}) =>
      StageDefinition(
        id: id ?? this.id,
        name: name ?? this.name,
        code: code.present ? code.value : this.code,
        stepLabel: stepLabel.present ? stepLabel.value : this.stepLabel,
        description: description.present ? description.value : this.description,
        openAfterFLowRun: openAfterFLowRun.present
            ? openAfterFLowRun.value
            : this.openAfterFLowRun,
        repeatable: repeatable ?? this.repeatable,
        stepOrder: stepOrder ?? this.stepOrder,
        flowType: flowType ?? this.flowType,
        dataTemplate: dataTemplate ?? this.dataTemplate,
      );
  StageDefinition copyWithCompanion(StageDefinitionsCompanion data) {
    return StageDefinition(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      code: data.code.present ? data.code.value : this.code,
      stepLabel: data.stepLabel.present ? data.stepLabel.value : this.stepLabel,
      description:
          data.description.present ? data.description.value : this.description,
      openAfterFLowRun: data.openAfterFLowRun.present
          ? data.openAfterFLowRun.value
          : this.openAfterFLowRun,
      repeatable:
          data.repeatable.present ? data.repeatable.value : this.repeatable,
      stepOrder: data.stepOrder.present ? data.stepOrder.value : this.stepOrder,
      flowType: data.flowType.present ? data.flowType.value : this.flowType,
      dataTemplate: data.dataTemplate.present
          ? data.dataTemplate.value
          : this.dataTemplate,
    );
  }

  @override
  String toString() {
    return (StringBuffer('StageDefinition(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('stepLabel: $stepLabel, ')
          ..write('description: $description, ')
          ..write('openAfterFLowRun: $openAfterFLowRun, ')
          ..write('repeatable: $repeatable, ')
          ..write('stepOrder: $stepOrder, ')
          ..write('flowType: $flowType, ')
          ..write('dataTemplate: $dataTemplate')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name, code, stepLabel, description,
      openAfterFLowRun, repeatable, stepOrder, flowType, dataTemplate);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StageDefinition &&
          other.id == this.id &&
          other.name == this.name &&
          other.code == this.code &&
          other.stepLabel == this.stepLabel &&
          other.description == this.description &&
          other.openAfterFLowRun == this.openAfterFLowRun &&
          other.repeatable == this.repeatable &&
          other.stepOrder == this.stepOrder &&
          other.flowType == this.flowType &&
          other.dataTemplate == this.dataTemplate);
}

class StageDefinitionsCompanion extends UpdateCompanion<StageDefinition> {
  final Value<String> id;
  final Value<String> name;
  final Value<String?> code;
  final Value<String?> stepLabel;
  final Value<String?> description;
  final Value<bool?> openAfterFLowRun;
  final Value<bool> repeatable;
  final Value<int> stepOrder;
  final Value<String> flowType;
  final Value<String> dataTemplate;
  final Value<int> rowid;
  const StageDefinitionsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.code = const Value.absent(),
    this.stepLabel = const Value.absent(),
    this.description = const Value.absent(),
    this.openAfterFLowRun = const Value.absent(),
    this.repeatable = const Value.absent(),
    this.stepOrder = const Value.absent(),
    this.flowType = const Value.absent(),
    this.dataTemplate = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  StageDefinitionsCompanion.insert({
    required String id,
    required String name,
    this.code = const Value.absent(),
    this.stepLabel = const Value.absent(),
    this.description = const Value.absent(),
    this.openAfterFLowRun = const Value.absent(),
    required bool repeatable,
    required int stepOrder,
    required String flowType,
    required String dataTemplate,
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        name = Value(name),
        repeatable = Value(repeatable),
        stepOrder = Value(stepOrder),
        flowType = Value(flowType),
        dataTemplate = Value(dataTemplate);
  static Insertable<StageDefinition> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? code,
    Expression<String>? stepLabel,
    Expression<String>? description,
    Expression<bool>? openAfterFLowRun,
    Expression<bool>? repeatable,
    Expression<int>? stepOrder,
    Expression<String>? flowType,
    Expression<String>? dataTemplate,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (code != null) 'code': code,
      if (stepLabel != null) 'step_label': stepLabel,
      if (description != null) 'description': description,
      if (openAfterFLowRun != null) 'open_after_f_low_run': openAfterFLowRun,
      if (repeatable != null) 'repeatable': repeatable,
      if (stepOrder != null) 'step_order': stepOrder,
      if (flowType != null) 'flow_type': flowType,
      if (dataTemplate != null) 'data_template': dataTemplate,
      if (rowid != null) 'rowid': rowid,
    });
  }

  StageDefinitionsCompanion copyWith(
      {Value<String>? id,
      Value<String>? name,
      Value<String?>? code,
      Value<String?>? stepLabel,
      Value<String?>? description,
      Value<bool?>? openAfterFLowRun,
      Value<bool>? repeatable,
      Value<int>? stepOrder,
      Value<String>? flowType,
      Value<String>? dataTemplate,
      Value<int>? rowid}) {
    return StageDefinitionsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      code: code ?? this.code,
      stepLabel: stepLabel ?? this.stepLabel,
      description: description ?? this.description,
      openAfterFLowRun: openAfterFLowRun ?? this.openAfterFLowRun,
      repeatable: repeatable ?? this.repeatable,
      stepOrder: stepOrder ?? this.stepOrder,
      flowType: flowType ?? this.flowType,
      dataTemplate: dataTemplate ?? this.dataTemplate,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (stepLabel.present) {
      map['step_label'] = Variable<String>(stepLabel.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (openAfterFLowRun.present) {
      map['open_after_f_low_run'] = Variable<bool>(openAfterFLowRun.value);
    }
    if (repeatable.present) {
      map['repeatable'] = Variable<bool>(repeatable.value);
    }
    if (stepOrder.present) {
      map['step_order'] = Variable<int>(stepOrder.value);
    }
    if (flowType.present) {
      map['flow_type'] = Variable<String>(flowType.value);
    }
    if (dataTemplate.present) {
      map['data_template'] = Variable<String>(dataTemplate.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StageDefinitionsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('stepLabel: $stepLabel, ')
          ..write('description: $description, ')
          ..write('openAfterFLowRun: $openAfterFLowRun, ')
          ..write('repeatable: $repeatable, ')
          ..write('stepOrder: $stepOrder, ')
          ..write('flowType: $flowType, ')
          ..write('dataTemplate: $dataTemplate, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $DataSubmissionsTable extends DataSubmissions
    with TableInfo<$DataSubmissionsTable, DataSubmission> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DataSubmissionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _lastModifiedDateMeta =
      const VerificationMeta('lastModifiedDate');
  @override
  late final GeneratedColumn<DateTime> lastModifiedDate =
      GeneratedColumn<DateTime>('last_modified_date', aliasedName, true,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<DateTime> createdDate = GeneratedColumn<DateTime>(
      'created_date', aliasedName, true,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _deletedMeta =
      const VerificationMeta('deleted');
  @override
  late final GeneratedColumn<bool> deleted = GeneratedColumn<bool>(
      'deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("deleted" IN (0, 1))'),
      clientDefault: () => false);
  static const VerificationMeta _deletedAtMeta =
      const VerificationMeta('deletedAt');
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
      'deleted_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _dataTemplateMeta =
      const VerificationMeta('dataTemplate');
  @override
  late final GeneratedColumn<String> dataTemplate = GeneratedColumn<String>(
      'data_template', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES form_templates (id)'));
  static const VerificationMeta _dataTemplateVerMeta =
      const VerificationMeta('dataTemplateVer');
  @override
  late final GeneratedColumn<String> dataTemplateVer = GeneratedColumn<String>(
      'data_template_ver', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES form_template_versions (id)'));
  static const VerificationMeta _flowInstanceMeta =
      const VerificationMeta('flowInstance');
  @override
  late final GeneratedColumn<String> flowInstance = GeneratedColumn<String>(
      'flow_instance', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES flow_instances (id)'));
  static const VerificationMeta _flowTypeMeta =
      const VerificationMeta('flowType');
  @override
  late final GeneratedColumn<String> flowType = GeneratedColumn<String>(
      'flow_type', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES flow_types (id)'));
  static const VerificationMeta _teamMeta = const VerificationMeta('team');
  @override
  late final GeneratedColumn<String> team = GeneratedColumn<String>(
      'team', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES teams (id)'));
  static const VerificationMeta _orgUnitMeta =
      const VerificationMeta('orgUnit');
  @override
  late final GeneratedColumn<String> orgUnit = GeneratedColumn<String>(
      'org_unit', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES org_units (id)'));
  static const VerificationMeta _stageDefinitionMeta =
      const VerificationMeta('stageDefinition');
  @override
  late final GeneratedColumn<String> stageDefinition = GeneratedColumn<String>(
      'stage_definition', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES stage_definitions (id)'));
  static const VerificationMeta _entityInstanceMeta =
      const VerificationMeta('entityInstance');
  @override
  late final GeneratedColumn<String> entityInstance = GeneratedColumn<String>(
      'entity_instance', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES entity_instances (id)'));
  static const VerificationMeta _startEntryTimeMeta =
      const VerificationMeta('startEntryTime');
  @override
  late final GeneratedColumn<DateTime> startEntryTime =
      GeneratedColumn<DateTime>('start_entry_time', aliasedName, false,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _finishedEntryTimeMeta =
      const VerificationMeta('finishedEntryTime');
  @override
  late final GeneratedColumn<DateTime> finishedEntryTime =
      GeneratedColumn<DateTime>('finished_entry_time', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
      formData = GeneratedColumn<String>('form_data', aliasedName, true,
              type: DriftSqlType.string, requiredDuringInsert: false)
          .withConverter<Map<String, dynamic>?>(
              $DataSubmissionsTable.$converterformData);
  static const VerificationMeta _updatedAtClientMeta =
      const VerificationMeta('updatedAtClient');
  @override
  late final GeneratedColumn<DateTime> updatedAtClient =
      GeneratedColumn<DateTime>('updated_at_client', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<InstanceSyncStatus, String>
      syncState = GeneratedColumn<String>('sync_state', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<InstanceSyncStatus>(
              $DataSubmissionsTable.$convertersyncState);
  static const VerificationMeta _lastSyncDateMeta =
      const VerificationMeta('lastSyncDate');
  @override
  late final GeneratedColumn<DateTime> lastSyncDate = GeneratedColumn<DateTime>(
      'last_sync_date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _lastSyncMessageMeta =
      const VerificationMeta('lastSyncMessage');
  @override
  late final GeneratedColumn<String> lastSyncMessage = GeneratedColumn<String>(
      'last_sync_message', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isToUpdateMeta =
      const VerificationMeta('isToUpdate');
  @override
  late final GeneratedColumn<bool> isToUpdate = GeneratedColumn<bool>(
      'is_to_update', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_to_update" IN (0, 1))'));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        lastModifiedDate,
        createdDate,
        deleted,
        deletedAt,
        dataTemplate,
        dataTemplateVer,
        flowInstance,
        flowType,
        team,
        orgUnit,
        stageDefinition,
        entityInstance,
        startEntryTime,
        finishedEntryTime,
        formData,
        updatedAtClient,
        syncState,
        lastSyncDate,
        lastSyncMessage,
        isToUpdate
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'data_submissions';
  @override
  VerificationContext validateIntegrity(Insertable<DataSubmission> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('last_modified_date')) {
      context.handle(
          _lastModifiedDateMeta,
          lastModifiedDate.isAcceptableOrUnknown(
              data['last_modified_date']!, _lastModifiedDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('deleted')) {
      context.handle(_deletedMeta,
          deleted.isAcceptableOrUnknown(data['deleted']!, _deletedMeta));
    }
    if (data.containsKey('deleted_at')) {
      context.handle(_deletedAtMeta,
          deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta));
    }
    if (data.containsKey('data_template')) {
      context.handle(
          _dataTemplateMeta,
          dataTemplate.isAcceptableOrUnknown(
              data['data_template']!, _dataTemplateMeta));
    } else if (isInserting) {
      context.missing(_dataTemplateMeta);
    }
    if (data.containsKey('data_template_ver')) {
      context.handle(
          _dataTemplateVerMeta,
          dataTemplateVer.isAcceptableOrUnknown(
              data['data_template_ver']!, _dataTemplateVerMeta));
    } else if (isInserting) {
      context.missing(_dataTemplateVerMeta);
    }
    if (data.containsKey('flow_instance')) {
      context.handle(
          _flowInstanceMeta,
          flowInstance.isAcceptableOrUnknown(
              data['flow_instance']!, _flowInstanceMeta));
    }
    if (data.containsKey('flow_type')) {
      context.handle(_flowTypeMeta,
          flowType.isAcceptableOrUnknown(data['flow_type']!, _flowTypeMeta));
    } else if (isInserting) {
      context.missing(_flowTypeMeta);
    }
    if (data.containsKey('team')) {
      context.handle(
          _teamMeta, team.isAcceptableOrUnknown(data['team']!, _teamMeta));
    }
    if (data.containsKey('org_unit')) {
      context.handle(_orgUnitMeta,
          orgUnit.isAcceptableOrUnknown(data['org_unit']!, _orgUnitMeta));
    }
    if (data.containsKey('stage_definition')) {
      context.handle(
          _stageDefinitionMeta,
          stageDefinition.isAcceptableOrUnknown(
              data['stage_definition']!, _stageDefinitionMeta));
    }
    if (data.containsKey('entity_instance')) {
      context.handle(
          _entityInstanceMeta,
          entityInstance.isAcceptableOrUnknown(
              data['entity_instance']!, _entityInstanceMeta));
    }
    if (data.containsKey('start_entry_time')) {
      context.handle(
          _startEntryTimeMeta,
          startEntryTime.isAcceptableOrUnknown(
              data['start_entry_time']!, _startEntryTimeMeta));
    }
    if (data.containsKey('finished_entry_time')) {
      context.handle(
          _finishedEntryTimeMeta,
          finishedEntryTime.isAcceptableOrUnknown(
              data['finished_entry_time']!, _finishedEntryTimeMeta));
    }
    if (data.containsKey('updated_at_client')) {
      context.handle(
          _updatedAtClientMeta,
          updatedAtClient.isAcceptableOrUnknown(
              data['updated_at_client']!, _updatedAtClientMeta));
    }
    if (data.containsKey('last_sync_date')) {
      context.handle(
          _lastSyncDateMeta,
          lastSyncDate.isAcceptableOrUnknown(
              data['last_sync_date']!, _lastSyncDateMeta));
    }
    if (data.containsKey('last_sync_message')) {
      context.handle(
          _lastSyncMessageMeta,
          lastSyncMessage.isAcceptableOrUnknown(
              data['last_sync_message']!, _lastSyncMessageMeta));
    }
    if (data.containsKey('is_to_update')) {
      context.handle(
          _isToUpdateMeta,
          isToUpdate.isAcceptableOrUnknown(
              data['is_to_update']!, _isToUpdateMeta));
    } else if (isInserting) {
      context.missing(_isToUpdateMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  DataSubmission map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DataSubmission(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      lastModifiedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_modified_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_date']),
      deleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}deleted'])!,
      deletedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}deleted_at']),
      dataTemplate: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}data_template'])!,
      dataTemplateVer: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}data_template_ver'])!,
      flowInstance: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}flow_instance']),
      flowType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}flow_type'])!,
      team: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}team']),
      orgUnit: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}org_unit']),
      stageDefinition: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}stage_definition']),
      entityInstance: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}entity_instance']),
      startEntryTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}start_entry_time'])!,
      finishedEntryTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}finished_entry_time']),
      formData: $DataSubmissionsTable.$converterformData.fromSql(
          attachedDatabase.typeMapping
              .read(DriftSqlType.string, data['${effectivePrefix}form_data'])),
      updatedAtClient: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}updated_at_client']),
      syncState: $DataSubmissionsTable.$convertersyncState.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}sync_state'])!),
      lastSyncDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_sync_date']),
      lastSyncMessage: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}last_sync_message']),
      isToUpdate: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_to_update'])!,
    );
  }

  @override
  $DataSubmissionsTable createAlias(String alias) {
    return $DataSubmissionsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>?, String?> $converterformData =
      const NullAwareMapConverter();
  static JsonTypeConverter2<InstanceSyncStatus, String, String>
      $convertersyncState = const EnumNameConverter(InstanceSyncStatus.values);
}

class DataSubmission extends DataClass implements Insertable<DataSubmission> {
  final String id;
  final DateTime? lastModifiedDate;
  final DateTime? createdDate;
  final bool deleted;
  final DateTime? deletedAt;

  /// analogous to program
  final String dataTemplate;
  final String dataTemplateVer;

  /// analogous to enrollment
  final String? flowInstance;
  final String flowType;

  /// who
  final String? team;

  /// where
  final String? orgUnit;
  final String? stageDefinition;

  /// referencing what, (In case of entity bound submissions or null
  final String? entityInstance;
  final DateTime startEntryTime;
  final DateTime? finishedEntryTime;
  final Map<String, dynamic>? formData;
  final DateTime? updatedAtClient;
  final InstanceSyncStatus syncState;
  final DateTime? lastSyncDate;
  final String? lastSyncMessage;

  /// is already synced to server
  final bool isToUpdate;
  const DataSubmission(
      {required this.id,
      this.lastModifiedDate,
      this.createdDate,
      required this.deleted,
      this.deletedAt,
      required this.dataTemplate,
      required this.dataTemplateVer,
      this.flowInstance,
      required this.flowType,
      this.team,
      this.orgUnit,
      this.stageDefinition,
      this.entityInstance,
      required this.startEntryTime,
      this.finishedEntryTime,
      this.formData,
      this.updatedAtClient,
      required this.syncState,
      this.lastSyncDate,
      this.lastSyncMessage,
      required this.isToUpdate});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || lastModifiedDate != null) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<DateTime>(createdDate);
    }
    map['deleted'] = Variable<bool>(deleted);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    map['data_template'] = Variable<String>(dataTemplate);
    map['data_template_ver'] = Variable<String>(dataTemplateVer);
    if (!nullToAbsent || flowInstance != null) {
      map['flow_instance'] = Variable<String>(flowInstance);
    }
    map['flow_type'] = Variable<String>(flowType);
    if (!nullToAbsent || team != null) {
      map['team'] = Variable<String>(team);
    }
    if (!nullToAbsent || orgUnit != null) {
      map['org_unit'] = Variable<String>(orgUnit);
    }
    if (!nullToAbsent || stageDefinition != null) {
      map['stage_definition'] = Variable<String>(stageDefinition);
    }
    if (!nullToAbsent || entityInstance != null) {
      map['entity_instance'] = Variable<String>(entityInstance);
    }
    map['start_entry_time'] = Variable<DateTime>(startEntryTime);
    if (!nullToAbsent || finishedEntryTime != null) {
      map['finished_entry_time'] = Variable<DateTime>(finishedEntryTime);
    }
    if (!nullToAbsent || formData != null) {
      map['form_data'] = Variable<String>(
          $DataSubmissionsTable.$converterformData.toSql(formData));
    }
    if (!nullToAbsent || updatedAtClient != null) {
      map['updated_at_client'] = Variable<DateTime>(updatedAtClient);
    }
    {
      map['sync_state'] = Variable<String>(
          $DataSubmissionsTable.$convertersyncState.toSql(syncState));
    }
    if (!nullToAbsent || lastSyncDate != null) {
      map['last_sync_date'] = Variable<DateTime>(lastSyncDate);
    }
    if (!nullToAbsent || lastSyncMessage != null) {
      map['last_sync_message'] = Variable<String>(lastSyncMessage);
    }
    map['is_to_update'] = Variable<bool>(isToUpdate);
    return map;
  }

  DataSubmissionsCompanion toCompanion(bool nullToAbsent) {
    return DataSubmissionsCompanion(
      id: Value(id),
      lastModifiedDate: lastModifiedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      deleted: Value(deleted),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      dataTemplate: Value(dataTemplate),
      dataTemplateVer: Value(dataTemplateVer),
      flowInstance: flowInstance == null && nullToAbsent
          ? const Value.absent()
          : Value(flowInstance),
      flowType: Value(flowType),
      team: team == null && nullToAbsent ? const Value.absent() : Value(team),
      orgUnit: orgUnit == null && nullToAbsent
          ? const Value.absent()
          : Value(orgUnit),
      stageDefinition: stageDefinition == null && nullToAbsent
          ? const Value.absent()
          : Value(stageDefinition),
      entityInstance: entityInstance == null && nullToAbsent
          ? const Value.absent()
          : Value(entityInstance),
      startEntryTime: Value(startEntryTime),
      finishedEntryTime: finishedEntryTime == null && nullToAbsent
          ? const Value.absent()
          : Value(finishedEntryTime),
      formData: formData == null && nullToAbsent
          ? const Value.absent()
          : Value(formData),
      updatedAtClient: updatedAtClient == null && nullToAbsent
          ? const Value.absent()
          : Value(updatedAtClient),
      syncState: Value(syncState),
      lastSyncDate: lastSyncDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncDate),
      lastSyncMessage: lastSyncMessage == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncMessage),
      isToUpdate: Value(isToUpdate),
    );
  }

  factory DataSubmission.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DataSubmission(
      id: serializer.fromJson<String>(json['id']),
      lastModifiedDate:
          serializer.fromJson<DateTime?>(json['lastModifiedDate']),
      createdDate: serializer.fromJson<DateTime?>(json['createdDate']),
      deleted: serializer.fromJson<bool>(json['deleted']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      dataTemplate: serializer.fromJson<String>(json['dataTemplate']),
      dataTemplateVer: serializer.fromJson<String>(json['dataTemplateVer']),
      flowInstance: serializer.fromJson<String?>(json['flowInstance']),
      flowType: serializer.fromJson<String>(json['flowType']),
      team: serializer.fromJson<String?>(json['team']),
      orgUnit: serializer.fromJson<String?>(json['orgUnit']),
      stageDefinition: serializer.fromJson<String?>(json['stageDefinition']),
      entityInstance: serializer.fromJson<String?>(json['entityInstance']),
      startEntryTime: serializer.fromJson<DateTime>(json['startEntryTime']),
      finishedEntryTime:
          serializer.fromJson<DateTime?>(json['finishedEntryTime']),
      formData: serializer.fromJson<Map<String, dynamic>?>(json['formData']),
      updatedAtClient: serializer.fromJson<DateTime?>(json['updatedAtClient']),
      syncState: $DataSubmissionsTable.$convertersyncState
          .fromJson(serializer.fromJson<String>(json['syncState'])),
      lastSyncDate: serializer.fromJson<DateTime?>(json['lastSyncDate']),
      lastSyncMessage: serializer.fromJson<String?>(json['lastSyncMessage']),
      isToUpdate: serializer.fromJson<bool>(json['isToUpdate']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'lastModifiedDate': serializer.toJson<DateTime?>(lastModifiedDate),
      'createdDate': serializer.toJson<DateTime?>(createdDate),
      'deleted': serializer.toJson<bool>(deleted),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'dataTemplate': serializer.toJson<String>(dataTemplate),
      'dataTemplateVer': serializer.toJson<String>(dataTemplateVer),
      'flowInstance': serializer.toJson<String?>(flowInstance),
      'flowType': serializer.toJson<String>(flowType),
      'team': serializer.toJson<String?>(team),
      'orgUnit': serializer.toJson<String?>(orgUnit),
      'stageDefinition': serializer.toJson<String?>(stageDefinition),
      'entityInstance': serializer.toJson<String?>(entityInstance),
      'startEntryTime': serializer.toJson<DateTime>(startEntryTime),
      'finishedEntryTime': serializer.toJson<DateTime?>(finishedEntryTime),
      'formData': serializer.toJson<Map<String, dynamic>?>(formData),
      'updatedAtClient': serializer.toJson<DateTime?>(updatedAtClient),
      'syncState': serializer.toJson<String>(
          $DataSubmissionsTable.$convertersyncState.toJson(syncState)),
      'lastSyncDate': serializer.toJson<DateTime?>(lastSyncDate),
      'lastSyncMessage': serializer.toJson<String?>(lastSyncMessage),
      'isToUpdate': serializer.toJson<bool>(isToUpdate),
    };
  }

  DataSubmission copyWith(
          {String? id,
          Value<DateTime?> lastModifiedDate = const Value.absent(),
          Value<DateTime?> createdDate = const Value.absent(),
          bool? deleted,
          Value<DateTime?> deletedAt = const Value.absent(),
          String? dataTemplate,
          String? dataTemplateVer,
          Value<String?> flowInstance = const Value.absent(),
          String? flowType,
          Value<String?> team = const Value.absent(),
          Value<String?> orgUnit = const Value.absent(),
          Value<String?> stageDefinition = const Value.absent(),
          Value<String?> entityInstance = const Value.absent(),
          DateTime? startEntryTime,
          Value<DateTime?> finishedEntryTime = const Value.absent(),
          Value<Map<String, dynamic>?> formData = const Value.absent(),
          Value<DateTime?> updatedAtClient = const Value.absent(),
          InstanceSyncStatus? syncState,
          Value<DateTime?> lastSyncDate = const Value.absent(),
          Value<String?> lastSyncMessage = const Value.absent(),
          bool? isToUpdate}) =>
      DataSubmission(
        id: id ?? this.id,
        lastModifiedDate: lastModifiedDate.present
            ? lastModifiedDate.value
            : this.lastModifiedDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        deleted: deleted ?? this.deleted,
        deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
        dataTemplate: dataTemplate ?? this.dataTemplate,
        dataTemplateVer: dataTemplateVer ?? this.dataTemplateVer,
        flowInstance:
            flowInstance.present ? flowInstance.value : this.flowInstance,
        flowType: flowType ?? this.flowType,
        team: team.present ? team.value : this.team,
        orgUnit: orgUnit.present ? orgUnit.value : this.orgUnit,
        stageDefinition: stageDefinition.present
            ? stageDefinition.value
            : this.stageDefinition,
        entityInstance:
            entityInstance.present ? entityInstance.value : this.entityInstance,
        startEntryTime: startEntryTime ?? this.startEntryTime,
        finishedEntryTime: finishedEntryTime.present
            ? finishedEntryTime.value
            : this.finishedEntryTime,
        formData: formData.present ? formData.value : this.formData,
        updatedAtClient: updatedAtClient.present
            ? updatedAtClient.value
            : this.updatedAtClient,
        syncState: syncState ?? this.syncState,
        lastSyncDate:
            lastSyncDate.present ? lastSyncDate.value : this.lastSyncDate,
        lastSyncMessage: lastSyncMessage.present
            ? lastSyncMessage.value
            : this.lastSyncMessage,
        isToUpdate: isToUpdate ?? this.isToUpdate,
      );
  DataSubmission copyWithCompanion(DataSubmissionsCompanion data) {
    return DataSubmission(
      id: data.id.present ? data.id.value : this.id,
      lastModifiedDate: data.lastModifiedDate.present
          ? data.lastModifiedDate.value
          : this.lastModifiedDate,
      createdDate:
          data.createdDate.present ? data.createdDate.value : this.createdDate,
      deleted: data.deleted.present ? data.deleted.value : this.deleted,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      dataTemplate: data.dataTemplate.present
          ? data.dataTemplate.value
          : this.dataTemplate,
      dataTemplateVer: data.dataTemplateVer.present
          ? data.dataTemplateVer.value
          : this.dataTemplateVer,
      flowInstance: data.flowInstance.present
          ? data.flowInstance.value
          : this.flowInstance,
      flowType: data.flowType.present ? data.flowType.value : this.flowType,
      team: data.team.present ? data.team.value : this.team,
      orgUnit: data.orgUnit.present ? data.orgUnit.value : this.orgUnit,
      stageDefinition: data.stageDefinition.present
          ? data.stageDefinition.value
          : this.stageDefinition,
      entityInstance: data.entityInstance.present
          ? data.entityInstance.value
          : this.entityInstance,
      startEntryTime: data.startEntryTime.present
          ? data.startEntryTime.value
          : this.startEntryTime,
      finishedEntryTime: data.finishedEntryTime.present
          ? data.finishedEntryTime.value
          : this.finishedEntryTime,
      formData: data.formData.present ? data.formData.value : this.formData,
      updatedAtClient: data.updatedAtClient.present
          ? data.updatedAtClient.value
          : this.updatedAtClient,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
      lastSyncDate: data.lastSyncDate.present
          ? data.lastSyncDate.value
          : this.lastSyncDate,
      lastSyncMessage: data.lastSyncMessage.present
          ? data.lastSyncMessage.value
          : this.lastSyncMessage,
      isToUpdate:
          data.isToUpdate.present ? data.isToUpdate.value : this.isToUpdate,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DataSubmission(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('deleted: $deleted, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('dataTemplate: $dataTemplate, ')
          ..write('dataTemplateVer: $dataTemplateVer, ')
          ..write('flowInstance: $flowInstance, ')
          ..write('flowType: $flowType, ')
          ..write('team: $team, ')
          ..write('orgUnit: $orgUnit, ')
          ..write('stageDefinition: $stageDefinition, ')
          ..write('entityInstance: $entityInstance, ')
          ..write('startEntryTime: $startEntryTime, ')
          ..write('finishedEntryTime: $finishedEntryTime, ')
          ..write('formData: $formData, ')
          ..write('updatedAtClient: $updatedAtClient, ')
          ..write('syncState: $syncState, ')
          ..write('lastSyncDate: $lastSyncDate, ')
          ..write('lastSyncMessage: $lastSyncMessage, ')
          ..write('isToUpdate: $isToUpdate')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        lastModifiedDate,
        createdDate,
        deleted,
        deletedAt,
        dataTemplate,
        dataTemplateVer,
        flowInstance,
        flowType,
        team,
        orgUnit,
        stageDefinition,
        entityInstance,
        startEntryTime,
        finishedEntryTime,
        formData,
        updatedAtClient,
        syncState,
        lastSyncDate,
        lastSyncMessage,
        isToUpdate
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DataSubmission &&
          other.id == this.id &&
          other.lastModifiedDate == this.lastModifiedDate &&
          other.createdDate == this.createdDate &&
          other.deleted == this.deleted &&
          other.deletedAt == this.deletedAt &&
          other.dataTemplate == this.dataTemplate &&
          other.dataTemplateVer == this.dataTemplateVer &&
          other.flowInstance == this.flowInstance &&
          other.flowType == this.flowType &&
          other.team == this.team &&
          other.orgUnit == this.orgUnit &&
          other.stageDefinition == this.stageDefinition &&
          other.entityInstance == this.entityInstance &&
          other.startEntryTime == this.startEntryTime &&
          other.finishedEntryTime == this.finishedEntryTime &&
          other.formData == this.formData &&
          other.updatedAtClient == this.updatedAtClient &&
          other.syncState == this.syncState &&
          other.lastSyncDate == this.lastSyncDate &&
          other.lastSyncMessage == this.lastSyncMessage &&
          other.isToUpdate == this.isToUpdate);
}

class DataSubmissionsCompanion extends UpdateCompanion<DataSubmission> {
  final Value<String> id;
  final Value<DateTime?> lastModifiedDate;
  final Value<DateTime?> createdDate;
  final Value<bool> deleted;
  final Value<DateTime?> deletedAt;
  final Value<String> dataTemplate;
  final Value<String> dataTemplateVer;
  final Value<String?> flowInstance;
  final Value<String> flowType;
  final Value<String?> team;
  final Value<String?> orgUnit;
  final Value<String?> stageDefinition;
  final Value<String?> entityInstance;
  final Value<DateTime> startEntryTime;
  final Value<DateTime?> finishedEntryTime;
  final Value<Map<String, dynamic>?> formData;
  final Value<DateTime?> updatedAtClient;
  final Value<InstanceSyncStatus> syncState;
  final Value<DateTime?> lastSyncDate;
  final Value<String?> lastSyncMessage;
  final Value<bool> isToUpdate;
  final Value<int> rowid;
  const DataSubmissionsCompanion({
    this.id = const Value.absent(),
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.deleted = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.dataTemplate = const Value.absent(),
    this.dataTemplateVer = const Value.absent(),
    this.flowInstance = const Value.absent(),
    this.flowType = const Value.absent(),
    this.team = const Value.absent(),
    this.orgUnit = const Value.absent(),
    this.stageDefinition = const Value.absent(),
    this.entityInstance = const Value.absent(),
    this.startEntryTime = const Value.absent(),
    this.finishedEntryTime = const Value.absent(),
    this.formData = const Value.absent(),
    this.updatedAtClient = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lastSyncDate = const Value.absent(),
    this.lastSyncMessage = const Value.absent(),
    this.isToUpdate = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  DataSubmissionsCompanion.insert({
    required String id,
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.deleted = const Value.absent(),
    this.deletedAt = const Value.absent(),
    required String dataTemplate,
    required String dataTemplateVer,
    this.flowInstance = const Value.absent(),
    required String flowType,
    this.team = const Value.absent(),
    this.orgUnit = const Value.absent(),
    this.stageDefinition = const Value.absent(),
    this.entityInstance = const Value.absent(),
    this.startEntryTime = const Value.absent(),
    this.finishedEntryTime = const Value.absent(),
    this.formData = const Value.absent(),
    this.updatedAtClient = const Value.absent(),
    required InstanceSyncStatus syncState,
    this.lastSyncDate = const Value.absent(),
    this.lastSyncMessage = const Value.absent(),
    required bool isToUpdate,
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        dataTemplate = Value(dataTemplate),
        dataTemplateVer = Value(dataTemplateVer),
        flowType = Value(flowType),
        syncState = Value(syncState),
        isToUpdate = Value(isToUpdate);
  static Insertable<DataSubmission> custom({
    Expression<String>? id,
    Expression<DateTime>? lastModifiedDate,
    Expression<DateTime>? createdDate,
    Expression<bool>? deleted,
    Expression<DateTime>? deletedAt,
    Expression<String>? dataTemplate,
    Expression<String>? dataTemplateVer,
    Expression<String>? flowInstance,
    Expression<String>? flowType,
    Expression<String>? team,
    Expression<String>? orgUnit,
    Expression<String>? stageDefinition,
    Expression<String>? entityInstance,
    Expression<DateTime>? startEntryTime,
    Expression<DateTime>? finishedEntryTime,
    Expression<String>? formData,
    Expression<DateTime>? updatedAtClient,
    Expression<String>? syncState,
    Expression<DateTime>? lastSyncDate,
    Expression<String>? lastSyncMessage,
    Expression<bool>? isToUpdate,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (lastModifiedDate != null) 'last_modified_date': lastModifiedDate,
      if (createdDate != null) 'created_date': createdDate,
      if (deleted != null) 'deleted': deleted,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (dataTemplate != null) 'data_template': dataTemplate,
      if (dataTemplateVer != null) 'data_template_ver': dataTemplateVer,
      if (flowInstance != null) 'flow_instance': flowInstance,
      if (flowType != null) 'flow_type': flowType,
      if (team != null) 'team': team,
      if (orgUnit != null) 'org_unit': orgUnit,
      if (stageDefinition != null) 'stage_definition': stageDefinition,
      if (entityInstance != null) 'entity_instance': entityInstance,
      if (startEntryTime != null) 'start_entry_time': startEntryTime,
      if (finishedEntryTime != null) 'finished_entry_time': finishedEntryTime,
      if (formData != null) 'form_data': formData,
      if (updatedAtClient != null) 'updated_at_client': updatedAtClient,
      if (syncState != null) 'sync_state': syncState,
      if (lastSyncDate != null) 'last_sync_date': lastSyncDate,
      if (lastSyncMessage != null) 'last_sync_message': lastSyncMessage,
      if (isToUpdate != null) 'is_to_update': isToUpdate,
      if (rowid != null) 'rowid': rowid,
    });
  }

  DataSubmissionsCompanion copyWith(
      {Value<String>? id,
      Value<DateTime?>? lastModifiedDate,
      Value<DateTime?>? createdDate,
      Value<bool>? deleted,
      Value<DateTime?>? deletedAt,
      Value<String>? dataTemplate,
      Value<String>? dataTemplateVer,
      Value<String?>? flowInstance,
      Value<String>? flowType,
      Value<String?>? team,
      Value<String?>? orgUnit,
      Value<String?>? stageDefinition,
      Value<String?>? entityInstance,
      Value<DateTime>? startEntryTime,
      Value<DateTime?>? finishedEntryTime,
      Value<Map<String, dynamic>?>? formData,
      Value<DateTime?>? updatedAtClient,
      Value<InstanceSyncStatus>? syncState,
      Value<DateTime?>? lastSyncDate,
      Value<String?>? lastSyncMessage,
      Value<bool>? isToUpdate,
      Value<int>? rowid}) {
    return DataSubmissionsCompanion(
      id: id ?? this.id,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      createdDate: createdDate ?? this.createdDate,
      deleted: deleted ?? this.deleted,
      deletedAt: deletedAt ?? this.deletedAt,
      dataTemplate: dataTemplate ?? this.dataTemplate,
      dataTemplateVer: dataTemplateVer ?? this.dataTemplateVer,
      flowInstance: flowInstance ?? this.flowInstance,
      flowType: flowType ?? this.flowType,
      team: team ?? this.team,
      orgUnit: orgUnit ?? this.orgUnit,
      stageDefinition: stageDefinition ?? this.stageDefinition,
      entityInstance: entityInstance ?? this.entityInstance,
      startEntryTime: startEntryTime ?? this.startEntryTime,
      finishedEntryTime: finishedEntryTime ?? this.finishedEntryTime,
      formData: formData ?? this.formData,
      updatedAtClient: updatedAtClient ?? this.updatedAtClient,
      syncState: syncState ?? this.syncState,
      lastSyncDate: lastSyncDate ?? this.lastSyncDate,
      lastSyncMessage: lastSyncMessage ?? this.lastSyncMessage,
      isToUpdate: isToUpdate ?? this.isToUpdate,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (lastModifiedDate.present) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<DateTime>(createdDate.value);
    }
    if (deleted.present) {
      map['deleted'] = Variable<bool>(deleted.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (dataTemplate.present) {
      map['data_template'] = Variable<String>(dataTemplate.value);
    }
    if (dataTemplateVer.present) {
      map['data_template_ver'] = Variable<String>(dataTemplateVer.value);
    }
    if (flowInstance.present) {
      map['flow_instance'] = Variable<String>(flowInstance.value);
    }
    if (flowType.present) {
      map['flow_type'] = Variable<String>(flowType.value);
    }
    if (team.present) {
      map['team'] = Variable<String>(team.value);
    }
    if (orgUnit.present) {
      map['org_unit'] = Variable<String>(orgUnit.value);
    }
    if (stageDefinition.present) {
      map['stage_definition'] = Variable<String>(stageDefinition.value);
    }
    if (entityInstance.present) {
      map['entity_instance'] = Variable<String>(entityInstance.value);
    }
    if (startEntryTime.present) {
      map['start_entry_time'] = Variable<DateTime>(startEntryTime.value);
    }
    if (finishedEntryTime.present) {
      map['finished_entry_time'] = Variable<DateTime>(finishedEntryTime.value);
    }
    if (formData.present) {
      map['form_data'] = Variable<String>(
          $DataSubmissionsTable.$converterformData.toSql(formData.value));
    }
    if (updatedAtClient.present) {
      map['updated_at_client'] = Variable<DateTime>(updatedAtClient.value);
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(
          $DataSubmissionsTable.$convertersyncState.toSql(syncState.value));
    }
    if (lastSyncDate.present) {
      map['last_sync_date'] = Variable<DateTime>(lastSyncDate.value);
    }
    if (lastSyncMessage.present) {
      map['last_sync_message'] = Variable<String>(lastSyncMessage.value);
    }
    if (isToUpdate.present) {
      map['is_to_update'] = Variable<bool>(isToUpdate.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DataSubmissionsCompanion(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('deleted: $deleted, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('dataTemplate: $dataTemplate, ')
          ..write('dataTemplateVer: $dataTemplateVer, ')
          ..write('flowInstance: $flowInstance, ')
          ..write('flowType: $flowType, ')
          ..write('team: $team, ')
          ..write('orgUnit: $orgUnit, ')
          ..write('stageDefinition: $stageDefinition, ')
          ..write('entityInstance: $entityInstance, ')
          ..write('startEntryTime: $startEntryTime, ')
          ..write('finishedEntryTime: $finishedEntryTime, ')
          ..write('formData: $formData, ')
          ..write('updatedAtClient: $updatedAtClient, ')
          ..write('syncState: $syncState, ')
          ..write('lastSyncDate: $lastSyncDate, ')
          ..write('lastSyncMessage: $lastSyncMessage, ')
          ..write('isToUpdate: $isToUpdate, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $RepeatInstancesTable extends RepeatInstances
    with TableInfo<$RepeatInstancesTable, RepeatInstance> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RepeatInstancesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _lastModifiedDateMeta =
      const VerificationMeta('lastModifiedDate');
  @override
  late final GeneratedColumn<DateTime> lastModifiedDate =
      GeneratedColumn<DateTime>('last_modified_date', aliasedName, true,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<DateTime> createdDate = GeneratedColumn<DateTime>(
      'created_date', aliasedName, true,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _templatePathMeta =
      const VerificationMeta('templatePath');
  @override
  late final GeneratedColumn<String> templatePath = GeneratedColumn<String>(
      'template_path', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _submissionMeta =
      const VerificationMeta('submission');
  @override
  late final GeneratedColumn<String> submission = GeneratedColumn<String>(
      'submission', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES data_submissions (id)'));
  static const VerificationMeta _parentMeta = const VerificationMeta('parent');
  @override
  late final GeneratedColumn<String> parent = GeneratedColumn<String>(
      'parent', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES repeat_instances (id)'));
  static const VerificationMeta _repeatIndexMeta =
      const VerificationMeta('repeatIndex');
  @override
  late final GeneratedColumn<int> repeatIndex = GeneratedColumn<int>(
      'repeat_index', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        lastModifiedDate,
        createdDate,
        templatePath,
        submission,
        parent,
        repeatIndex
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'repeat_instances';
  @override
  VerificationContext validateIntegrity(Insertable<RepeatInstance> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('last_modified_date')) {
      context.handle(
          _lastModifiedDateMeta,
          lastModifiedDate.isAcceptableOrUnknown(
              data['last_modified_date']!, _lastModifiedDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('template_path')) {
      context.handle(
          _templatePathMeta,
          templatePath.isAcceptableOrUnknown(
              data['template_path']!, _templatePathMeta));
    } else if (isInserting) {
      context.missing(_templatePathMeta);
    }
    if (data.containsKey('submission')) {
      context.handle(
          _submissionMeta,
          submission.isAcceptableOrUnknown(
              data['submission']!, _submissionMeta));
    } else if (isInserting) {
      context.missing(_submissionMeta);
    }
    if (data.containsKey('parent')) {
      context.handle(_parentMeta,
          parent.isAcceptableOrUnknown(data['parent']!, _parentMeta));
    }
    if (data.containsKey('repeat_index')) {
      context.handle(
          _repeatIndexMeta,
          repeatIndex.isAcceptableOrUnknown(
              data['repeat_index']!, _repeatIndexMeta));
    } else if (isInserting) {
      context.missing(_repeatIndexMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  RepeatInstance map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RepeatInstance(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      lastModifiedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_modified_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_date']),
      templatePath: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}template_path'])!,
      submission: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}submission'])!,
      parent: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}parent']),
      repeatIndex: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}repeat_index'])!,
    );
  }

  @override
  $RepeatInstancesTable createAlias(String alias) {
    return $RepeatInstancesTable(attachedDatabase, alias);
  }
}

class RepeatInstance extends DataClass implements Insertable<RepeatInstance> {
  final String id;
  final DateTime? lastModifiedDate;
  final DateTime? createdDate;

  /// Path of the Repeat in the FormTemplate (non-null)
  final String templatePath;
  final String submission;

  /// reference to nearest parent RepeatInstance (nullable)
  final String? parent;

  /// Repeat index for order and identity (non-null)
  final int repeatIndex;
  const RepeatInstance(
      {required this.id,
      this.lastModifiedDate,
      this.createdDate,
      required this.templatePath,
      required this.submission,
      this.parent,
      required this.repeatIndex});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || lastModifiedDate != null) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<DateTime>(createdDate);
    }
    map['template_path'] = Variable<String>(templatePath);
    map['submission'] = Variable<String>(submission);
    if (!nullToAbsent || parent != null) {
      map['parent'] = Variable<String>(parent);
    }
    map['repeat_index'] = Variable<int>(repeatIndex);
    return map;
  }

  RepeatInstancesCompanion toCompanion(bool nullToAbsent) {
    return RepeatInstancesCompanion(
      id: Value(id),
      lastModifiedDate: lastModifiedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      templatePath: Value(templatePath),
      submission: Value(submission),
      parent:
          parent == null && nullToAbsent ? const Value.absent() : Value(parent),
      repeatIndex: Value(repeatIndex),
    );
  }

  factory RepeatInstance.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RepeatInstance(
      id: serializer.fromJson<String>(json['id']),
      lastModifiedDate:
          serializer.fromJson<DateTime?>(json['lastModifiedDate']),
      createdDate: serializer.fromJson<DateTime?>(json['createdDate']),
      templatePath: serializer.fromJson<String>(json['templatePath']),
      submission: serializer.fromJson<String>(json['submission']),
      parent: serializer.fromJson<String?>(json['parent']),
      repeatIndex: serializer.fromJson<int>(json['repeatIndex']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'lastModifiedDate': serializer.toJson<DateTime?>(lastModifiedDate),
      'createdDate': serializer.toJson<DateTime?>(createdDate),
      'templatePath': serializer.toJson<String>(templatePath),
      'submission': serializer.toJson<String>(submission),
      'parent': serializer.toJson<String?>(parent),
      'repeatIndex': serializer.toJson<int>(repeatIndex),
    };
  }

  RepeatInstance copyWith(
          {String? id,
          Value<DateTime?> lastModifiedDate = const Value.absent(),
          Value<DateTime?> createdDate = const Value.absent(),
          String? templatePath,
          String? submission,
          Value<String?> parent = const Value.absent(),
          int? repeatIndex}) =>
      RepeatInstance(
        id: id ?? this.id,
        lastModifiedDate: lastModifiedDate.present
            ? lastModifiedDate.value
            : this.lastModifiedDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        templatePath: templatePath ?? this.templatePath,
        submission: submission ?? this.submission,
        parent: parent.present ? parent.value : this.parent,
        repeatIndex: repeatIndex ?? this.repeatIndex,
      );
  RepeatInstance copyWithCompanion(RepeatInstancesCompanion data) {
    return RepeatInstance(
      id: data.id.present ? data.id.value : this.id,
      lastModifiedDate: data.lastModifiedDate.present
          ? data.lastModifiedDate.value
          : this.lastModifiedDate,
      createdDate:
          data.createdDate.present ? data.createdDate.value : this.createdDate,
      templatePath: data.templatePath.present
          ? data.templatePath.value
          : this.templatePath,
      submission:
          data.submission.present ? data.submission.value : this.submission,
      parent: data.parent.present ? data.parent.value : this.parent,
      repeatIndex:
          data.repeatIndex.present ? data.repeatIndex.value : this.repeatIndex,
    );
  }

  @override
  String toString() {
    return (StringBuffer('RepeatInstance(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('templatePath: $templatePath, ')
          ..write('submission: $submission, ')
          ..write('parent: $parent, ')
          ..write('repeatIndex: $repeatIndex')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, lastModifiedDate, createdDate,
      templatePath, submission, parent, repeatIndex);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RepeatInstance &&
          other.id == this.id &&
          other.lastModifiedDate == this.lastModifiedDate &&
          other.createdDate == this.createdDate &&
          other.templatePath == this.templatePath &&
          other.submission == this.submission &&
          other.parent == this.parent &&
          other.repeatIndex == this.repeatIndex);
}

class RepeatInstancesCompanion extends UpdateCompanion<RepeatInstance> {
  final Value<String> id;
  final Value<DateTime?> lastModifiedDate;
  final Value<DateTime?> createdDate;
  final Value<String> templatePath;
  final Value<String> submission;
  final Value<String?> parent;
  final Value<int> repeatIndex;
  final Value<int> rowid;
  const RepeatInstancesCompanion({
    this.id = const Value.absent(),
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.templatePath = const Value.absent(),
    this.submission = const Value.absent(),
    this.parent = const Value.absent(),
    this.repeatIndex = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  RepeatInstancesCompanion.insert({
    required String id,
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    required String templatePath,
    required String submission,
    this.parent = const Value.absent(),
    required int repeatIndex,
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        templatePath = Value(templatePath),
        submission = Value(submission),
        repeatIndex = Value(repeatIndex);
  static Insertable<RepeatInstance> custom({
    Expression<String>? id,
    Expression<DateTime>? lastModifiedDate,
    Expression<DateTime>? createdDate,
    Expression<String>? templatePath,
    Expression<String>? submission,
    Expression<String>? parent,
    Expression<int>? repeatIndex,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (lastModifiedDate != null) 'last_modified_date': lastModifiedDate,
      if (createdDate != null) 'created_date': createdDate,
      if (templatePath != null) 'template_path': templatePath,
      if (submission != null) 'submission': submission,
      if (parent != null) 'parent': parent,
      if (repeatIndex != null) 'repeat_index': repeatIndex,
      if (rowid != null) 'rowid': rowid,
    });
  }

  RepeatInstancesCompanion copyWith(
      {Value<String>? id,
      Value<DateTime?>? lastModifiedDate,
      Value<DateTime?>? createdDate,
      Value<String>? templatePath,
      Value<String>? submission,
      Value<String?>? parent,
      Value<int>? repeatIndex,
      Value<int>? rowid}) {
    return RepeatInstancesCompanion(
      id: id ?? this.id,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      createdDate: createdDate ?? this.createdDate,
      templatePath: templatePath ?? this.templatePath,
      submission: submission ?? this.submission,
      parent: parent ?? this.parent,
      repeatIndex: repeatIndex ?? this.repeatIndex,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (lastModifiedDate.present) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<DateTime>(createdDate.value);
    }
    if (templatePath.present) {
      map['template_path'] = Variable<String>(templatePath.value);
    }
    if (submission.present) {
      map['submission'] = Variable<String>(submission.value);
    }
    if (parent.present) {
      map['parent'] = Variable<String>(parent.value);
    }
    if (repeatIndex.present) {
      map['repeat_index'] = Variable<int>(repeatIndex.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RepeatInstancesCompanion(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('templatePath: $templatePath, ')
          ..write('submission: $submission, ')
          ..write('parent: $parent, ')
          ..write('repeatIndex: $repeatIndex, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $DataOptionSetsTable extends DataOptionSets
    with TableInfo<$DataOptionSetsTable, DataOptionSet> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DataOptionSetsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _lastModifiedDateMeta =
      const VerificationMeta('lastModifiedDate');
  @override
  late final GeneratedColumn<DateTime> lastModifiedDate =
      GeneratedColumn<DateTime>('last_modified_date', aliasedName, true,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<DateTime> createdDate = GeneratedColumn<DateTime>(
      'created_date', aliasedName, true,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _displayNameMeta =
      const VerificationMeta('displayName');
  @override
  late final GeneratedColumn<String> displayName = GeneratedColumn<String>(
      'display_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
      label = GeneratedColumn<String>('label', aliasedName, true,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '{}')
          .withConverter<Map<String, dynamic>?>(
              $DataOptionSetsTable.$converterlabel);
  @override
  late final GeneratedColumnWithTypeConverter<List<Translation>, String>
      translations = GeneratedColumn<String>('translations', aliasedName, false,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '[]')
          .withConverter<List<Translation>>(
              $DataOptionSetsTable.$convertertranslations);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<List<FormOption>, String>
      options = GeneratedColumn<String>('options', aliasedName, false,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '[]')
          .withConverter<List<FormOption>>(
              $DataOptionSetsTable.$converteroptions);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        lastModifiedDate,
        createdDate,
        displayName,
        label,
        translations,
        name,
        code,
        options
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'data_option_sets';
  @override
  VerificationContext validateIntegrity(Insertable<DataOptionSet> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('last_modified_date')) {
      context.handle(
          _lastModifiedDateMeta,
          lastModifiedDate.isAcceptableOrUnknown(
              data['last_modified_date']!, _lastModifiedDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('display_name')) {
      context.handle(
          _displayNameMeta,
          displayName.isAcceptableOrUnknown(
              data['display_name']!, _displayNameMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  DataOptionSet map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DataOptionSet(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      lastModifiedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_modified_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_date']),
      displayName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}display_name']),
      label: $DataOptionSetsTable.$converterlabel.fromSql(attachedDatabase
          .typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}label'])),
      translations: $DataOptionSetsTable.$convertertranslations.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}translations'])!),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      options: $DataOptionSetsTable.$converteroptions.fromSql(attachedDatabase
          .typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}options'])!),
    );
  }

  @override
  $DataOptionSetsTable createAlias(String alias) {
    return $DataOptionSetsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>?, String?> $converterlabel =
      const NullAwareMapConverter();
  static TypeConverter<List<Translation>, String> $convertertranslations =
      const TranslationConverter();
  static TypeConverter<List<FormOption>, String> $converteroptions =
      const FormOptionListConverter();
}

class DataOptionSet extends DataClass implements Insertable<DataOptionSet> {
  final String id;
  final DateTime? lastModifiedDate;
  final DateTime? createdDate;
  final String? displayName;
  final Map<String, dynamic>? label;
  final List<Translation> translations;
  final String name;
  final String? code;
  final List<FormOption> options;
  const DataOptionSet(
      {required this.id,
      this.lastModifiedDate,
      this.createdDate,
      this.displayName,
      this.label,
      required this.translations,
      required this.name,
      this.code,
      required this.options});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || lastModifiedDate != null) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<DateTime>(createdDate);
    }
    if (!nullToAbsent || displayName != null) {
      map['display_name'] = Variable<String>(displayName);
    }
    if (!nullToAbsent || label != null) {
      map['label'] =
          Variable<String>($DataOptionSetsTable.$converterlabel.toSql(label));
    }
    {
      map['translations'] = Variable<String>(
          $DataOptionSetsTable.$convertertranslations.toSql(translations));
    }
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    {
      map['options'] = Variable<String>(
          $DataOptionSetsTable.$converteroptions.toSql(options));
    }
    return map;
  }

  DataOptionSetsCompanion toCompanion(bool nullToAbsent) {
    return DataOptionSetsCompanion(
      id: Value(id),
      lastModifiedDate: lastModifiedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      displayName: displayName == null && nullToAbsent
          ? const Value.absent()
          : Value(displayName),
      label:
          label == null && nullToAbsent ? const Value.absent() : Value(label),
      translations: Value(translations),
      name: Value(name),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      options: Value(options),
    );
  }

  factory DataOptionSet.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DataOptionSet(
      id: serializer.fromJson<String>(json['id']),
      lastModifiedDate:
          serializer.fromJson<DateTime?>(json['lastModifiedDate']),
      createdDate: serializer.fromJson<DateTime?>(json['createdDate']),
      displayName: serializer.fromJson<String?>(json['displayName']),
      label: serializer.fromJson<Map<String, dynamic>?>(json['label']),
      translations:
          serializer.fromJson<List<Translation>>(json['translations']),
      name: serializer.fromJson<String>(json['name']),
      code: serializer.fromJson<String?>(json['code']),
      options: serializer.fromJson<List<FormOption>>(json['options']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'lastModifiedDate': serializer.toJson<DateTime?>(lastModifiedDate),
      'createdDate': serializer.toJson<DateTime?>(createdDate),
      'displayName': serializer.toJson<String?>(displayName),
      'label': serializer.toJson<Map<String, dynamic>?>(label),
      'translations': serializer.toJson<List<Translation>>(translations),
      'name': serializer.toJson<String>(name),
      'code': serializer.toJson<String?>(code),
      'options': serializer.toJson<List<FormOption>>(options),
    };
  }

  DataOptionSet copyWith(
          {String? id,
          Value<DateTime?> lastModifiedDate = const Value.absent(),
          Value<DateTime?> createdDate = const Value.absent(),
          Value<String?> displayName = const Value.absent(),
          Value<Map<String, dynamic>?> label = const Value.absent(),
          List<Translation>? translations,
          String? name,
          Value<String?> code = const Value.absent(),
          List<FormOption>? options}) =>
      DataOptionSet(
        id: id ?? this.id,
        lastModifiedDate: lastModifiedDate.present
            ? lastModifiedDate.value
            : this.lastModifiedDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        displayName: displayName.present ? displayName.value : this.displayName,
        label: label.present ? label.value : this.label,
        translations: translations ?? this.translations,
        name: name ?? this.name,
        code: code.present ? code.value : this.code,
        options: options ?? this.options,
      );
  DataOptionSet copyWithCompanion(DataOptionSetsCompanion data) {
    return DataOptionSet(
      id: data.id.present ? data.id.value : this.id,
      lastModifiedDate: data.lastModifiedDate.present
          ? data.lastModifiedDate.value
          : this.lastModifiedDate,
      createdDate:
          data.createdDate.present ? data.createdDate.value : this.createdDate,
      displayName:
          data.displayName.present ? data.displayName.value : this.displayName,
      label: data.label.present ? data.label.value : this.label,
      translations: data.translations.present
          ? data.translations.value
          : this.translations,
      name: data.name.present ? data.name.value : this.name,
      code: data.code.present ? data.code.value : this.code,
      options: data.options.present ? data.options.value : this.options,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DataOptionSet(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('displayName: $displayName, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('options: $options')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, lastModifiedDate, createdDate,
      displayName, label, translations, name, code, options);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DataOptionSet &&
          other.id == this.id &&
          other.lastModifiedDate == this.lastModifiedDate &&
          other.createdDate == this.createdDate &&
          other.displayName == this.displayName &&
          other.label == this.label &&
          other.translations == this.translations &&
          other.name == this.name &&
          other.code == this.code &&
          other.options == this.options);
}

class DataOptionSetsCompanion extends UpdateCompanion<DataOptionSet> {
  final Value<String> id;
  final Value<DateTime?> lastModifiedDate;
  final Value<DateTime?> createdDate;
  final Value<String?> displayName;
  final Value<Map<String, dynamic>?> label;
  final Value<List<Translation>> translations;
  final Value<String> name;
  final Value<String?> code;
  final Value<List<FormOption>> options;
  final Value<int> rowid;
  const DataOptionSetsCompanion({
    this.id = const Value.absent(),
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.displayName = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    this.name = const Value.absent(),
    this.code = const Value.absent(),
    this.options = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  DataOptionSetsCompanion.insert({
    required String id,
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.displayName = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    required String name,
    this.code = const Value.absent(),
    this.options = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        name = Value(name);
  static Insertable<DataOptionSet> custom({
    Expression<String>? id,
    Expression<DateTime>? lastModifiedDate,
    Expression<DateTime>? createdDate,
    Expression<String>? displayName,
    Expression<String>? label,
    Expression<String>? translations,
    Expression<String>? name,
    Expression<String>? code,
    Expression<String>? options,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (lastModifiedDate != null) 'last_modified_date': lastModifiedDate,
      if (createdDate != null) 'created_date': createdDate,
      if (displayName != null) 'display_name': displayName,
      if (label != null) 'label': label,
      if (translations != null) 'translations': translations,
      if (name != null) 'name': name,
      if (code != null) 'code': code,
      if (options != null) 'options': options,
      if (rowid != null) 'rowid': rowid,
    });
  }

  DataOptionSetsCompanion copyWith(
      {Value<String>? id,
      Value<DateTime?>? lastModifiedDate,
      Value<DateTime?>? createdDate,
      Value<String?>? displayName,
      Value<Map<String, dynamic>?>? label,
      Value<List<Translation>>? translations,
      Value<String>? name,
      Value<String?>? code,
      Value<List<FormOption>>? options,
      Value<int>? rowid}) {
    return DataOptionSetsCompanion(
      id: id ?? this.id,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      createdDate: createdDate ?? this.createdDate,
      displayName: displayName ?? this.displayName,
      label: label ?? this.label,
      translations: translations ?? this.translations,
      name: name ?? this.name,
      code: code ?? this.code,
      options: options ?? this.options,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (lastModifiedDate.present) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<DateTime>(createdDate.value);
    }
    if (displayName.present) {
      map['display_name'] = Variable<String>(displayName.value);
    }
    if (label.present) {
      map['label'] = Variable<String>(
          $DataOptionSetsTable.$converterlabel.toSql(label.value));
    }
    if (translations.present) {
      map['translations'] = Variable<String>($DataOptionSetsTable
          .$convertertranslations
          .toSql(translations.value));
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (options.present) {
      map['options'] = Variable<String>(
          $DataOptionSetsTable.$converteroptions.toSql(options.value));
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DataOptionSetsCompanion(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('displayName: $displayName, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('options: $options, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $DataElementsTable extends DataElements
    with TableInfo<$DataElementsTable, DataElement> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DataElementsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _lastModifiedDateMeta =
      const VerificationMeta('lastModifiedDate');
  @override
  late final GeneratedColumn<DateTime> lastModifiedDate =
      GeneratedColumn<DateTime>('last_modified_date', aliasedName, true,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<DateTime> createdDate = GeneratedColumn<DateTime>(
      'created_date', aliasedName, true,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _displayNameMeta =
      const VerificationMeta('displayName');
  @override
  late final GeneratedColumn<String> displayName = GeneratedColumn<String>(
      'display_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
      label = GeneratedColumn<String>('label', aliasedName, true,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '{}')
          .withConverter<Map<String, dynamic>?>(
              $DataElementsTable.$converterlabel);
  @override
  late final GeneratedColumnWithTypeConverter<List<Translation>, String>
      translations = GeneratedColumn<String>('translations', aliasedName, false,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '[]')
          .withConverter<List<Translation>>(
              $DataElementsTable.$convertertranslations);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<ValueType, String> type =
      GeneratedColumn<String>('type', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<ValueType>($DataElementsTable.$convertertype);
  static const VerificationMeta _optionSetMeta =
      const VerificationMeta('optionSet');
  @override
  late final GeneratedColumn<String> optionSet = GeneratedColumn<String>(
      'option_set', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES data_option_sets (id)'));
  static const VerificationMeta _mandatoryMeta =
      const VerificationMeta('mandatory');
  @override
  late final GeneratedColumn<bool> mandatory = GeneratedColumn<bool>(
      'mandatory', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("mandatory" IN (0, 1))'));
  static const VerificationMeta _defaultValueMeta =
      const VerificationMeta('defaultValue');
  @override
  late final GeneratedColumn<String> defaultValue = GeneratedColumn<String>(
      'default_value', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<ScannedCodeProperties?, String>
      scannedCodeProperties = GeneratedColumn<String>(
              'scanned_code_properties', aliasedName, true,
              type: DriftSqlType.string, requiredDuringInsert: false)
          .withConverter<ScannedCodeProperties?>(
              $DataElementsTable.$converterscannedCodeProperties);
  static const VerificationMeta _gs1EnabledMeta =
      const VerificationMeta('gs1Enabled');
  @override
  late final GeneratedColumn<bool> gs1Enabled = GeneratedColumn<bool>(
      'gs1_enabled', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("gs1_enabled" IN (0, 1))'));
  @override
  late final GeneratedColumnWithTypeConverter<MetadataResourceType?, String>
      resourceType = GeneratedColumn<String>('resource_type', aliasedName, true,
              type: DriftSqlType.string, requiredDuringInsert: false)
          .withConverter<MetadataResourceType?>(
              $DataElementsTable.$converterresourceTypen);
  static const VerificationMeta _resourceMetadataSchemaMeta =
      const VerificationMeta('resourceMetadataSchema');
  @override
  late final GeneratedColumn<String> resourceMetadataSchema =
      GeneratedColumn<String>('resource_metadata_schema', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        lastModifiedDate,
        createdDate,
        displayName,
        label,
        translations,
        name,
        code,
        description,
        type,
        optionSet,
        mandatory,
        defaultValue,
        scannedCodeProperties,
        gs1Enabled,
        resourceType,
        resourceMetadataSchema
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'data_elements';
  @override
  VerificationContext validateIntegrity(Insertable<DataElement> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('last_modified_date')) {
      context.handle(
          _lastModifiedDateMeta,
          lastModifiedDate.isAcceptableOrUnknown(
              data['last_modified_date']!, _lastModifiedDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('display_name')) {
      context.handle(
          _displayNameMeta,
          displayName.isAcceptableOrUnknown(
              data['display_name']!, _displayNameMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    if (data.containsKey('option_set')) {
      context.handle(_optionSetMeta,
          optionSet.isAcceptableOrUnknown(data['option_set']!, _optionSetMeta));
    }
    if (data.containsKey('mandatory')) {
      context.handle(_mandatoryMeta,
          mandatory.isAcceptableOrUnknown(data['mandatory']!, _mandatoryMeta));
    }
    if (data.containsKey('default_value')) {
      context.handle(
          _defaultValueMeta,
          defaultValue.isAcceptableOrUnknown(
              data['default_value']!, _defaultValueMeta));
    }
    if (data.containsKey('gs1_enabled')) {
      context.handle(
          _gs1EnabledMeta,
          gs1Enabled.isAcceptableOrUnknown(
              data['gs1_enabled']!, _gs1EnabledMeta));
    }
    if (data.containsKey('resource_metadata_schema')) {
      context.handle(
          _resourceMetadataSchemaMeta,
          resourceMetadataSchema.isAcceptableOrUnknown(
              data['resource_metadata_schema']!, _resourceMetadataSchemaMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  DataElement map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DataElement(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      lastModifiedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_modified_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_date']),
      displayName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}display_name']),
      label: $DataElementsTable.$converterlabel.fromSql(attachedDatabase
          .typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}label'])),
      translations: $DataElementsTable.$convertertranslations.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}translations'])!),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
      type: $DataElementsTable.$convertertype.fromSql(attachedDatabase
          .typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type'])!),
      optionSet: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}option_set']),
      mandatory: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}mandatory']),
      defaultValue: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}default_value']),
      scannedCodeProperties: $DataElementsTable.$converterscannedCodeProperties
          .fromSql(attachedDatabase.typeMapping.read(DriftSqlType.string,
              data['${effectivePrefix}scanned_code_properties'])),
      gs1Enabled: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}gs1_enabled']),
      resourceType: $DataElementsTable.$converterresourceTypen.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}resource_type'])),
      resourceMetadataSchema: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}resource_metadata_schema']),
    );
  }

  @override
  $DataElementsTable createAlias(String alias) {
    return $DataElementsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>?, String?> $converterlabel =
      const NullAwareMapConverter();
  static TypeConverter<List<Translation>, String> $convertertranslations =
      const TranslationConverter();
  static JsonTypeConverter2<ValueType, String, String> $convertertype =
      const EnumNameConverter(ValueType.values);
  static JsonTypeConverter2<ScannedCodeProperties?, String?,
          Map<String, Object?>?> $converterscannedCodeProperties =
      const ScannedCodePropertiesConverter();
  static JsonTypeConverter2<MetadataResourceType, String, String>
      $converterresourceType =
      const EnumNameConverter(MetadataResourceType.values);
  static JsonTypeConverter2<MetadataResourceType?, String?, String?>
      $converterresourceTypen =
      JsonTypeConverter2.asNullable($converterresourceType);
}

class DataElement extends DataClass implements Insertable<DataElement> {
  final String id;
  final DateTime? lastModifiedDate;
  final DateTime? createdDate;
  final String? displayName;
  final Map<String, dynamic>? label;
  final List<Translation> translations;
  final String name;
  final String? code;
  final String? description;
  final ValueType type;
  final String? optionSet;
  final bool? mandatory;
  final String? defaultValue;
  final ScannedCodeProperties? scannedCodeProperties;
  final bool? gs1Enabled;
  final MetadataResourceType? resourceType;
  final String? resourceMetadataSchema;
  const DataElement(
      {required this.id,
      this.lastModifiedDate,
      this.createdDate,
      this.displayName,
      this.label,
      required this.translations,
      required this.name,
      this.code,
      this.description,
      required this.type,
      this.optionSet,
      this.mandatory,
      this.defaultValue,
      this.scannedCodeProperties,
      this.gs1Enabled,
      this.resourceType,
      this.resourceMetadataSchema});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || lastModifiedDate != null) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<DateTime>(createdDate);
    }
    if (!nullToAbsent || displayName != null) {
      map['display_name'] = Variable<String>(displayName);
    }
    if (!nullToAbsent || label != null) {
      map['label'] =
          Variable<String>($DataElementsTable.$converterlabel.toSql(label));
    }
    {
      map['translations'] = Variable<String>(
          $DataElementsTable.$convertertranslations.toSql(translations));
    }
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    {
      map['type'] =
          Variable<String>($DataElementsTable.$convertertype.toSql(type));
    }
    if (!nullToAbsent || optionSet != null) {
      map['option_set'] = Variable<String>(optionSet);
    }
    if (!nullToAbsent || mandatory != null) {
      map['mandatory'] = Variable<bool>(mandatory);
    }
    if (!nullToAbsent || defaultValue != null) {
      map['default_value'] = Variable<String>(defaultValue);
    }
    if (!nullToAbsent || scannedCodeProperties != null) {
      map['scanned_code_properties'] = Variable<String>($DataElementsTable
          .$converterscannedCodeProperties
          .toSql(scannedCodeProperties));
    }
    if (!nullToAbsent || gs1Enabled != null) {
      map['gs1_enabled'] = Variable<bool>(gs1Enabled);
    }
    if (!nullToAbsent || resourceType != null) {
      map['resource_type'] = Variable<String>(
          $DataElementsTable.$converterresourceTypen.toSql(resourceType));
    }
    if (!nullToAbsent || resourceMetadataSchema != null) {
      map['resource_metadata_schema'] =
          Variable<String>(resourceMetadataSchema);
    }
    return map;
  }

  DataElementsCompanion toCompanion(bool nullToAbsent) {
    return DataElementsCompanion(
      id: Value(id),
      lastModifiedDate: lastModifiedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      displayName: displayName == null && nullToAbsent
          ? const Value.absent()
          : Value(displayName),
      label:
          label == null && nullToAbsent ? const Value.absent() : Value(label),
      translations: Value(translations),
      name: Value(name),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      type: Value(type),
      optionSet: optionSet == null && nullToAbsent
          ? const Value.absent()
          : Value(optionSet),
      mandatory: mandatory == null && nullToAbsent
          ? const Value.absent()
          : Value(mandatory),
      defaultValue: defaultValue == null && nullToAbsent
          ? const Value.absent()
          : Value(defaultValue),
      scannedCodeProperties: scannedCodeProperties == null && nullToAbsent
          ? const Value.absent()
          : Value(scannedCodeProperties),
      gs1Enabled: gs1Enabled == null && nullToAbsent
          ? const Value.absent()
          : Value(gs1Enabled),
      resourceType: resourceType == null && nullToAbsent
          ? const Value.absent()
          : Value(resourceType),
      resourceMetadataSchema: resourceMetadataSchema == null && nullToAbsent
          ? const Value.absent()
          : Value(resourceMetadataSchema),
    );
  }

  factory DataElement.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DataElement(
      id: serializer.fromJson<String>(json['id']),
      lastModifiedDate:
          serializer.fromJson<DateTime?>(json['lastModifiedDate']),
      createdDate: serializer.fromJson<DateTime?>(json['createdDate']),
      displayName: serializer.fromJson<String?>(json['displayName']),
      label: serializer.fromJson<Map<String, dynamic>?>(json['label']),
      translations:
          serializer.fromJson<List<Translation>>(json['translations']),
      name: serializer.fromJson<String>(json['name']),
      code: serializer.fromJson<String?>(json['code']),
      description: serializer.fromJson<String?>(json['description']),
      type: $DataElementsTable.$convertertype
          .fromJson(serializer.fromJson<String>(json['type'])),
      optionSet: serializer.fromJson<String?>(json['optionSet']),
      mandatory: serializer.fromJson<bool?>(json['mandatory']),
      defaultValue: serializer.fromJson<String?>(json['defaultValue']),
      scannedCodeProperties: $DataElementsTable.$converterscannedCodeProperties
          .fromJson(serializer
              .fromJson<Map<String, Object?>?>(json['scannedCodeProperties'])),
      gs1Enabled: serializer.fromJson<bool?>(json['gs1Enabled']),
      resourceType: $DataElementsTable.$converterresourceTypen
          .fromJson(serializer.fromJson<String?>(json['resourceType'])),
      resourceMetadataSchema:
          serializer.fromJson<String?>(json['resourceMetadataSchema']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'lastModifiedDate': serializer.toJson<DateTime?>(lastModifiedDate),
      'createdDate': serializer.toJson<DateTime?>(createdDate),
      'displayName': serializer.toJson<String?>(displayName),
      'label': serializer.toJson<Map<String, dynamic>?>(label),
      'translations': serializer.toJson<List<Translation>>(translations),
      'name': serializer.toJson<String>(name),
      'code': serializer.toJson<String?>(code),
      'description': serializer.toJson<String?>(description),
      'type': serializer
          .toJson<String>($DataElementsTable.$convertertype.toJson(type)),
      'optionSet': serializer.toJson<String?>(optionSet),
      'mandatory': serializer.toJson<bool?>(mandatory),
      'defaultValue': serializer.toJson<String?>(defaultValue),
      'scannedCodeProperties': serializer.toJson<Map<String, Object?>?>(
          $DataElementsTable.$converterscannedCodeProperties
              .toJson(scannedCodeProperties)),
      'gs1Enabled': serializer.toJson<bool?>(gs1Enabled),
      'resourceType': serializer.toJson<String?>(
          $DataElementsTable.$converterresourceTypen.toJson(resourceType)),
      'resourceMetadataSchema':
          serializer.toJson<String?>(resourceMetadataSchema),
    };
  }

  DataElement copyWith(
          {String? id,
          Value<DateTime?> lastModifiedDate = const Value.absent(),
          Value<DateTime?> createdDate = const Value.absent(),
          Value<String?> displayName = const Value.absent(),
          Value<Map<String, dynamic>?> label = const Value.absent(),
          List<Translation>? translations,
          String? name,
          Value<String?> code = const Value.absent(),
          Value<String?> description = const Value.absent(),
          ValueType? type,
          Value<String?> optionSet = const Value.absent(),
          Value<bool?> mandatory = const Value.absent(),
          Value<String?> defaultValue = const Value.absent(),
          Value<ScannedCodeProperties?> scannedCodeProperties =
              const Value.absent(),
          Value<bool?> gs1Enabled = const Value.absent(),
          Value<MetadataResourceType?> resourceType = const Value.absent(),
          Value<String?> resourceMetadataSchema = const Value.absent()}) =>
      DataElement(
        id: id ?? this.id,
        lastModifiedDate: lastModifiedDate.present
            ? lastModifiedDate.value
            : this.lastModifiedDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        displayName: displayName.present ? displayName.value : this.displayName,
        label: label.present ? label.value : this.label,
        translations: translations ?? this.translations,
        name: name ?? this.name,
        code: code.present ? code.value : this.code,
        description: description.present ? description.value : this.description,
        type: type ?? this.type,
        optionSet: optionSet.present ? optionSet.value : this.optionSet,
        mandatory: mandatory.present ? mandatory.value : this.mandatory,
        defaultValue:
            defaultValue.present ? defaultValue.value : this.defaultValue,
        scannedCodeProperties: scannedCodeProperties.present
            ? scannedCodeProperties.value
            : this.scannedCodeProperties,
        gs1Enabled: gs1Enabled.present ? gs1Enabled.value : this.gs1Enabled,
        resourceType:
            resourceType.present ? resourceType.value : this.resourceType,
        resourceMetadataSchema: resourceMetadataSchema.present
            ? resourceMetadataSchema.value
            : this.resourceMetadataSchema,
      );
  DataElement copyWithCompanion(DataElementsCompanion data) {
    return DataElement(
      id: data.id.present ? data.id.value : this.id,
      lastModifiedDate: data.lastModifiedDate.present
          ? data.lastModifiedDate.value
          : this.lastModifiedDate,
      createdDate:
          data.createdDate.present ? data.createdDate.value : this.createdDate,
      displayName:
          data.displayName.present ? data.displayName.value : this.displayName,
      label: data.label.present ? data.label.value : this.label,
      translations: data.translations.present
          ? data.translations.value
          : this.translations,
      name: data.name.present ? data.name.value : this.name,
      code: data.code.present ? data.code.value : this.code,
      description:
          data.description.present ? data.description.value : this.description,
      type: data.type.present ? data.type.value : this.type,
      optionSet: data.optionSet.present ? data.optionSet.value : this.optionSet,
      mandatory: data.mandatory.present ? data.mandatory.value : this.mandatory,
      defaultValue: data.defaultValue.present
          ? data.defaultValue.value
          : this.defaultValue,
      scannedCodeProperties: data.scannedCodeProperties.present
          ? data.scannedCodeProperties.value
          : this.scannedCodeProperties,
      gs1Enabled:
          data.gs1Enabled.present ? data.gs1Enabled.value : this.gs1Enabled,
      resourceType: data.resourceType.present
          ? data.resourceType.value
          : this.resourceType,
      resourceMetadataSchema: data.resourceMetadataSchema.present
          ? data.resourceMetadataSchema.value
          : this.resourceMetadataSchema,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DataElement(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('displayName: $displayName, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('description: $description, ')
          ..write('type: $type, ')
          ..write('optionSet: $optionSet, ')
          ..write('mandatory: $mandatory, ')
          ..write('defaultValue: $defaultValue, ')
          ..write('scannedCodeProperties: $scannedCodeProperties, ')
          ..write('gs1Enabled: $gs1Enabled, ')
          ..write('resourceType: $resourceType, ')
          ..write('resourceMetadataSchema: $resourceMetadataSchema')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      lastModifiedDate,
      createdDate,
      displayName,
      label,
      translations,
      name,
      code,
      description,
      type,
      optionSet,
      mandatory,
      defaultValue,
      scannedCodeProperties,
      gs1Enabled,
      resourceType,
      resourceMetadataSchema);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DataElement &&
          other.id == this.id &&
          other.lastModifiedDate == this.lastModifiedDate &&
          other.createdDate == this.createdDate &&
          other.displayName == this.displayName &&
          other.label == this.label &&
          other.translations == this.translations &&
          other.name == this.name &&
          other.code == this.code &&
          other.description == this.description &&
          other.type == this.type &&
          other.optionSet == this.optionSet &&
          other.mandatory == this.mandatory &&
          other.defaultValue == this.defaultValue &&
          other.scannedCodeProperties == this.scannedCodeProperties &&
          other.gs1Enabled == this.gs1Enabled &&
          other.resourceType == this.resourceType &&
          other.resourceMetadataSchema == this.resourceMetadataSchema);
}

class DataElementsCompanion extends UpdateCompanion<DataElement> {
  final Value<String> id;
  final Value<DateTime?> lastModifiedDate;
  final Value<DateTime?> createdDate;
  final Value<String?> displayName;
  final Value<Map<String, dynamic>?> label;
  final Value<List<Translation>> translations;
  final Value<String> name;
  final Value<String?> code;
  final Value<String?> description;
  final Value<ValueType> type;
  final Value<String?> optionSet;
  final Value<bool?> mandatory;
  final Value<String?> defaultValue;
  final Value<ScannedCodeProperties?> scannedCodeProperties;
  final Value<bool?> gs1Enabled;
  final Value<MetadataResourceType?> resourceType;
  final Value<String?> resourceMetadataSchema;
  final Value<int> rowid;
  const DataElementsCompanion({
    this.id = const Value.absent(),
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.displayName = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    this.name = const Value.absent(),
    this.code = const Value.absent(),
    this.description = const Value.absent(),
    this.type = const Value.absent(),
    this.optionSet = const Value.absent(),
    this.mandatory = const Value.absent(),
    this.defaultValue = const Value.absent(),
    this.scannedCodeProperties = const Value.absent(),
    this.gs1Enabled = const Value.absent(),
    this.resourceType = const Value.absent(),
    this.resourceMetadataSchema = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  DataElementsCompanion.insert({
    required String id,
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.displayName = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    required String name,
    this.code = const Value.absent(),
    this.description = const Value.absent(),
    required ValueType type,
    this.optionSet = const Value.absent(),
    this.mandatory = const Value.absent(),
    this.defaultValue = const Value.absent(),
    this.scannedCodeProperties = const Value.absent(),
    this.gs1Enabled = const Value.absent(),
    this.resourceType = const Value.absent(),
    this.resourceMetadataSchema = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        name = Value(name),
        type = Value(type);
  static Insertable<DataElement> custom({
    Expression<String>? id,
    Expression<DateTime>? lastModifiedDate,
    Expression<DateTime>? createdDate,
    Expression<String>? displayName,
    Expression<String>? label,
    Expression<String>? translations,
    Expression<String>? name,
    Expression<String>? code,
    Expression<String>? description,
    Expression<String>? type,
    Expression<String>? optionSet,
    Expression<bool>? mandatory,
    Expression<String>? defaultValue,
    Expression<String>? scannedCodeProperties,
    Expression<bool>? gs1Enabled,
    Expression<String>? resourceType,
    Expression<String>? resourceMetadataSchema,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (lastModifiedDate != null) 'last_modified_date': lastModifiedDate,
      if (createdDate != null) 'created_date': createdDate,
      if (displayName != null) 'display_name': displayName,
      if (label != null) 'label': label,
      if (translations != null) 'translations': translations,
      if (name != null) 'name': name,
      if (code != null) 'code': code,
      if (description != null) 'description': description,
      if (type != null) 'type': type,
      if (optionSet != null) 'option_set': optionSet,
      if (mandatory != null) 'mandatory': mandatory,
      if (defaultValue != null) 'default_value': defaultValue,
      if (scannedCodeProperties != null)
        'scanned_code_properties': scannedCodeProperties,
      if (gs1Enabled != null) 'gs1_enabled': gs1Enabled,
      if (resourceType != null) 'resource_type': resourceType,
      if (resourceMetadataSchema != null)
        'resource_metadata_schema': resourceMetadataSchema,
      if (rowid != null) 'rowid': rowid,
    });
  }

  DataElementsCompanion copyWith(
      {Value<String>? id,
      Value<DateTime?>? lastModifiedDate,
      Value<DateTime?>? createdDate,
      Value<String?>? displayName,
      Value<Map<String, dynamic>?>? label,
      Value<List<Translation>>? translations,
      Value<String>? name,
      Value<String?>? code,
      Value<String?>? description,
      Value<ValueType>? type,
      Value<String?>? optionSet,
      Value<bool?>? mandatory,
      Value<String?>? defaultValue,
      Value<ScannedCodeProperties?>? scannedCodeProperties,
      Value<bool?>? gs1Enabled,
      Value<MetadataResourceType?>? resourceType,
      Value<String?>? resourceMetadataSchema,
      Value<int>? rowid}) {
    return DataElementsCompanion(
      id: id ?? this.id,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      createdDate: createdDate ?? this.createdDate,
      displayName: displayName ?? this.displayName,
      label: label ?? this.label,
      translations: translations ?? this.translations,
      name: name ?? this.name,
      code: code ?? this.code,
      description: description ?? this.description,
      type: type ?? this.type,
      optionSet: optionSet ?? this.optionSet,
      mandatory: mandatory ?? this.mandatory,
      defaultValue: defaultValue ?? this.defaultValue,
      scannedCodeProperties:
          scannedCodeProperties ?? this.scannedCodeProperties,
      gs1Enabled: gs1Enabled ?? this.gs1Enabled,
      resourceType: resourceType ?? this.resourceType,
      resourceMetadataSchema:
          resourceMetadataSchema ?? this.resourceMetadataSchema,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (lastModifiedDate.present) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<DateTime>(createdDate.value);
    }
    if (displayName.present) {
      map['display_name'] = Variable<String>(displayName.value);
    }
    if (label.present) {
      map['label'] = Variable<String>(
          $DataElementsTable.$converterlabel.toSql(label.value));
    }
    if (translations.present) {
      map['translations'] = Variable<String>(
          $DataElementsTable.$convertertranslations.toSql(translations.value));
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (type.present) {
      map['type'] =
          Variable<String>($DataElementsTable.$convertertype.toSql(type.value));
    }
    if (optionSet.present) {
      map['option_set'] = Variable<String>(optionSet.value);
    }
    if (mandatory.present) {
      map['mandatory'] = Variable<bool>(mandatory.value);
    }
    if (defaultValue.present) {
      map['default_value'] = Variable<String>(defaultValue.value);
    }
    if (scannedCodeProperties.present) {
      map['scanned_code_properties'] = Variable<String>($DataElementsTable
          .$converterscannedCodeProperties
          .toSql(scannedCodeProperties.value));
    }
    if (gs1Enabled.present) {
      map['gs1_enabled'] = Variable<bool>(gs1Enabled.value);
    }
    if (resourceType.present) {
      map['resource_type'] = Variable<String>(
          $DataElementsTable.$converterresourceTypen.toSql(resourceType.value));
    }
    if (resourceMetadataSchema.present) {
      map['resource_metadata_schema'] =
          Variable<String>(resourceMetadataSchema.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DataElementsCompanion(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('displayName: $displayName, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('description: $description, ')
          ..write('type: $type, ')
          ..write('optionSet: $optionSet, ')
          ..write('mandatory: $mandatory, ')
          ..write('defaultValue: $defaultValue, ')
          ..write('scannedCodeProperties: $scannedCodeProperties, ')
          ..write('gs1Enabled: $gs1Enabled, ')
          ..write('resourceType: $resourceType, ')
          ..write('resourceMetadataSchema: $resourceMetadataSchema, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $DataValuesTable extends DataValues
    with TableInfo<$DataValuesTable, DataValue> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DataValuesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _lastModifiedDateMeta =
      const VerificationMeta('lastModifiedDate');
  @override
  late final GeneratedColumn<DateTime> lastModifiedDate =
      GeneratedColumn<DateTime>('last_modified_date', aliasedName, true,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<DateTime> createdDate = GeneratedColumn<DateTime>(
      'created_date', aliasedName, true,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _dataElementMeta =
      const VerificationMeta('dataElement');
  @override
  late final GeneratedColumn<String> dataElement = GeneratedColumn<String>(
      'data_element', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES data_elements (id)'));
  static const VerificationMeta _dataInstanceMeta =
      const VerificationMeta('dataInstance');
  @override
  late final GeneratedColumn<String> dataInstance = GeneratedColumn<String>(
      'data_instance', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES data_submissions (id)'));
  static const VerificationMeta _valueMeta = const VerificationMeta('value');
  @override
  late final GeneratedColumn<String> value = GeneratedColumn<String>(
      'value', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _commentMeta =
      const VerificationMeta('comment');
  @override
  late final GeneratedColumn<String> comment = GeneratedColumn<String>(
      'comment', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        lastModifiedDate,
        createdDate,
        dataElement,
        dataInstance,
        value,
        comment
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'data_values';
  @override
  VerificationContext validateIntegrity(Insertable<DataValue> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('last_modified_date')) {
      context.handle(
          _lastModifiedDateMeta,
          lastModifiedDate.isAcceptableOrUnknown(
              data['last_modified_date']!, _lastModifiedDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('data_element')) {
      context.handle(
          _dataElementMeta,
          dataElement.isAcceptableOrUnknown(
              data['data_element']!, _dataElementMeta));
    } else if (isInserting) {
      context.missing(_dataElementMeta);
    }
    if (data.containsKey('data_instance')) {
      context.handle(
          _dataInstanceMeta,
          dataInstance.isAcceptableOrUnknown(
              data['data_instance']!, _dataInstanceMeta));
    } else if (isInserting) {
      context.missing(_dataInstanceMeta);
    }
    if (data.containsKey('value')) {
      context.handle(
          _valueMeta, value.isAcceptableOrUnknown(data['value']!, _valueMeta));
    }
    if (data.containsKey('comment')) {
      context.handle(_commentMeta,
          comment.isAcceptableOrUnknown(data['comment']!, _commentMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  DataValue map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DataValue(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      lastModifiedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_modified_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_date']),
      dataElement: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}data_element'])!,
      dataInstance: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}data_instance'])!,
      value: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}value']),
      comment: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}comment']),
    );
  }

  @override
  $DataValuesTable createAlias(String alias) {
    return $DataValuesTable(attachedDatabase, alias);
  }
}

class DataValue extends DataClass implements Insertable<DataValue> {
  final String id;
  final DateTime? lastModifiedDate;
  final DateTime? createdDate;
  final String dataElement;
  final String dataInstance;
  final String? value;
  final String? comment;
  const DataValue(
      {required this.id,
      this.lastModifiedDate,
      this.createdDate,
      required this.dataElement,
      required this.dataInstance,
      this.value,
      this.comment});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || lastModifiedDate != null) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<DateTime>(createdDate);
    }
    map['data_element'] = Variable<String>(dataElement);
    map['data_instance'] = Variable<String>(dataInstance);
    if (!nullToAbsent || value != null) {
      map['value'] = Variable<String>(value);
    }
    if (!nullToAbsent || comment != null) {
      map['comment'] = Variable<String>(comment);
    }
    return map;
  }

  DataValuesCompanion toCompanion(bool nullToAbsent) {
    return DataValuesCompanion(
      id: Value(id),
      lastModifiedDate: lastModifiedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      dataElement: Value(dataElement),
      dataInstance: Value(dataInstance),
      value:
          value == null && nullToAbsent ? const Value.absent() : Value(value),
      comment: comment == null && nullToAbsent
          ? const Value.absent()
          : Value(comment),
    );
  }

  factory DataValue.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DataValue(
      id: serializer.fromJson<String>(json['id']),
      lastModifiedDate:
          serializer.fromJson<DateTime?>(json['lastModifiedDate']),
      createdDate: serializer.fromJson<DateTime?>(json['createdDate']),
      dataElement: serializer.fromJson<String>(json['dataElement']),
      dataInstance: serializer.fromJson<String>(json['dataInstance']),
      value: serializer.fromJson<String?>(json['value']),
      comment: serializer.fromJson<String?>(json['comment']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'lastModifiedDate': serializer.toJson<DateTime?>(lastModifiedDate),
      'createdDate': serializer.toJson<DateTime?>(createdDate),
      'dataElement': serializer.toJson<String>(dataElement),
      'dataInstance': serializer.toJson<String>(dataInstance),
      'value': serializer.toJson<String?>(value),
      'comment': serializer.toJson<String?>(comment),
    };
  }

  DataValue copyWith(
          {String? id,
          Value<DateTime?> lastModifiedDate = const Value.absent(),
          Value<DateTime?> createdDate = const Value.absent(),
          String? dataElement,
          String? dataInstance,
          Value<String?> value = const Value.absent(),
          Value<String?> comment = const Value.absent()}) =>
      DataValue(
        id: id ?? this.id,
        lastModifiedDate: lastModifiedDate.present
            ? lastModifiedDate.value
            : this.lastModifiedDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        dataElement: dataElement ?? this.dataElement,
        dataInstance: dataInstance ?? this.dataInstance,
        value: value.present ? value.value : this.value,
        comment: comment.present ? comment.value : this.comment,
      );
  DataValue copyWithCompanion(DataValuesCompanion data) {
    return DataValue(
      id: data.id.present ? data.id.value : this.id,
      lastModifiedDate: data.lastModifiedDate.present
          ? data.lastModifiedDate.value
          : this.lastModifiedDate,
      createdDate:
          data.createdDate.present ? data.createdDate.value : this.createdDate,
      dataElement:
          data.dataElement.present ? data.dataElement.value : this.dataElement,
      dataInstance: data.dataInstance.present
          ? data.dataInstance.value
          : this.dataInstance,
      value: data.value.present ? data.value.value : this.value,
      comment: data.comment.present ? data.comment.value : this.comment,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DataValue(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('dataElement: $dataElement, ')
          ..write('dataInstance: $dataInstance, ')
          ..write('value: $value, ')
          ..write('comment: $comment')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, lastModifiedDate, createdDate,
      dataElement, dataInstance, value, comment);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DataValue &&
          other.id == this.id &&
          other.lastModifiedDate == this.lastModifiedDate &&
          other.createdDate == this.createdDate &&
          other.dataElement == this.dataElement &&
          other.dataInstance == this.dataInstance &&
          other.value == this.value &&
          other.comment == this.comment);
}

class DataValuesCompanion extends UpdateCompanion<DataValue> {
  final Value<String> id;
  final Value<DateTime?> lastModifiedDate;
  final Value<DateTime?> createdDate;
  final Value<String> dataElement;
  final Value<String> dataInstance;
  final Value<String?> value;
  final Value<String?> comment;
  final Value<int> rowid;
  const DataValuesCompanion({
    this.id = const Value.absent(),
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.dataElement = const Value.absent(),
    this.dataInstance = const Value.absent(),
    this.value = const Value.absent(),
    this.comment = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  DataValuesCompanion.insert({
    required String id,
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    required String dataElement,
    required String dataInstance,
    this.value = const Value.absent(),
    this.comment = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        dataElement = Value(dataElement),
        dataInstance = Value(dataInstance);
  static Insertable<DataValue> custom({
    Expression<String>? id,
    Expression<DateTime>? lastModifiedDate,
    Expression<DateTime>? createdDate,
    Expression<String>? dataElement,
    Expression<String>? dataInstance,
    Expression<String>? value,
    Expression<String>? comment,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (lastModifiedDate != null) 'last_modified_date': lastModifiedDate,
      if (createdDate != null) 'created_date': createdDate,
      if (dataElement != null) 'data_element': dataElement,
      if (dataInstance != null) 'data_instance': dataInstance,
      if (value != null) 'value': value,
      if (comment != null) 'comment': comment,
      if (rowid != null) 'rowid': rowid,
    });
  }

  DataValuesCompanion copyWith(
      {Value<String>? id,
      Value<DateTime?>? lastModifiedDate,
      Value<DateTime?>? createdDate,
      Value<String>? dataElement,
      Value<String>? dataInstance,
      Value<String?>? value,
      Value<String?>? comment,
      Value<int>? rowid}) {
    return DataValuesCompanion(
      id: id ?? this.id,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      createdDate: createdDate ?? this.createdDate,
      dataElement: dataElement ?? this.dataElement,
      dataInstance: dataInstance ?? this.dataInstance,
      value: value ?? this.value,
      comment: comment ?? this.comment,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (lastModifiedDate.present) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<DateTime>(createdDate.value);
    }
    if (dataElement.present) {
      map['data_element'] = Variable<String>(dataElement.value);
    }
    if (dataInstance.present) {
      map['data_instance'] = Variable<String>(dataInstance.value);
    }
    if (value.present) {
      map['value'] = Variable<String>(value.value);
    }
    if (comment.present) {
      map['comment'] = Variable<String>(comment.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DataValuesCompanion(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('dataElement: $dataElement, ')
          ..write('dataInstance: $dataInstance, ')
          ..write('value: $value, ')
          ..write('comment: $comment, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $DataOptionsTable extends DataOptions
    with TableInfo<$DataOptionsTable, DataOption> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DataOptionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _optionSetMeta =
      const VerificationMeta('optionSet');
  @override
  late final GeneratedColumn<String> optionSet = GeneratedColumn<String>(
      'option_set', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES data_option_sets (id)'));
  static const VerificationMeta _orderMeta = const VerificationMeta('order');
  @override
  late final GeneratedColumn<int> order = GeneratedColumn<int>(
      'order', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      clientDefault: () => 0);
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
      label = GeneratedColumn<String>('label', aliasedName, true,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '{}')
          .withConverter<Map<String, dynamic>?>(
              $DataOptionsTable.$converterlabel);
  @override
  late final GeneratedColumnWithTypeConverter<List<Translation>?, String>
      translations = GeneratedColumn<String>('translations', aliasedName, true,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '[]')
          .withConverter<List<Translation>?>(
              $DataOptionsTable.$convertertranslationsn);
  @override
  List<GeneratedColumn> get $columns =>
      [id, name, code, optionSet, order, label, translations];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'data_options';
  @override
  VerificationContext validateIntegrity(Insertable<DataOption> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('option_set')) {
      context.handle(_optionSetMeta,
          optionSet.isAcceptableOrUnknown(data['option_set']!, _optionSetMeta));
    } else if (isInserting) {
      context.missing(_optionSetMeta);
    }
    if (data.containsKey('order')) {
      context.handle(
          _orderMeta, order.isAcceptableOrUnknown(data['order']!, _orderMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {optionSet, id},
        {optionSet, name},
      ];
  @override
  DataOption map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DataOption(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      optionSet: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}option_set'])!,
      order: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}order'])!,
      label: $DataOptionsTable.$converterlabel.fromSql(attachedDatabase
          .typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}label'])),
      translations: $DataOptionsTable.$convertertranslationsn.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}translations'])),
    );
  }

  @override
  $DataOptionsTable createAlias(String alias) {
    return $DataOptionsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>?, String?> $converterlabel =
      const NullAwareMapConverter();
  static TypeConverter<List<Translation>, String> $convertertranslations =
      const TranslationConverter();
  static TypeConverter<List<Translation>?, String?> $convertertranslationsn =
      NullAwareTypeConverter.wrap($convertertranslations);
}

class DataOption extends DataClass implements Insertable<DataOption> {
  final String id;
  final String name;
  final String? code;
  final String optionSet;
  final int order;
  final Map<String, dynamic>? label;
  final List<Translation>? translations;
  const DataOption(
      {required this.id,
      required this.name,
      this.code,
      required this.optionSet,
      required this.order,
      this.label,
      this.translations});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    map['option_set'] = Variable<String>(optionSet);
    map['order'] = Variable<int>(order);
    if (!nullToAbsent || label != null) {
      map['label'] =
          Variable<String>($DataOptionsTable.$converterlabel.toSql(label));
    }
    if (!nullToAbsent || translations != null) {
      map['translations'] = Variable<String>(
          $DataOptionsTable.$convertertranslationsn.toSql(translations));
    }
    return map;
  }

  DataOptionsCompanion toCompanion(bool nullToAbsent) {
    return DataOptionsCompanion(
      id: Value(id),
      name: Value(name),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      optionSet: Value(optionSet),
      order: Value(order),
      label:
          label == null && nullToAbsent ? const Value.absent() : Value(label),
      translations: translations == null && nullToAbsent
          ? const Value.absent()
          : Value(translations),
    );
  }

  factory DataOption.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DataOption(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      code: serializer.fromJson<String?>(json['code']),
      optionSet: serializer.fromJson<String>(json['optionSet']),
      order: serializer.fromJson<int>(json['order']),
      label: serializer.fromJson<Map<String, dynamic>?>(json['label']),
      translations:
          serializer.fromJson<List<Translation>?>(json['translations']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'code': serializer.toJson<String?>(code),
      'optionSet': serializer.toJson<String>(optionSet),
      'order': serializer.toJson<int>(order),
      'label': serializer.toJson<Map<String, dynamic>?>(label),
      'translations': serializer.toJson<List<Translation>?>(translations),
    };
  }

  DataOption copyWith(
          {String? id,
          String? name,
          Value<String?> code = const Value.absent(),
          String? optionSet,
          int? order,
          Value<Map<String, dynamic>?> label = const Value.absent(),
          Value<List<Translation>?> translations = const Value.absent()}) =>
      DataOption(
        id: id ?? this.id,
        name: name ?? this.name,
        code: code.present ? code.value : this.code,
        optionSet: optionSet ?? this.optionSet,
        order: order ?? this.order,
        label: label.present ? label.value : this.label,
        translations:
            translations.present ? translations.value : this.translations,
      );
  DataOption copyWithCompanion(DataOptionsCompanion data) {
    return DataOption(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      code: data.code.present ? data.code.value : this.code,
      optionSet: data.optionSet.present ? data.optionSet.value : this.optionSet,
      order: data.order.present ? data.order.value : this.order,
      label: data.label.present ? data.label.value : this.label,
      translations: data.translations.present
          ? data.translations.value
          : this.translations,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DataOption(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('optionSet: $optionSet, ')
          ..write('order: $order, ')
          ..write('label: $label, ')
          ..write('translations: $translations')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, name, code, optionSet, order, label, translations);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DataOption &&
          other.id == this.id &&
          other.name == this.name &&
          other.code == this.code &&
          other.optionSet == this.optionSet &&
          other.order == this.order &&
          other.label == this.label &&
          other.translations == this.translations);
}

class DataOptionsCompanion extends UpdateCompanion<DataOption> {
  final Value<String> id;
  final Value<String> name;
  final Value<String?> code;
  final Value<String> optionSet;
  final Value<int> order;
  final Value<Map<String, dynamic>?> label;
  final Value<List<Translation>?> translations;
  final Value<int> rowid;
  const DataOptionsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.code = const Value.absent(),
    this.optionSet = const Value.absent(),
    this.order = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  DataOptionsCompanion.insert({
    required String id,
    required String name,
    this.code = const Value.absent(),
    required String optionSet,
    this.order = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        name = Value(name),
        optionSet = Value(optionSet);
  static Insertable<DataOption> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? code,
    Expression<String>? optionSet,
    Expression<int>? order,
    Expression<String>? label,
    Expression<String>? translations,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (code != null) 'code': code,
      if (optionSet != null) 'option_set': optionSet,
      if (order != null) 'order': order,
      if (label != null) 'label': label,
      if (translations != null) 'translations': translations,
      if (rowid != null) 'rowid': rowid,
    });
  }

  DataOptionsCompanion copyWith(
      {Value<String>? id,
      Value<String>? name,
      Value<String?>? code,
      Value<String>? optionSet,
      Value<int>? order,
      Value<Map<String, dynamic>?>? label,
      Value<List<Translation>?>? translations,
      Value<int>? rowid}) {
    return DataOptionsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      code: code ?? this.code,
      optionSet: optionSet ?? this.optionSet,
      order: order ?? this.order,
      label: label ?? this.label,
      translations: translations ?? this.translations,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (optionSet.present) {
      map['option_set'] = Variable<String>(optionSet.value);
    }
    if (order.present) {
      map['order'] = Variable<int>(order.value);
    }
    if (label.present) {
      map['label'] = Variable<String>(
          $DataOptionsTable.$converterlabel.toSql(label.value));
    }
    if (translations.present) {
      map['translations'] = Variable<String>(
          $DataOptionsTable.$convertertranslationsn.toSql(translations.value));
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DataOptionsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('optionSet: $optionSet, ')
          ..write('order: $order, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $UserFormPermissionsTable extends UserFormPermissions
    with TableInfo<$UserFormPermissionsTable, UserFormPermission> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UserFormPermissionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _teamMeta = const VerificationMeta('team');
  @override
  late final GeneratedColumn<String> team = GeneratedColumn<String>(
      'team', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES teams (id)'));
  static const VerificationMeta _formMeta = const VerificationMeta('form');
  @override
  late final GeneratedColumn<String> form = GeneratedColumn<String>(
      'form', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES form_templates (id)'));
  static const VerificationMeta _validFromMeta =
      const VerificationMeta('validFrom');
  @override
  late final GeneratedColumn<DateTime> validFrom = GeneratedColumn<DateTime>(
      'valid_from', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _validToMeta =
      const VerificationMeta('validTo');
  @override
  late final GeneratedColumn<DateTime> validTo = GeneratedColumn<DateTime>(
      'valid_to', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<List<FormPermission>, String>
      permissions = GeneratedColumn<String>('permissions', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<List<FormPermission>>(
              $UserFormPermissionsTable.$converterpermissions);
  @override
  List<GeneratedColumn> get $columns =>
      [team, form, validFrom, validTo, permissions];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'user_form_permissions';
  @override
  VerificationContext validateIntegrity(Insertable<UserFormPermission> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('team')) {
      context.handle(
          _teamMeta, team.isAcceptableOrUnknown(data['team']!, _teamMeta));
    } else if (isInserting) {
      context.missing(_teamMeta);
    }
    if (data.containsKey('form')) {
      context.handle(
          _formMeta, form.isAcceptableOrUnknown(data['form']!, _formMeta));
    } else if (isInserting) {
      context.missing(_formMeta);
    }
    if (data.containsKey('valid_from')) {
      context.handle(_validFromMeta,
          validFrom.isAcceptableOrUnknown(data['valid_from']!, _validFromMeta));
    }
    if (data.containsKey('valid_to')) {
      context.handle(_validToMeta,
          validTo.isAcceptableOrUnknown(data['valid_to']!, _validToMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {team, form};
  @override
  UserFormPermission map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserFormPermission(
      team: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}team'])!,
      form: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}form'])!,
      validFrom: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}valid_from']),
      validTo: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}valid_to']),
      permissions: $UserFormPermissionsTable.$converterpermissions.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}permissions'])!),
    );
  }

  @override
  $UserFormPermissionsTable createAlias(String alias) {
    return $UserFormPermissionsTable(attachedDatabase, alias);
  }

  static TypeConverter<List<FormPermission>, String> $converterpermissions =
      const FormPermissionsConverter();
}

class UserFormPermission extends DataClass
    implements Insertable<UserFormPermission> {
  final String team;
  final String form;
  final DateTime? validFrom;
  final DateTime? validTo;
  final List<FormPermission> permissions;
  const UserFormPermission(
      {required this.team,
      required this.form,
      this.validFrom,
      this.validTo,
      required this.permissions});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['team'] = Variable<String>(team);
    map['form'] = Variable<String>(form);
    if (!nullToAbsent || validFrom != null) {
      map['valid_from'] = Variable<DateTime>(validFrom);
    }
    if (!nullToAbsent || validTo != null) {
      map['valid_to'] = Variable<DateTime>(validTo);
    }
    {
      map['permissions'] = Variable<String>(
          $UserFormPermissionsTable.$converterpermissions.toSql(permissions));
    }
    return map;
  }

  UserFormPermissionsCompanion toCompanion(bool nullToAbsent) {
    return UserFormPermissionsCompanion(
      team: Value(team),
      form: Value(form),
      validFrom: validFrom == null && nullToAbsent
          ? const Value.absent()
          : Value(validFrom),
      validTo: validTo == null && nullToAbsent
          ? const Value.absent()
          : Value(validTo),
      permissions: Value(permissions),
    );
  }

  factory UserFormPermission.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserFormPermission(
      team: serializer.fromJson<String>(json['team']),
      form: serializer.fromJson<String>(json['form']),
      validFrom: serializer.fromJson<DateTime?>(json['validFrom']),
      validTo: serializer.fromJson<DateTime?>(json['validTo']),
      permissions:
          serializer.fromJson<List<FormPermission>>(json['permissions']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'team': serializer.toJson<String>(team),
      'form': serializer.toJson<String>(form),
      'validFrom': serializer.toJson<DateTime?>(validFrom),
      'validTo': serializer.toJson<DateTime?>(validTo),
      'permissions': serializer.toJson<List<FormPermission>>(permissions),
    };
  }

  UserFormPermission copyWith(
          {String? team,
          String? form,
          Value<DateTime?> validFrom = const Value.absent(),
          Value<DateTime?> validTo = const Value.absent(),
          List<FormPermission>? permissions}) =>
      UserFormPermission(
        team: team ?? this.team,
        form: form ?? this.form,
        validFrom: validFrom.present ? validFrom.value : this.validFrom,
        validTo: validTo.present ? validTo.value : this.validTo,
        permissions: permissions ?? this.permissions,
      );
  UserFormPermission copyWithCompanion(UserFormPermissionsCompanion data) {
    return UserFormPermission(
      team: data.team.present ? data.team.value : this.team,
      form: data.form.present ? data.form.value : this.form,
      validFrom: data.validFrom.present ? data.validFrom.value : this.validFrom,
      validTo: data.validTo.present ? data.validTo.value : this.validTo,
      permissions:
          data.permissions.present ? data.permissions.value : this.permissions,
    );
  }

  @override
  String toString() {
    return (StringBuffer('UserFormPermission(')
          ..write('team: $team, ')
          ..write('form: $form, ')
          ..write('validFrom: $validFrom, ')
          ..write('validTo: $validTo, ')
          ..write('permissions: $permissions')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(team, form, validFrom, validTo, permissions);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserFormPermission &&
          other.team == this.team &&
          other.form == this.form &&
          other.validFrom == this.validFrom &&
          other.validTo == this.validTo &&
          other.permissions == this.permissions);
}

class UserFormPermissionsCompanion extends UpdateCompanion<UserFormPermission> {
  final Value<String> team;
  final Value<String> form;
  final Value<DateTime?> validFrom;
  final Value<DateTime?> validTo;
  final Value<List<FormPermission>> permissions;
  final Value<int> rowid;
  const UserFormPermissionsCompanion({
    this.team = const Value.absent(),
    this.form = const Value.absent(),
    this.validFrom = const Value.absent(),
    this.validTo = const Value.absent(),
    this.permissions = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UserFormPermissionsCompanion.insert({
    required String team,
    required String form,
    this.validFrom = const Value.absent(),
    this.validTo = const Value.absent(),
    required List<FormPermission> permissions,
    this.rowid = const Value.absent(),
  })  : team = Value(team),
        form = Value(form),
        permissions = Value(permissions);
  static Insertable<UserFormPermission> custom({
    Expression<String>? team,
    Expression<String>? form,
    Expression<DateTime>? validFrom,
    Expression<DateTime>? validTo,
    Expression<String>? permissions,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (team != null) 'team': team,
      if (form != null) 'form': form,
      if (validFrom != null) 'valid_from': validFrom,
      if (validTo != null) 'valid_to': validTo,
      if (permissions != null) 'permissions': permissions,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UserFormPermissionsCompanion copyWith(
      {Value<String>? team,
      Value<String>? form,
      Value<DateTime?>? validFrom,
      Value<DateTime?>? validTo,
      Value<List<FormPermission>>? permissions,
      Value<int>? rowid}) {
    return UserFormPermissionsCompanion(
      team: team ?? this.team,
      form: form ?? this.form,
      validFrom: validFrom ?? this.validFrom,
      validTo: validTo ?? this.validTo,
      permissions: permissions ?? this.permissions,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (team.present) {
      map['team'] = Variable<String>(team.value);
    }
    if (form.present) {
      map['form'] = Variable<String>(form.value);
    }
    if (validFrom.present) {
      map['valid_from'] = Variable<DateTime>(validFrom.value);
    }
    if (validTo.present) {
      map['valid_to'] = Variable<DateTime>(validTo.value);
    }
    if (permissions.present) {
      map['permissions'] = Variable<String>($UserFormPermissionsTable
          .$converterpermissions
          .toSql(permissions.value));
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserFormPermissionsCompanion(')
          ..write('team: $team, ')
          ..write('form: $form, ')
          ..write('validFrom: $validFrom, ')
          ..write('validTo: $validTo, ')
          ..write('permissions: $permissions, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $EntityAttributesTable extends EntityAttributes
    with TableInfo<$EntityAttributesTable, EntityAttribute> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EntityAttributesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _lastModifiedDateMeta =
      const VerificationMeta('lastModifiedDate');
  @override
  late final GeneratedColumn<DateTime> lastModifiedDate =
      GeneratedColumn<DateTime>('last_modified_date', aliasedName, true,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<DateTime> createdDate = GeneratedColumn<DateTime>(
      'created_date', aliasedName, true,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _displayNameMeta =
      const VerificationMeta('displayName');
  @override
  late final GeneratedColumn<String> displayName = GeneratedColumn<String>(
      'display_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
      label = GeneratedColumn<String>('label', aliasedName, true,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '{}')
          .withConverter<Map<String, dynamic>?>(
              $EntityAttributesTable.$converterlabel);
  @override
  late final GeneratedColumnWithTypeConverter<List<Translation>, String>
      translations = GeneratedColumn<String>('translations', aliasedName, false,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '[]')
          .withConverter<List<Translation>>(
              $EntityAttributesTable.$convertertranslations);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _shortNameMeta =
      const VerificationMeta('shortName');
  @override
  late final GeneratedColumn<String> shortName = GeneratedColumn<String>(
      'short_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<ValueType, String> valueType =
      GeneratedColumn<String>('value_type', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<ValueType>($EntityAttributesTable.$convertervalueType);
  static const VerificationMeta _optionSetMeta =
      const VerificationMeta('optionSet');
  @override
  late final GeneratedColumn<String> optionSet = GeneratedColumn<String>(
      'option_set', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES data_option_sets (id)'));
  static const VerificationMeta _displayWhenPlannedMeta =
      const VerificationMeta('displayWhenPlanned');
  @override
  late final GeneratedColumn<bool> displayWhenPlanned = GeneratedColumn<bool>(
      'display_when_planned', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("display_when_planned" IN (0, 1))'));
  static const VerificationMeta _mandatoryMeta =
      const VerificationMeta('mandatory');
  @override
  late final GeneratedColumn<bool> mandatory = GeneratedColumn<bool>(
      'mandatory', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("mandatory" IN (0, 1))'),
      clientDefault: () => false);
  static const VerificationMeta _defaultValueMeta =
      const VerificationMeta('defaultValue');
  @override
  late final GeneratedColumn<String> defaultValue = GeneratedColumn<String>(
      'default_value', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        lastModifiedDate,
        createdDate,
        displayName,
        label,
        translations,
        code,
        name,
        shortName,
        description,
        valueType,
        optionSet,
        displayWhenPlanned,
        mandatory,
        defaultValue
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'entity_attributes';
  @override
  VerificationContext validateIntegrity(Insertable<EntityAttribute> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('last_modified_date')) {
      context.handle(
          _lastModifiedDateMeta,
          lastModifiedDate.isAcceptableOrUnknown(
              data['last_modified_date']!, _lastModifiedDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('display_name')) {
      context.handle(
          _displayNameMeta,
          displayName.isAcceptableOrUnknown(
              data['display_name']!, _displayNameMeta));
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('short_name')) {
      context.handle(_shortNameMeta,
          shortName.isAcceptableOrUnknown(data['short_name']!, _shortNameMeta));
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    if (data.containsKey('option_set')) {
      context.handle(_optionSetMeta,
          optionSet.isAcceptableOrUnknown(data['option_set']!, _optionSetMeta));
    }
    if (data.containsKey('display_when_planned')) {
      context.handle(
          _displayWhenPlannedMeta,
          displayWhenPlanned.isAcceptableOrUnknown(
              data['display_when_planned']!, _displayWhenPlannedMeta));
    }
    if (data.containsKey('mandatory')) {
      context.handle(_mandatoryMeta,
          mandatory.isAcceptableOrUnknown(data['mandatory']!, _mandatoryMeta));
    }
    if (data.containsKey('default_value')) {
      context.handle(
          _defaultValueMeta,
          defaultValue.isAcceptableOrUnknown(
              data['default_value']!, _defaultValueMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  EntityAttribute map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return EntityAttribute(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      lastModifiedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_modified_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_date']),
      displayName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}display_name']),
      label: $EntityAttributesTable.$converterlabel.fromSql(attachedDatabase
          .typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}label'])),
      translations: $EntityAttributesTable.$convertertranslations.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}translations'])!),
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      shortName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}short_name']),
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
      valueType: $EntityAttributesTable.$convertervalueType.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}value_type'])!),
      optionSet: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}option_set']),
      displayWhenPlanned: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}display_when_planned']),
      mandatory: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}mandatory']),
      defaultValue: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}default_value']),
    );
  }

  @override
  $EntityAttributesTable createAlias(String alias) {
    return $EntityAttributesTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>?, String?> $converterlabel =
      const NullAwareMapConverter();
  static TypeConverter<List<Translation>, String> $convertertranslations =
      const TranslationConverter();
  static JsonTypeConverter2<ValueType, String, String> $convertervalueType =
      const EnumNameConverter(ValueType.values);
}

class EntityAttribute extends DataClass implements Insertable<EntityAttribute> {
  final String id;
  final DateTime? lastModifiedDate;
  final DateTime? createdDate;
  final String? displayName;
  final Map<String, dynamic>? label;
  final List<Translation> translations;
  final String? code;
  final String name;
  final String? shortName;
  final String? description;
  final ValueType valueType;
  final String? optionSet;
  final bool? displayWhenPlanned;
  final bool? mandatory;
  final String? defaultValue;
  const EntityAttribute(
      {required this.id,
      this.lastModifiedDate,
      this.createdDate,
      this.displayName,
      this.label,
      required this.translations,
      this.code,
      required this.name,
      this.shortName,
      this.description,
      required this.valueType,
      this.optionSet,
      this.displayWhenPlanned,
      this.mandatory,
      this.defaultValue});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || lastModifiedDate != null) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<DateTime>(createdDate);
    }
    if (!nullToAbsent || displayName != null) {
      map['display_name'] = Variable<String>(displayName);
    }
    if (!nullToAbsent || label != null) {
      map['label'] =
          Variable<String>($EntityAttributesTable.$converterlabel.toSql(label));
    }
    {
      map['translations'] = Variable<String>(
          $EntityAttributesTable.$convertertranslations.toSql(translations));
    }
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || shortName != null) {
      map['short_name'] = Variable<String>(shortName);
    }
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    {
      map['value_type'] = Variable<String>(
          $EntityAttributesTable.$convertervalueType.toSql(valueType));
    }
    if (!nullToAbsent || optionSet != null) {
      map['option_set'] = Variable<String>(optionSet);
    }
    if (!nullToAbsent || displayWhenPlanned != null) {
      map['display_when_planned'] = Variable<bool>(displayWhenPlanned);
    }
    if (!nullToAbsent || mandatory != null) {
      map['mandatory'] = Variable<bool>(mandatory);
    }
    if (!nullToAbsent || defaultValue != null) {
      map['default_value'] = Variable<String>(defaultValue);
    }
    return map;
  }

  EntityAttributesCompanion toCompanion(bool nullToAbsent) {
    return EntityAttributesCompanion(
      id: Value(id),
      lastModifiedDate: lastModifiedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      displayName: displayName == null && nullToAbsent
          ? const Value.absent()
          : Value(displayName),
      label:
          label == null && nullToAbsent ? const Value.absent() : Value(label),
      translations: Value(translations),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      name: Value(name),
      shortName: shortName == null && nullToAbsent
          ? const Value.absent()
          : Value(shortName),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      valueType: Value(valueType),
      optionSet: optionSet == null && nullToAbsent
          ? const Value.absent()
          : Value(optionSet),
      displayWhenPlanned: displayWhenPlanned == null && nullToAbsent
          ? const Value.absent()
          : Value(displayWhenPlanned),
      mandatory: mandatory == null && nullToAbsent
          ? const Value.absent()
          : Value(mandatory),
      defaultValue: defaultValue == null && nullToAbsent
          ? const Value.absent()
          : Value(defaultValue),
    );
  }

  factory EntityAttribute.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return EntityAttribute(
      id: serializer.fromJson<String>(json['id']),
      lastModifiedDate:
          serializer.fromJson<DateTime?>(json['lastModifiedDate']),
      createdDate: serializer.fromJson<DateTime?>(json['createdDate']),
      displayName: serializer.fromJson<String?>(json['displayName']),
      label: serializer.fromJson<Map<String, dynamic>?>(json['label']),
      translations:
          serializer.fromJson<List<Translation>>(json['translations']),
      code: serializer.fromJson<String?>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      shortName: serializer.fromJson<String?>(json['shortName']),
      description: serializer.fromJson<String?>(json['description']),
      valueType: $EntityAttributesTable.$convertervalueType
          .fromJson(serializer.fromJson<String>(json['valueType'])),
      optionSet: serializer.fromJson<String?>(json['optionSet']),
      displayWhenPlanned:
          serializer.fromJson<bool?>(json['displayWhenPlanned']),
      mandatory: serializer.fromJson<bool?>(json['mandatory']),
      defaultValue: serializer.fromJson<String?>(json['defaultValue']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'lastModifiedDate': serializer.toJson<DateTime?>(lastModifiedDate),
      'createdDate': serializer.toJson<DateTime?>(createdDate),
      'displayName': serializer.toJson<String?>(displayName),
      'label': serializer.toJson<Map<String, dynamic>?>(label),
      'translations': serializer.toJson<List<Translation>>(translations),
      'code': serializer.toJson<String?>(code),
      'name': serializer.toJson<String>(name),
      'shortName': serializer.toJson<String?>(shortName),
      'description': serializer.toJson<String?>(description),
      'valueType': serializer.toJson<String>(
          $EntityAttributesTable.$convertervalueType.toJson(valueType)),
      'optionSet': serializer.toJson<String?>(optionSet),
      'displayWhenPlanned': serializer.toJson<bool?>(displayWhenPlanned),
      'mandatory': serializer.toJson<bool?>(mandatory),
      'defaultValue': serializer.toJson<String?>(defaultValue),
    };
  }

  EntityAttribute copyWith(
          {String? id,
          Value<DateTime?> lastModifiedDate = const Value.absent(),
          Value<DateTime?> createdDate = const Value.absent(),
          Value<String?> displayName = const Value.absent(),
          Value<Map<String, dynamic>?> label = const Value.absent(),
          List<Translation>? translations,
          Value<String?> code = const Value.absent(),
          String? name,
          Value<String?> shortName = const Value.absent(),
          Value<String?> description = const Value.absent(),
          ValueType? valueType,
          Value<String?> optionSet = const Value.absent(),
          Value<bool?> displayWhenPlanned = const Value.absent(),
          Value<bool?> mandatory = const Value.absent(),
          Value<String?> defaultValue = const Value.absent()}) =>
      EntityAttribute(
        id: id ?? this.id,
        lastModifiedDate: lastModifiedDate.present
            ? lastModifiedDate.value
            : this.lastModifiedDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        displayName: displayName.present ? displayName.value : this.displayName,
        label: label.present ? label.value : this.label,
        translations: translations ?? this.translations,
        code: code.present ? code.value : this.code,
        name: name ?? this.name,
        shortName: shortName.present ? shortName.value : this.shortName,
        description: description.present ? description.value : this.description,
        valueType: valueType ?? this.valueType,
        optionSet: optionSet.present ? optionSet.value : this.optionSet,
        displayWhenPlanned: displayWhenPlanned.present
            ? displayWhenPlanned.value
            : this.displayWhenPlanned,
        mandatory: mandatory.present ? mandatory.value : this.mandatory,
        defaultValue:
            defaultValue.present ? defaultValue.value : this.defaultValue,
      );
  EntityAttribute copyWithCompanion(EntityAttributesCompanion data) {
    return EntityAttribute(
      id: data.id.present ? data.id.value : this.id,
      lastModifiedDate: data.lastModifiedDate.present
          ? data.lastModifiedDate.value
          : this.lastModifiedDate,
      createdDate:
          data.createdDate.present ? data.createdDate.value : this.createdDate,
      displayName:
          data.displayName.present ? data.displayName.value : this.displayName,
      label: data.label.present ? data.label.value : this.label,
      translations: data.translations.present
          ? data.translations.value
          : this.translations,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      shortName: data.shortName.present ? data.shortName.value : this.shortName,
      description:
          data.description.present ? data.description.value : this.description,
      valueType: data.valueType.present ? data.valueType.value : this.valueType,
      optionSet: data.optionSet.present ? data.optionSet.value : this.optionSet,
      displayWhenPlanned: data.displayWhenPlanned.present
          ? data.displayWhenPlanned.value
          : this.displayWhenPlanned,
      mandatory: data.mandatory.present ? data.mandatory.value : this.mandatory,
      defaultValue: data.defaultValue.present
          ? data.defaultValue.value
          : this.defaultValue,
    );
  }

  @override
  String toString() {
    return (StringBuffer('EntityAttribute(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('displayName: $displayName, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('shortName: $shortName, ')
          ..write('description: $description, ')
          ..write('valueType: $valueType, ')
          ..write('optionSet: $optionSet, ')
          ..write('displayWhenPlanned: $displayWhenPlanned, ')
          ..write('mandatory: $mandatory, ')
          ..write('defaultValue: $defaultValue')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      lastModifiedDate,
      createdDate,
      displayName,
      label,
      translations,
      code,
      name,
      shortName,
      description,
      valueType,
      optionSet,
      displayWhenPlanned,
      mandatory,
      defaultValue);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is EntityAttribute &&
          other.id == this.id &&
          other.lastModifiedDate == this.lastModifiedDate &&
          other.createdDate == this.createdDate &&
          other.displayName == this.displayName &&
          other.label == this.label &&
          other.translations == this.translations &&
          other.code == this.code &&
          other.name == this.name &&
          other.shortName == this.shortName &&
          other.description == this.description &&
          other.valueType == this.valueType &&
          other.optionSet == this.optionSet &&
          other.displayWhenPlanned == this.displayWhenPlanned &&
          other.mandatory == this.mandatory &&
          other.defaultValue == this.defaultValue);
}

class EntityAttributesCompanion extends UpdateCompanion<EntityAttribute> {
  final Value<String> id;
  final Value<DateTime?> lastModifiedDate;
  final Value<DateTime?> createdDate;
  final Value<String?> displayName;
  final Value<Map<String, dynamic>?> label;
  final Value<List<Translation>> translations;
  final Value<String?> code;
  final Value<String> name;
  final Value<String?> shortName;
  final Value<String?> description;
  final Value<ValueType> valueType;
  final Value<String?> optionSet;
  final Value<bool?> displayWhenPlanned;
  final Value<bool?> mandatory;
  final Value<String?> defaultValue;
  final Value<int> rowid;
  const EntityAttributesCompanion({
    this.id = const Value.absent(),
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.displayName = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.shortName = const Value.absent(),
    this.description = const Value.absent(),
    this.valueType = const Value.absent(),
    this.optionSet = const Value.absent(),
    this.displayWhenPlanned = const Value.absent(),
    this.mandatory = const Value.absent(),
    this.defaultValue = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  EntityAttributesCompanion.insert({
    required String id,
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.displayName = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    this.code = const Value.absent(),
    required String name,
    this.shortName = const Value.absent(),
    this.description = const Value.absent(),
    required ValueType valueType,
    this.optionSet = const Value.absent(),
    this.displayWhenPlanned = const Value.absent(),
    this.mandatory = const Value.absent(),
    this.defaultValue = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        name = Value(name),
        valueType = Value(valueType);
  static Insertable<EntityAttribute> custom({
    Expression<String>? id,
    Expression<DateTime>? lastModifiedDate,
    Expression<DateTime>? createdDate,
    Expression<String>? displayName,
    Expression<String>? label,
    Expression<String>? translations,
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? shortName,
    Expression<String>? description,
    Expression<String>? valueType,
    Expression<String>? optionSet,
    Expression<bool>? displayWhenPlanned,
    Expression<bool>? mandatory,
    Expression<String>? defaultValue,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (lastModifiedDate != null) 'last_modified_date': lastModifiedDate,
      if (createdDate != null) 'created_date': createdDate,
      if (displayName != null) 'display_name': displayName,
      if (label != null) 'label': label,
      if (translations != null) 'translations': translations,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (shortName != null) 'short_name': shortName,
      if (description != null) 'description': description,
      if (valueType != null) 'value_type': valueType,
      if (optionSet != null) 'option_set': optionSet,
      if (displayWhenPlanned != null)
        'display_when_planned': displayWhenPlanned,
      if (mandatory != null) 'mandatory': mandatory,
      if (defaultValue != null) 'default_value': defaultValue,
      if (rowid != null) 'rowid': rowid,
    });
  }

  EntityAttributesCompanion copyWith(
      {Value<String>? id,
      Value<DateTime?>? lastModifiedDate,
      Value<DateTime?>? createdDate,
      Value<String?>? displayName,
      Value<Map<String, dynamic>?>? label,
      Value<List<Translation>>? translations,
      Value<String?>? code,
      Value<String>? name,
      Value<String?>? shortName,
      Value<String?>? description,
      Value<ValueType>? valueType,
      Value<String?>? optionSet,
      Value<bool?>? displayWhenPlanned,
      Value<bool?>? mandatory,
      Value<String?>? defaultValue,
      Value<int>? rowid}) {
    return EntityAttributesCompanion(
      id: id ?? this.id,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      createdDate: createdDate ?? this.createdDate,
      displayName: displayName ?? this.displayName,
      label: label ?? this.label,
      translations: translations ?? this.translations,
      code: code ?? this.code,
      name: name ?? this.name,
      shortName: shortName ?? this.shortName,
      description: description ?? this.description,
      valueType: valueType ?? this.valueType,
      optionSet: optionSet ?? this.optionSet,
      displayWhenPlanned: displayWhenPlanned ?? this.displayWhenPlanned,
      mandatory: mandatory ?? this.mandatory,
      defaultValue: defaultValue ?? this.defaultValue,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (lastModifiedDate.present) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<DateTime>(createdDate.value);
    }
    if (displayName.present) {
      map['display_name'] = Variable<String>(displayName.value);
    }
    if (label.present) {
      map['label'] = Variable<String>(
          $EntityAttributesTable.$converterlabel.toSql(label.value));
    }
    if (translations.present) {
      map['translations'] = Variable<String>($EntityAttributesTable
          .$convertertranslations
          .toSql(translations.value));
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (shortName.present) {
      map['short_name'] = Variable<String>(shortName.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (valueType.present) {
      map['value_type'] = Variable<String>(
          $EntityAttributesTable.$convertervalueType.toSql(valueType.value));
    }
    if (optionSet.present) {
      map['option_set'] = Variable<String>(optionSet.value);
    }
    if (displayWhenPlanned.present) {
      map['display_when_planned'] = Variable<bool>(displayWhenPlanned.value);
    }
    if (mandatory.present) {
      map['mandatory'] = Variable<bool>(mandatory.value);
    }
    if (defaultValue.present) {
      map['default_value'] = Variable<String>(defaultValue.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EntityAttributesCompanion(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('displayName: $displayName, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('shortName: $shortName, ')
          ..write('description: $description, ')
          ..write('valueType: $valueType, ')
          ..write('optionSet: $optionSet, ')
          ..write('displayWhenPlanned: $displayWhenPlanned, ')
          ..write('mandatory: $mandatory, ')
          ..write('defaultValue: $defaultValue, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $EntityAttributeValuesTable extends EntityAttributeValues
    with TableInfo<$EntityAttributeValuesTable, EntityAttributeValue> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EntityAttributeValuesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _lastModifiedDateMeta =
      const VerificationMeta('lastModifiedDate');
  @override
  late final GeneratedColumn<DateTime> lastModifiedDate =
      GeneratedColumn<DateTime>('last_modified_date', aliasedName, true,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<DateTime> createdDate = GeneratedColumn<DateTime>(
      'created_date', aliasedName, true,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      clientDefault: () => DateTime.now().toUtc());
  static const VerificationMeta _displayNameMeta =
      const VerificationMeta('displayName');
  @override
  late final GeneratedColumn<String> displayName = GeneratedColumn<String>(
      'display_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
      label = GeneratedColumn<String>('label', aliasedName, true,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '{}')
          .withConverter<Map<String, dynamic>?>(
              $EntityAttributeValuesTable.$converterlabel);
  @override
  late final GeneratedColumnWithTypeConverter<List<Translation>, String>
      translations = GeneratedColumn<String>('translations', aliasedName, false,
              type: DriftSqlType.string,
              requiredDuringInsert: false,
              clientDefault: () => '[]')
          .withConverter<List<Translation>>(
              $EntityAttributeValuesTable.$convertertranslations);
  static const VerificationMeta _entityInstanceMeta =
      const VerificationMeta('entityInstance');
  @override
  late final GeneratedColumn<String> entityInstance = GeneratedColumn<String>(
      'entity_instance', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES entity_instances (id)'));
  static const VerificationMeta _entityAttributeMeta =
      const VerificationMeta('entityAttribute');
  @override
  late final GeneratedColumn<String> entityAttribute = GeneratedColumn<String>(
      'entity_attribute', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES entity_instances (id)'));
  static const VerificationMeta _valueMeta = const VerificationMeta('value');
  @override
  late final GeneratedColumn<String> value = GeneratedColumn<String>(
      'value', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  late final GeneratedColumnWithTypeConverter<InstanceSyncStatus, String>
      syncState = GeneratedColumn<String>('sync_state', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<InstanceSyncStatus>(
              $EntityAttributeValuesTable.$convertersyncState);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        lastModifiedDate,
        createdDate,
        displayName,
        label,
        translations,
        entityInstance,
        entityAttribute,
        value,
        syncState
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'entity_attribute_values';
  @override
  VerificationContext validateIntegrity(
      Insertable<EntityAttributeValue> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('last_modified_date')) {
      context.handle(
          _lastModifiedDateMeta,
          lastModifiedDate.isAcceptableOrUnknown(
              data['last_modified_date']!, _lastModifiedDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('display_name')) {
      context.handle(
          _displayNameMeta,
          displayName.isAcceptableOrUnknown(
              data['display_name']!, _displayNameMeta));
    }
    if (data.containsKey('entity_instance')) {
      context.handle(
          _entityInstanceMeta,
          entityInstance.isAcceptableOrUnknown(
              data['entity_instance']!, _entityInstanceMeta));
    } else if (isInserting) {
      context.missing(_entityInstanceMeta);
    }
    if (data.containsKey('entity_attribute')) {
      context.handle(
          _entityAttributeMeta,
          entityAttribute.isAcceptableOrUnknown(
              data['entity_attribute']!, _entityAttributeMeta));
    } else if (isInserting) {
      context.missing(_entityAttributeMeta);
    }
    if (data.containsKey('value')) {
      context.handle(
          _valueMeta, value.isAcceptableOrUnknown(data['value']!, _valueMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  EntityAttributeValue map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return EntityAttributeValue(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      lastModifiedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_modified_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_date']),
      displayName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}display_name']),
      label: $EntityAttributeValuesTable.$converterlabel.fromSql(
          attachedDatabase.typeMapping
              .read(DriftSqlType.string, data['${effectivePrefix}label'])),
      translations: $EntityAttributeValuesTable.$convertertranslations.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}translations'])!),
      entityInstance: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}entity_instance'])!,
      entityAttribute: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}entity_attribute'])!,
      value: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}value']),
      syncState: $EntityAttributeValuesTable.$convertersyncState.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}sync_state'])!),
    );
  }

  @override
  $EntityAttributeValuesTable createAlias(String alias) {
    return $EntityAttributeValuesTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>?, String?> $converterlabel =
      const NullAwareMapConverter();
  static TypeConverter<List<Translation>, String> $convertertranslations =
      const TranslationConverter();
  static JsonTypeConverter2<InstanceSyncStatus, String, String>
      $convertersyncState = const EnumNameConverter(InstanceSyncStatus.values);
}

class EntityAttributeValue extends DataClass
    implements Insertable<EntityAttributeValue> {
  final String id;
  final DateTime? lastModifiedDate;
  final DateTime? createdDate;
  final String? displayName;
  final Map<String, dynamic>? label;
  final List<Translation> translations;
  final String entityInstance;
  final String entityAttribute;
  final String? value;
  final InstanceSyncStatus syncState;
  const EntityAttributeValue(
      {required this.id,
      this.lastModifiedDate,
      this.createdDate,
      this.displayName,
      this.label,
      required this.translations,
      required this.entityInstance,
      required this.entityAttribute,
      this.value,
      required this.syncState});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || lastModifiedDate != null) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<DateTime>(createdDate);
    }
    if (!nullToAbsent || displayName != null) {
      map['display_name'] = Variable<String>(displayName);
    }
    if (!nullToAbsent || label != null) {
      map['label'] = Variable<String>(
          $EntityAttributeValuesTable.$converterlabel.toSql(label));
    }
    {
      map['translations'] = Variable<String>($EntityAttributeValuesTable
          .$convertertranslations
          .toSql(translations));
    }
    map['entity_instance'] = Variable<String>(entityInstance);
    map['entity_attribute'] = Variable<String>(entityAttribute);
    if (!nullToAbsent || value != null) {
      map['value'] = Variable<String>(value);
    }
    {
      map['sync_state'] = Variable<String>(
          $EntityAttributeValuesTable.$convertersyncState.toSql(syncState));
    }
    return map;
  }

  EntityAttributeValuesCompanion toCompanion(bool nullToAbsent) {
    return EntityAttributeValuesCompanion(
      id: Value(id),
      lastModifiedDate: lastModifiedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      displayName: displayName == null && nullToAbsent
          ? const Value.absent()
          : Value(displayName),
      label:
          label == null && nullToAbsent ? const Value.absent() : Value(label),
      translations: Value(translations),
      entityInstance: Value(entityInstance),
      entityAttribute: Value(entityAttribute),
      value:
          value == null && nullToAbsent ? const Value.absent() : Value(value),
      syncState: Value(syncState),
    );
  }

  factory EntityAttributeValue.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return EntityAttributeValue(
      id: serializer.fromJson<String>(json['id']),
      lastModifiedDate:
          serializer.fromJson<DateTime?>(json['lastModifiedDate']),
      createdDate: serializer.fromJson<DateTime?>(json['createdDate']),
      displayName: serializer.fromJson<String?>(json['displayName']),
      label: serializer.fromJson<Map<String, dynamic>?>(json['label']),
      translations:
          serializer.fromJson<List<Translation>>(json['translations']),
      entityInstance: serializer.fromJson<String>(json['entityInstance']),
      entityAttribute: serializer.fromJson<String>(json['entityAttribute']),
      value: serializer.fromJson<String?>(json['value']),
      syncState: $EntityAttributeValuesTable.$convertersyncState
          .fromJson(serializer.fromJson<String>(json['syncState'])),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'lastModifiedDate': serializer.toJson<DateTime?>(lastModifiedDate),
      'createdDate': serializer.toJson<DateTime?>(createdDate),
      'displayName': serializer.toJson<String?>(displayName),
      'label': serializer.toJson<Map<String, dynamic>?>(label),
      'translations': serializer.toJson<List<Translation>>(translations),
      'entityInstance': serializer.toJson<String>(entityInstance),
      'entityAttribute': serializer.toJson<String>(entityAttribute),
      'value': serializer.toJson<String?>(value),
      'syncState': serializer.toJson<String>(
          $EntityAttributeValuesTable.$convertersyncState.toJson(syncState)),
    };
  }

  EntityAttributeValue copyWith(
          {String? id,
          Value<DateTime?> lastModifiedDate = const Value.absent(),
          Value<DateTime?> createdDate = const Value.absent(),
          Value<String?> displayName = const Value.absent(),
          Value<Map<String, dynamic>?> label = const Value.absent(),
          List<Translation>? translations,
          String? entityInstance,
          String? entityAttribute,
          Value<String?> value = const Value.absent(),
          InstanceSyncStatus? syncState}) =>
      EntityAttributeValue(
        id: id ?? this.id,
        lastModifiedDate: lastModifiedDate.present
            ? lastModifiedDate.value
            : this.lastModifiedDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        displayName: displayName.present ? displayName.value : this.displayName,
        label: label.present ? label.value : this.label,
        translations: translations ?? this.translations,
        entityInstance: entityInstance ?? this.entityInstance,
        entityAttribute: entityAttribute ?? this.entityAttribute,
        value: value.present ? value.value : this.value,
        syncState: syncState ?? this.syncState,
      );
  EntityAttributeValue copyWithCompanion(EntityAttributeValuesCompanion data) {
    return EntityAttributeValue(
      id: data.id.present ? data.id.value : this.id,
      lastModifiedDate: data.lastModifiedDate.present
          ? data.lastModifiedDate.value
          : this.lastModifiedDate,
      createdDate:
          data.createdDate.present ? data.createdDate.value : this.createdDate,
      displayName:
          data.displayName.present ? data.displayName.value : this.displayName,
      label: data.label.present ? data.label.value : this.label,
      translations: data.translations.present
          ? data.translations.value
          : this.translations,
      entityInstance: data.entityInstance.present
          ? data.entityInstance.value
          : this.entityInstance,
      entityAttribute: data.entityAttribute.present
          ? data.entityAttribute.value
          : this.entityAttribute,
      value: data.value.present ? data.value.value : this.value,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
    );
  }

  @override
  String toString() {
    return (StringBuffer('EntityAttributeValue(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('displayName: $displayName, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('entityInstance: $entityInstance, ')
          ..write('entityAttribute: $entityAttribute, ')
          ..write('value: $value, ')
          ..write('syncState: $syncState')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      lastModifiedDate,
      createdDate,
      displayName,
      label,
      translations,
      entityInstance,
      entityAttribute,
      value,
      syncState);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is EntityAttributeValue &&
          other.id == this.id &&
          other.lastModifiedDate == this.lastModifiedDate &&
          other.createdDate == this.createdDate &&
          other.displayName == this.displayName &&
          other.label == this.label &&
          other.translations == this.translations &&
          other.entityInstance == this.entityInstance &&
          other.entityAttribute == this.entityAttribute &&
          other.value == this.value &&
          other.syncState == this.syncState);
}

class EntityAttributeValuesCompanion
    extends UpdateCompanion<EntityAttributeValue> {
  final Value<String> id;
  final Value<DateTime?> lastModifiedDate;
  final Value<DateTime?> createdDate;
  final Value<String?> displayName;
  final Value<Map<String, dynamic>?> label;
  final Value<List<Translation>> translations;
  final Value<String> entityInstance;
  final Value<String> entityAttribute;
  final Value<String?> value;
  final Value<InstanceSyncStatus> syncState;
  final Value<int> rowid;
  const EntityAttributeValuesCompanion({
    this.id = const Value.absent(),
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.displayName = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    this.entityInstance = const Value.absent(),
    this.entityAttribute = const Value.absent(),
    this.value = const Value.absent(),
    this.syncState = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  EntityAttributeValuesCompanion.insert({
    required String id,
    this.lastModifiedDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.displayName = const Value.absent(),
    this.label = const Value.absent(),
    this.translations = const Value.absent(),
    required String entityInstance,
    required String entityAttribute,
    this.value = const Value.absent(),
    required InstanceSyncStatus syncState,
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        entityInstance = Value(entityInstance),
        entityAttribute = Value(entityAttribute),
        syncState = Value(syncState);
  static Insertable<EntityAttributeValue> custom({
    Expression<String>? id,
    Expression<DateTime>? lastModifiedDate,
    Expression<DateTime>? createdDate,
    Expression<String>? displayName,
    Expression<String>? label,
    Expression<String>? translations,
    Expression<String>? entityInstance,
    Expression<String>? entityAttribute,
    Expression<String>? value,
    Expression<String>? syncState,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (lastModifiedDate != null) 'last_modified_date': lastModifiedDate,
      if (createdDate != null) 'created_date': createdDate,
      if (displayName != null) 'display_name': displayName,
      if (label != null) 'label': label,
      if (translations != null) 'translations': translations,
      if (entityInstance != null) 'entity_instance': entityInstance,
      if (entityAttribute != null) 'entity_attribute': entityAttribute,
      if (value != null) 'value': value,
      if (syncState != null) 'sync_state': syncState,
      if (rowid != null) 'rowid': rowid,
    });
  }

  EntityAttributeValuesCompanion copyWith(
      {Value<String>? id,
      Value<DateTime?>? lastModifiedDate,
      Value<DateTime?>? createdDate,
      Value<String?>? displayName,
      Value<Map<String, dynamic>?>? label,
      Value<List<Translation>>? translations,
      Value<String>? entityInstance,
      Value<String>? entityAttribute,
      Value<String?>? value,
      Value<InstanceSyncStatus>? syncState,
      Value<int>? rowid}) {
    return EntityAttributeValuesCompanion(
      id: id ?? this.id,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      createdDate: createdDate ?? this.createdDate,
      displayName: displayName ?? this.displayName,
      label: label ?? this.label,
      translations: translations ?? this.translations,
      entityInstance: entityInstance ?? this.entityInstance,
      entityAttribute: entityAttribute ?? this.entityAttribute,
      value: value ?? this.value,
      syncState: syncState ?? this.syncState,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (lastModifiedDate.present) {
      map['last_modified_date'] = Variable<DateTime>(lastModifiedDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<DateTime>(createdDate.value);
    }
    if (displayName.present) {
      map['display_name'] = Variable<String>(displayName.value);
    }
    if (label.present) {
      map['label'] = Variable<String>(
          $EntityAttributeValuesTable.$converterlabel.toSql(label.value));
    }
    if (translations.present) {
      map['translations'] = Variable<String>($EntityAttributeValuesTable
          .$convertertranslations
          .toSql(translations.value));
    }
    if (entityInstance.present) {
      map['entity_instance'] = Variable<String>(entityInstance.value);
    }
    if (entityAttribute.present) {
      map['entity_attribute'] = Variable<String>(entityAttribute.value);
    }
    if (value.present) {
      map['value'] = Variable<String>(value.value);
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>($EntityAttributeValuesTable
          .$convertersyncState
          .toSql(syncState.value));
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EntityAttributeValuesCompanion(')
          ..write('id: $id, ')
          ..write('lastModifiedDate: $lastModifiedDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('displayName: $displayName, ')
          ..write('label: $label, ')
          ..write('translations: $translations, ')
          ..write('entityInstance: $entityInstance, ')
          ..write('entityAttribute: $entityAttribute, ')
          ..write('value: $value, ')
          ..write('syncState: $syncState, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $UsersTable users = $UsersTable(this);
  late final $OrgUnitsTable orgUnits = $OrgUnitsTable(this);
  late final $OuLevelsTable ouLevels = $OuLevelsTable(this);
  late final $ProjectsTable projects = $ProjectsTable(this);
  late final $ActivitiesTable activities = $ActivitiesTable(this);
  late final $TeamsTable teams = $TeamsTable(this);
  late final $ManagedTeamsTable managedTeams = $ManagedTeamsTable(this);
  late final $FlowTypesTable flowTypes = $FlowTypesTable(this);
  late final $EntityTypesTable entityTypes = $EntityTypesTable(this);
  late final $EntityInstancesTable entityInstances =
      $EntityInstancesTable(this);
  late final $FlowInstancesTable flowInstances = $FlowInstancesTable(this);
  late final $FormTemplatesTable formTemplates = $FormTemplatesTable(this);
  late final $AssignmentFormsTable assignmentForms =
      $AssignmentFormsTable(this);
  late final $MetadataSubmissionsTable metadataSubmissions =
      $MetadataSubmissionsTable(this);
  late final $FormTemplateVersionsTable formTemplateVersions =
      $FormTemplateVersionsTable(this);
  late final $StageDefinitionsTable stageDefinitions =
      $StageDefinitionsTable(this);
  late final $DataSubmissionsTable dataSubmissions =
      $DataSubmissionsTable(this);
  late final $RepeatInstancesTable repeatInstances =
      $RepeatInstancesTable(this);
  late final $DataOptionSetsTable dataOptionSets = $DataOptionSetsTable(this);
  late final $DataElementsTable dataElements = $DataElementsTable(this);
  late final $DataValuesTable dataValues = $DataValuesTable(this);
  late final $DataOptionsTable dataOptions = $DataOptionsTable(this);
  late final $UserFormPermissionsTable userFormPermissions =
      $UserFormPermissionsTable(this);
  late final $EntityAttributesTable entityAttributes =
      $EntityAttributesTable(this);
  late final $EntityAttributeValuesTable entityAttributeValues =
      $EntityAttributeValuesTable(this);
  late final Index orgNameIdx =
      Index('org_name_idx', 'CREATE INDEX org_name_idx ON org_units (name)');
  late final Index orgCodeIdx = Index(
      'org_code_idx', 'CREATE UNIQUE INDEX org_code_idx ON org_units (code)');
  late final Index orgPathIdx = Index(
      'org_path_idx', 'CREATE UNIQUE INDEX org_path_idx ON org_units (path)');
  late final Index orgLevelIdx =
      Index('org_level_idx', 'CREATE INDEX org_level_idx ON org_units (level)');
  late final Index levelNameIdx = Index(
      'level_name_idx', 'CREATE INDEX level_name_idx ON ou_levels (name)');
  late final Index activityDisabledIdx = Index('activity_disabled_idx',
      'CREATE INDEX activity_disabled_idx ON activities (disabled)');
  late final Index teamCodIdx =
      Index('team_cod_idx', 'CREATE INDEX team_cod_idx ON teams (code)');
  late final Index managedTeamCodIdx = Index('managed_team_cod_idx',
      'CREATE INDEX managed_team_cod_idx ON managed_teams (code)');
  late final Index flowInstanceStatusIdx = Index('flow_instance_status_idx',
      'CREATE INDEX flow_instance_status_idx ON flow_instances (flow_status)');
  late final Index repeatTemplatePathIdx = Index('repeat_template_path_idx',
      'CREATE INDEX repeat_template_path_idx ON repeat_instances (template_path)');
  late final Index dataElementNameIdx = Index('data_element_name_idx',
      'CREATE INDEX data_element_name_idx ON data_elements (name)');
  late final Index optionSetNameIdx = Index('option_set_name_idx',
      'CREATE INDEX option_set_name_idx ON data_option_sets (name)');
  late final Index optionSetCodeIdx = Index('option_set_code_idx',
      'CREATE UNIQUE INDEX option_set_code_idx ON data_option_sets (code)');
  late final Index optionNameIdx = Index(
      'option_name_idx', 'CREATE INDEX option_name_idx ON data_options (name)');
  late final Index optionCodeIdx = Index('option_code_idx',
      'CREATE UNIQUE INDEX option_code_idx ON data_options (code)');
  late final Index dataInstanceStatusIdx = Index('data_instance_status_idx',
      'CREATE INDEX data_instance_status_idx ON data_submissions (sync_state)');
  late final Index templateVersionNumberIdx = Index(
      'template_version_number_idx',
      'CREATE INDEX template_version_number_idx ON form_template_versions (version_number)');
  late final Index formPermissionFormIdx = Index('form_permission_form_idx',
      'CREATE INDEX form_permission_form_idx ON user_form_permissions (team, form)');
  late final Index assignmentTypePlanningModeIdx = Index(
      'assignment_type_planning_mode_idx',
      'CREATE INDEX assignment_type_planning_mode_idx ON flow_types (planning_mode)');
  late final Index entityTypeKeyIdx = Index('entity_type_key_idx',
      'CREATE INDEX entity_type_key_idx ON entity_types (name)');
  late final Index entityAttributeNameIdx = Index('entity_attribute_name_idx',
      'CREATE INDEX entity_attribute_name_idx ON entity_attributes (name)');
  late final ActivitiesDao activitiesDao = ActivitiesDao(this as AppDatabase);
  late final FlowInstancesDao flowInstancesDao =
      FlowInstancesDao(this as AppDatabase);
  late final DataSubmissionsDao dataSubmissionsDao =
      DataSubmissionsDao(this as AppDatabase);
  late final DataValuesDao dataValuesDao = DataValuesDao(this as AppDatabase);
  late final RepeatInstancesDao repeatInstancesDao =
      RepeatInstancesDao(this as AppDatabase);
  late final TeamsDao teamsDao = TeamsDao(this as AppDatabase);
  late final DataOptionSetsDao dataOptionSetsDao =
      DataOptionSetsDao(this as AppDatabase);
  late final OrgUnitsDao orgUnitsDao = OrgUnitsDao(this as AppDatabase);
  late final UsersDao usersDao = UsersDao(this as AppDatabase);
  late final FormTemplateVersionsDao formTemplateVersionsDao =
      FormTemplateVersionsDao(this as AppDatabase);
  late final FormTemplatesDao formTemplatesDao =
      FormTemplatesDao(this as AppDatabase);
  late final DataElementsDao dataElementsDao =
      DataElementsDao(this as AppDatabase);
  late final FlowTypesDao flowTypesDao = FlowTypesDao(this as AppDatabase);
  late final EntityTypesDao entityTypesDao =
      EntityTypesDao(this as AppDatabase);
  late final EntityAttributesDao entityAttributesDao =
      EntityAttributesDao(this as AppDatabase);
  late final EntityInstancesDao entityInstancesDao =
      EntityInstancesDao(this as AppDatabase);
  late final StageDefinitionsDao stageDefinitionsDao =
      StageDefinitionsDao(this as AppDatabase);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
        users,
        orgUnits,
        ouLevels,
        projects,
        activities,
        teams,
        managedTeams,
        flowTypes,
        entityTypes,
        entityInstances,
        flowInstances,
        formTemplates,
        assignmentForms,
        metadataSubmissions,
        formTemplateVersions,
        stageDefinitions,
        dataSubmissions,
        repeatInstances,
        dataOptionSets,
        dataElements,
        dataValues,
        dataOptions,
        userFormPermissions,
        entityAttributes,
        entityAttributeValues,
        orgNameIdx,
        orgCodeIdx,
        orgPathIdx,
        orgLevelIdx,
        levelNameIdx,
        activityDisabledIdx,
        teamCodIdx,
        managedTeamCodIdx,
        flowInstanceStatusIdx,
        repeatTemplatePathIdx,
        dataElementNameIdx,
        optionSetNameIdx,
        optionSetCodeIdx,
        optionNameIdx,
        optionCodeIdx,
        dataInstanceStatusIdx,
        templateVersionNumberIdx,
        formPermissionFormIdx,
        assignmentTypePlanningModeIdx,
        entityTypeKeyIdx,
        entityAttributeNameIdx
      ];
  @override
  StreamQueryUpdateRules get streamUpdateRules => const StreamQueryUpdateRules(
        [
          WritePropagation(
            on: TableUpdateQuery.onTableName('flow_instances',
                limitUpdateKind: UpdateKind.update),
            result: [
              TableUpdate('assignment_forms', kind: UpdateKind.update),
            ],
          ),
        ],
      );
  @override
  DriftDatabaseOptions get options =>
      const DriftDatabaseOptions(storeDateTimeAsText: true);
}

typedef $$UsersTableCreateCompanionBuilder = UsersCompanion Function({
  required String id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  required String username,
  Value<String?> firstName,
  Value<String?> lastName,
  Value<String?> mobile,
  Value<String?> email,
  Value<String?> langKey,
  Value<bool> activated,
  Value<String?> imageUrl,
  required List<String> authorities,
  Value<int?> submissionCount,
  Value<int?> assignmentCount,
  Value<int?> orgUnitCount,
  required List<String> activityUIDs,
  required List<String> userTeamsUIDs,
  required List<String> managedTeamsUIDs,
  required List<String> userGroupsUIDs,
  required List<String> userFormsUIDs,
  Value<int> rowid,
});
typedef $$UsersTableUpdateCompanionBuilder = UsersCompanion Function({
  Value<String> id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String> username,
  Value<String?> firstName,
  Value<String?> lastName,
  Value<String?> mobile,
  Value<String?> email,
  Value<String?> langKey,
  Value<bool> activated,
  Value<String?> imageUrl,
  Value<List<String>> authorities,
  Value<int?> submissionCount,
  Value<int?> assignmentCount,
  Value<int?> orgUnitCount,
  Value<List<String>> activityUIDs,
  Value<List<String>> userTeamsUIDs,
  Value<List<String>> managedTeamsUIDs,
  Value<List<String>> userGroupsUIDs,
  Value<List<String>> userFormsUIDs,
  Value<int> rowid,
});

final class $$UsersTableReferences
    extends BaseReferences<_$AppDatabase, $UsersTable, User> {
  $$UsersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$TeamsTable, List<Team>> _userTeamsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.teams,
          aliasName: $_aliasNameGenerator(db.users.id, db.teams.user));

  $$TeamsTableProcessedTableManager get userTeams {
    final manager = $$TeamsTableTableManager($_db, $_db.teams)
        .filter((f) => f.user.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_userTeamsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$ManagedTeamsTable, List<ManagedTeam>>
      _managedTeamsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
          db.managedTeams,
          aliasName: $_aliasNameGenerator(db.users.id, db.managedTeams.user));

  $$ManagedTeamsTableProcessedTableManager get managedTeams {
    final manager = $$ManagedTeamsTableTableManager($_db, $_db.managedTeams)
        .filter((f) => f.user.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_managedTeamsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$UsersTableFilterComposer extends Composer<_$AppDatabase, $UsersTable> {
  $$UsersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get username => $composableBuilder(
      column: $table.username, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get firstName => $composableBuilder(
      column: $table.firstName, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get lastName => $composableBuilder(
      column: $table.lastName, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get mobile => $composableBuilder(
      column: $table.mobile, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get langKey => $composableBuilder(
      column: $table.langKey, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get activated => $composableBuilder(
      column: $table.activated, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get imageUrl => $composableBuilder(
      column: $table.imageUrl, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<List<String>, List<String>, String>
      get authorities => $composableBuilder(
          column: $table.authorities,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<int> get submissionCount => $composableBuilder(
      column: $table.submissionCount,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get assignmentCount => $composableBuilder(
      column: $table.assignmentCount,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get orgUnitCount => $composableBuilder(
      column: $table.orgUnitCount, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<List<String>, List<String>, String>
      get activityUIDs => $composableBuilder(
          column: $table.activityUIDs,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnWithTypeConverterFilters<List<String>, List<String>, String>
      get userTeamsUIDs => $composableBuilder(
          column: $table.userTeamsUIDs,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnWithTypeConverterFilters<List<String>, List<String>, String>
      get managedTeamsUIDs => $composableBuilder(
          column: $table.managedTeamsUIDs,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnWithTypeConverterFilters<List<String>, List<String>, String>
      get userGroupsUIDs => $composableBuilder(
          column: $table.userGroupsUIDs,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnWithTypeConverterFilters<List<String>, List<String>, String>
      get userFormsUIDs => $composableBuilder(
          column: $table.userFormsUIDs,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  Expression<bool> userTeams(
      Expression<bool> Function($$TeamsTableFilterComposer f) f) {
    final $$TeamsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.teams,
        getReferencedColumn: (t) => t.user,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$TeamsTableFilterComposer(
              $db: $db,
              $table: $db.teams,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> managedTeams(
      Expression<bool> Function($$ManagedTeamsTableFilterComposer f) f) {
    final $$ManagedTeamsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.managedTeams,
        getReferencedColumn: (t) => t.user,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ManagedTeamsTableFilterComposer(
              $db: $db,
              $table: $db.managedTeams,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$UsersTableOrderingComposer
    extends Composer<_$AppDatabase, $UsersTable> {
  $$UsersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get username => $composableBuilder(
      column: $table.username, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get firstName => $composableBuilder(
      column: $table.firstName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get lastName => $composableBuilder(
      column: $table.lastName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get mobile => $composableBuilder(
      column: $table.mobile, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get langKey => $composableBuilder(
      column: $table.langKey, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get activated => $composableBuilder(
      column: $table.activated, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get imageUrl => $composableBuilder(
      column: $table.imageUrl, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get authorities => $composableBuilder(
      column: $table.authorities, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get submissionCount => $composableBuilder(
      column: $table.submissionCount,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get assignmentCount => $composableBuilder(
      column: $table.assignmentCount,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get orgUnitCount => $composableBuilder(
      column: $table.orgUnitCount,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get activityUIDs => $composableBuilder(
      column: $table.activityUIDs,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get userTeamsUIDs => $composableBuilder(
      column: $table.userTeamsUIDs,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get managedTeamsUIDs => $composableBuilder(
      column: $table.managedTeamsUIDs,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get userGroupsUIDs => $composableBuilder(
      column: $table.userGroupsUIDs,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get userFormsUIDs => $composableBuilder(
      column: $table.userFormsUIDs,
      builder: (column) => ColumnOrderings(column));
}

class $$UsersTableAnnotationComposer
    extends Composer<_$AppDatabase, $UsersTable> {
  $$UsersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate, builder: (column) => column);

  GeneratedColumn<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => column);

  GeneratedColumn<String> get username =>
      $composableBuilder(column: $table.username, builder: (column) => column);

  GeneratedColumn<String> get firstName =>
      $composableBuilder(column: $table.firstName, builder: (column) => column);

  GeneratedColumn<String> get lastName =>
      $composableBuilder(column: $table.lastName, builder: (column) => column);

  GeneratedColumn<String> get mobile =>
      $composableBuilder(column: $table.mobile, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<String> get langKey =>
      $composableBuilder(column: $table.langKey, builder: (column) => column);

  GeneratedColumn<bool> get activated =>
      $composableBuilder(column: $table.activated, builder: (column) => column);

  GeneratedColumn<String> get imageUrl =>
      $composableBuilder(column: $table.imageUrl, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<String>, String> get authorities =>
      $composableBuilder(
          column: $table.authorities, builder: (column) => column);

  GeneratedColumn<int> get submissionCount => $composableBuilder(
      column: $table.submissionCount, builder: (column) => column);

  GeneratedColumn<int> get assignmentCount => $composableBuilder(
      column: $table.assignmentCount, builder: (column) => column);

  GeneratedColumn<int> get orgUnitCount => $composableBuilder(
      column: $table.orgUnitCount, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<String>, String> get activityUIDs =>
      $composableBuilder(
          column: $table.activityUIDs, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<String>, String> get userTeamsUIDs =>
      $composableBuilder(
          column: $table.userTeamsUIDs, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<String>, String> get managedTeamsUIDs =>
      $composableBuilder(
          column: $table.managedTeamsUIDs, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<String>, String> get userGroupsUIDs =>
      $composableBuilder(
          column: $table.userGroupsUIDs, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<String>, String> get userFormsUIDs =>
      $composableBuilder(
          column: $table.userFormsUIDs, builder: (column) => column);

  Expression<T> userTeams<T extends Object>(
      Expression<T> Function($$TeamsTableAnnotationComposer a) f) {
    final $$TeamsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.teams,
        getReferencedColumn: (t) => t.user,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$TeamsTableAnnotationComposer(
              $db: $db,
              $table: $db.teams,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> managedTeams<T extends Object>(
      Expression<T> Function($$ManagedTeamsTableAnnotationComposer a) f) {
    final $$ManagedTeamsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.managedTeams,
        getReferencedColumn: (t) => t.user,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ManagedTeamsTableAnnotationComposer(
              $db: $db,
              $table: $db.managedTeams,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$UsersTableTableManager extends RootTableManager<
    _$AppDatabase,
    $UsersTable,
    User,
    $$UsersTableFilterComposer,
    $$UsersTableOrderingComposer,
    $$UsersTableAnnotationComposer,
    $$UsersTableCreateCompanionBuilder,
    $$UsersTableUpdateCompanionBuilder,
    (User, $$UsersTableReferences),
    User,
    PrefetchHooks Function({bool userTeams, bool managedTeams})> {
  $$UsersTableTableManager(_$AppDatabase db, $UsersTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$UsersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$UsersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$UsersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String> username = const Value.absent(),
            Value<String?> firstName = const Value.absent(),
            Value<String?> lastName = const Value.absent(),
            Value<String?> mobile = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<String?> langKey = const Value.absent(),
            Value<bool> activated = const Value.absent(),
            Value<String?> imageUrl = const Value.absent(),
            Value<List<String>> authorities = const Value.absent(),
            Value<int?> submissionCount = const Value.absent(),
            Value<int?> assignmentCount = const Value.absent(),
            Value<int?> orgUnitCount = const Value.absent(),
            Value<List<String>> activityUIDs = const Value.absent(),
            Value<List<String>> userTeamsUIDs = const Value.absent(),
            Value<List<String>> managedTeamsUIDs = const Value.absent(),
            Value<List<String>> userGroupsUIDs = const Value.absent(),
            Value<List<String>> userFormsUIDs = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              UsersCompanion(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            username: username,
            firstName: firstName,
            lastName: lastName,
            mobile: mobile,
            email: email,
            langKey: langKey,
            activated: activated,
            imageUrl: imageUrl,
            authorities: authorities,
            submissionCount: submissionCount,
            assignmentCount: assignmentCount,
            orgUnitCount: orgUnitCount,
            activityUIDs: activityUIDs,
            userTeamsUIDs: userTeamsUIDs,
            managedTeamsUIDs: managedTeamsUIDs,
            userGroupsUIDs: userGroupsUIDs,
            userFormsUIDs: userFormsUIDs,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            required String username,
            Value<String?> firstName = const Value.absent(),
            Value<String?> lastName = const Value.absent(),
            Value<String?> mobile = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<String?> langKey = const Value.absent(),
            Value<bool> activated = const Value.absent(),
            Value<String?> imageUrl = const Value.absent(),
            required List<String> authorities,
            Value<int?> submissionCount = const Value.absent(),
            Value<int?> assignmentCount = const Value.absent(),
            Value<int?> orgUnitCount = const Value.absent(),
            required List<String> activityUIDs,
            required List<String> userTeamsUIDs,
            required List<String> managedTeamsUIDs,
            required List<String> userGroupsUIDs,
            required List<String> userFormsUIDs,
            Value<int> rowid = const Value.absent(),
          }) =>
              UsersCompanion.insert(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            username: username,
            firstName: firstName,
            lastName: lastName,
            mobile: mobile,
            email: email,
            langKey: langKey,
            activated: activated,
            imageUrl: imageUrl,
            authorities: authorities,
            submissionCount: submissionCount,
            assignmentCount: assignmentCount,
            orgUnitCount: orgUnitCount,
            activityUIDs: activityUIDs,
            userTeamsUIDs: userTeamsUIDs,
            managedTeamsUIDs: managedTeamsUIDs,
            userGroupsUIDs: userGroupsUIDs,
            userFormsUIDs: userFormsUIDs,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $$UsersTableReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: ({userTeams = false, managedTeams = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (userTeams) db.teams,
                if (managedTeams) db.managedTeams
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (userTeams)
                    await $_getPrefetchedData<User, $UsersTable, Team>(
                        currentTable: table,
                        referencedTable:
                            $$UsersTableReferences._userTeamsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$UsersTableReferences(db, table, p0).userTeams,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) =>
                                referencedItems.where((e) => e.user == item.id),
                        typedResults: items),
                  if (managedTeams)
                    await $_getPrefetchedData<User, $UsersTable, ManagedTeam>(
                        currentTable: table,
                        referencedTable:
                            $$UsersTableReferences._managedTeamsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$UsersTableReferences(db, table, p0).managedTeams,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) =>
                                referencedItems.where((e) => e.user == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$UsersTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $UsersTable,
    User,
    $$UsersTableFilterComposer,
    $$UsersTableOrderingComposer,
    $$UsersTableAnnotationComposer,
    $$UsersTableCreateCompanionBuilder,
    $$UsersTableUpdateCompanionBuilder,
    (User, $$UsersTableReferences),
    User,
    PrefetchHooks Function({bool userTeams, bool managedTeams})>;
typedef $$OrgUnitsTableCreateCompanionBuilder = OrgUnitsCompanion Function({
  required String id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> displayName,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>> translations,
  required String name,
  Value<String?> code,
  required String path,
  required int level,
  Value<String?> parent,
  Value<int> rowid,
});
typedef $$OrgUnitsTableUpdateCompanionBuilder = OrgUnitsCompanion Function({
  Value<String> id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> displayName,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>> translations,
  Value<String> name,
  Value<String?> code,
  Value<String> path,
  Value<int> level,
  Value<String?> parent,
  Value<int> rowid,
});

final class $$OrgUnitsTableReferences
    extends BaseReferences<_$AppDatabase, $OrgUnitsTable, OrgUnit> {
  $$OrgUnitsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $OrgUnitsTable _parentTable(_$AppDatabase db) => db.orgUnits
      .createAlias($_aliasNameGenerator(db.orgUnits.parent, db.orgUnits.id));

  $$OrgUnitsTableProcessedTableManager? get parent {
    final $_column = $_itemColumn<String>('parent');
    if ($_column == null) return null;
    final manager = $$OrgUnitsTableTableManager($_db, $_db.orgUnits)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_parentTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$FlowInstancesTable, List<FlowInstance>>
      _flowInstancesTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
          db.flowInstances,
          aliasName:
              $_aliasNameGenerator(db.orgUnits.id, db.flowInstances.orgUnit));

  $$FlowInstancesTableProcessedTableManager get flowInstances {
    final manager = $$FlowInstancesTableTableManager($_db, $_db.flowInstances)
        .filter((f) => f.orgUnit.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_flowInstancesTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$DataSubmissionsTable, List<DataSubmission>>
      _ouDataInstancesTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
          db.dataSubmissions,
          aliasName:
              $_aliasNameGenerator(db.orgUnits.id, db.dataSubmissions.orgUnit));

  $$DataSubmissionsTableProcessedTableManager get ouDataInstances {
    final manager =
        $$DataSubmissionsTableTableManager($_db, $_db.dataSubmissions)
            .filter((f) => f.orgUnit.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_ouDataInstancesTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$OrgUnitsTableFilterComposer
    extends Composer<_$AppDatabase, $OrgUnitsTable> {
  $$OrgUnitsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<Map<String, dynamic>?, Map<String, dynamic>,
          String>
      get label => $composableBuilder(
          column: $table.label,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnWithTypeConverterFilters<List<Translation>, List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get path => $composableBuilder(
      column: $table.path, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get level => $composableBuilder(
      column: $table.level, builder: (column) => ColumnFilters(column));

  $$OrgUnitsTableFilterComposer get parent {
    final $$OrgUnitsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.parent,
        referencedTable: $db.orgUnits,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrgUnitsTableFilterComposer(
              $db: $db,
              $table: $db.orgUnits,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> flowInstances(
      Expression<bool> Function($$FlowInstancesTableFilterComposer f) f) {
    final $$FlowInstancesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.flowInstances,
        getReferencedColumn: (t) => t.orgUnit,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowInstancesTableFilterComposer(
              $db: $db,
              $table: $db.flowInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> ouDataInstances(
      Expression<bool> Function($$DataSubmissionsTableFilterComposer f) f) {
    final $$DataSubmissionsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.orgUnit,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableFilterComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$OrgUnitsTableOrderingComposer
    extends Composer<_$AppDatabase, $OrgUnitsTable> {
  $$OrgUnitsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get label => $composableBuilder(
      column: $table.label, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get translations => $composableBuilder(
      column: $table.translations,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get path => $composableBuilder(
      column: $table.path, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get level => $composableBuilder(
      column: $table.level, builder: (column) => ColumnOrderings(column));

  $$OrgUnitsTableOrderingComposer get parent {
    final $$OrgUnitsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.parent,
        referencedTable: $db.orgUnits,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrgUnitsTableOrderingComposer(
              $db: $db,
              $table: $db.orgUnits,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$OrgUnitsTableAnnotationComposer
    extends Composer<_$AppDatabase, $OrgUnitsTable> {
  $$OrgUnitsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate, builder: (column) => column);

  GeneratedColumn<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => column);

  GeneratedColumn<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String> get label =>
      $composableBuilder(column: $table.label, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get path =>
      $composableBuilder(column: $table.path, builder: (column) => column);

  GeneratedColumn<int> get level =>
      $composableBuilder(column: $table.level, builder: (column) => column);

  $$OrgUnitsTableAnnotationComposer get parent {
    final $$OrgUnitsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.parent,
        referencedTable: $db.orgUnits,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrgUnitsTableAnnotationComposer(
              $db: $db,
              $table: $db.orgUnits,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> flowInstances<T extends Object>(
      Expression<T> Function($$FlowInstancesTableAnnotationComposer a) f) {
    final $$FlowInstancesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.flowInstances,
        getReferencedColumn: (t) => t.orgUnit,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowInstancesTableAnnotationComposer(
              $db: $db,
              $table: $db.flowInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> ouDataInstances<T extends Object>(
      Expression<T> Function($$DataSubmissionsTableAnnotationComposer a) f) {
    final $$DataSubmissionsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.orgUnit,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableAnnotationComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$OrgUnitsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $OrgUnitsTable,
    OrgUnit,
    $$OrgUnitsTableFilterComposer,
    $$OrgUnitsTableOrderingComposer,
    $$OrgUnitsTableAnnotationComposer,
    $$OrgUnitsTableCreateCompanionBuilder,
    $$OrgUnitsTableUpdateCompanionBuilder,
    (OrgUnit, $$OrgUnitsTableReferences),
    OrgUnit,
    PrefetchHooks Function(
        {bool parent, bool flowInstances, bool ouDataInstances})> {
  $$OrgUnitsTableTableManager(_$AppDatabase db, $OrgUnitsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OrgUnitsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OrgUnitsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OrgUnitsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> displayName = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>> translations = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<String> path = const Value.absent(),
            Value<int> level = const Value.absent(),
            Value<String?> parent = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              OrgUnitsCompanion(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            displayName: displayName,
            label: label,
            translations: translations,
            name: name,
            code: code,
            path: path,
            level: level,
            parent: parent,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> displayName = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>> translations = const Value.absent(),
            required String name,
            Value<String?> code = const Value.absent(),
            required String path,
            required int level,
            Value<String?> parent = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              OrgUnitsCompanion.insert(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            displayName: displayName,
            label: label,
            translations: translations,
            name: name,
            code: code,
            path: path,
            level: level,
            parent: parent,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $$OrgUnitsTableReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: (
              {parent = false,
              flowInstances = false,
              ouDataInstances = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (flowInstances) db.flowInstances,
                if (ouDataInstances) db.dataSubmissions
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (parent) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.parent,
                    referencedTable: $$OrgUnitsTableReferences._parentTable(db),
                    referencedColumn:
                        $$OrgUnitsTableReferences._parentTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (flowInstances)
                    await $_getPrefetchedData<OrgUnit, $OrgUnitsTable,
                            FlowInstance>(
                        currentTable: table,
                        referencedTable:
                            $$OrgUnitsTableReferences._flowInstancesTable(db),
                        managerFromTypedResult: (p0) =>
                            $$OrgUnitsTableReferences(db, table, p0)
                                .flowInstances,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.orgUnit == item.id),
                        typedResults: items),
                  if (ouDataInstances)
                    await $_getPrefetchedData<OrgUnit, $OrgUnitsTable,
                            DataSubmission>(
                        currentTable: table,
                        referencedTable:
                            $$OrgUnitsTableReferences._ouDataInstancesTable(db),
                        managerFromTypedResult: (p0) =>
                            $$OrgUnitsTableReferences(db, table, p0)
                                .ouDataInstances,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.orgUnit == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$OrgUnitsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $OrgUnitsTable,
    OrgUnit,
    $$OrgUnitsTableFilterComposer,
    $$OrgUnitsTableOrderingComposer,
    $$OrgUnitsTableAnnotationComposer,
    $$OrgUnitsTableCreateCompanionBuilder,
    $$OrgUnitsTableUpdateCompanionBuilder,
    (OrgUnit, $$OrgUnitsTableReferences),
    OrgUnit,
    PrefetchHooks Function(
        {bool parent, bool flowInstances, bool ouDataInstances})>;
typedef $$OuLevelsTableCreateCompanionBuilder = OuLevelsCompanion Function({
  required String id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> displayName,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>> translations,
  required String name,
  Value<String?> code,
  required int level,
  Value<int?> offlineLevels,
  Value<int> rowid,
});
typedef $$OuLevelsTableUpdateCompanionBuilder = OuLevelsCompanion Function({
  Value<String> id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> displayName,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>> translations,
  Value<String> name,
  Value<String?> code,
  Value<int> level,
  Value<int?> offlineLevels,
  Value<int> rowid,
});

class $$OuLevelsTableFilterComposer
    extends Composer<_$AppDatabase, $OuLevelsTable> {
  $$OuLevelsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<Map<String, dynamic>?, Map<String, dynamic>,
          String>
      get label => $composableBuilder(
          column: $table.label,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnWithTypeConverterFilters<List<Translation>, List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get level => $composableBuilder(
      column: $table.level, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get offlineLevels => $composableBuilder(
      column: $table.offlineLevels, builder: (column) => ColumnFilters(column));
}

class $$OuLevelsTableOrderingComposer
    extends Composer<_$AppDatabase, $OuLevelsTable> {
  $$OuLevelsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get label => $composableBuilder(
      column: $table.label, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get translations => $composableBuilder(
      column: $table.translations,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get level => $composableBuilder(
      column: $table.level, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get offlineLevels => $composableBuilder(
      column: $table.offlineLevels,
      builder: (column) => ColumnOrderings(column));
}

class $$OuLevelsTableAnnotationComposer
    extends Composer<_$AppDatabase, $OuLevelsTable> {
  $$OuLevelsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate, builder: (column) => column);

  GeneratedColumn<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => column);

  GeneratedColumn<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String> get label =>
      $composableBuilder(column: $table.label, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<int> get level =>
      $composableBuilder(column: $table.level, builder: (column) => column);

  GeneratedColumn<int> get offlineLevels => $composableBuilder(
      column: $table.offlineLevels, builder: (column) => column);
}

class $$OuLevelsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $OuLevelsTable,
    OuLevel,
    $$OuLevelsTableFilterComposer,
    $$OuLevelsTableOrderingComposer,
    $$OuLevelsTableAnnotationComposer,
    $$OuLevelsTableCreateCompanionBuilder,
    $$OuLevelsTableUpdateCompanionBuilder,
    (OuLevel, BaseReferences<_$AppDatabase, $OuLevelsTable, OuLevel>),
    OuLevel,
    PrefetchHooks Function()> {
  $$OuLevelsTableTableManager(_$AppDatabase db, $OuLevelsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OuLevelsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OuLevelsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OuLevelsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> displayName = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>> translations = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<int> level = const Value.absent(),
            Value<int?> offlineLevels = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              OuLevelsCompanion(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            displayName: displayName,
            label: label,
            translations: translations,
            name: name,
            code: code,
            level: level,
            offlineLevels: offlineLevels,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> displayName = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>> translations = const Value.absent(),
            required String name,
            Value<String?> code = const Value.absent(),
            required int level,
            Value<int?> offlineLevels = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              OuLevelsCompanion.insert(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            displayName: displayName,
            label: label,
            translations: translations,
            name: name,
            code: code,
            level: level,
            offlineLevels: offlineLevels,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$OuLevelsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $OuLevelsTable,
    OuLevel,
    $$OuLevelsTableFilterComposer,
    $$OuLevelsTableOrderingComposer,
    $$OuLevelsTableAnnotationComposer,
    $$OuLevelsTableCreateCompanionBuilder,
    $$OuLevelsTableUpdateCompanionBuilder,
    (OuLevel, BaseReferences<_$AppDatabase, $OuLevelsTable, OuLevel>),
    OuLevel,
    PrefetchHooks Function()>;
typedef $$ProjectsTableCreateCompanionBuilder = ProjectsCompanion Function({
  required String id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> displayName,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>> translations,
  required String name,
  Value<String?> code,
  Value<bool> disabled,
  Value<int> rowid,
});
typedef $$ProjectsTableUpdateCompanionBuilder = ProjectsCompanion Function({
  Value<String> id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> displayName,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>> translations,
  Value<String> name,
  Value<String?> code,
  Value<bool> disabled,
  Value<int> rowid,
});

final class $$ProjectsTableReferences
    extends BaseReferences<_$AppDatabase, $ProjectsTable, Project> {
  $$ProjectsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$ActivitiesTable, List<Activity>>
      _activitiesRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.activities,
              aliasName:
                  $_aliasNameGenerator(db.projects.id, db.activities.project));

  $$ActivitiesTableProcessedTableManager get activitiesRefs {
    final manager = $$ActivitiesTableTableManager($_db, $_db.activities)
        .filter((f) => f.project.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_activitiesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$ProjectsTableFilterComposer
    extends Composer<_$AppDatabase, $ProjectsTable> {
  $$ProjectsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<Map<String, dynamic>?, Map<String, dynamic>,
          String>
      get label => $composableBuilder(
          column: $table.label,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnWithTypeConverterFilters<List<Translation>, List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get disabled => $composableBuilder(
      column: $table.disabled, builder: (column) => ColumnFilters(column));

  Expression<bool> activitiesRefs(
      Expression<bool> Function($$ActivitiesTableFilterComposer f) f) {
    final $$ActivitiesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.activities,
        getReferencedColumn: (t) => t.project,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ActivitiesTableFilterComposer(
              $db: $db,
              $table: $db.activities,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$ProjectsTableOrderingComposer
    extends Composer<_$AppDatabase, $ProjectsTable> {
  $$ProjectsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get label => $composableBuilder(
      column: $table.label, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get translations => $composableBuilder(
      column: $table.translations,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get disabled => $composableBuilder(
      column: $table.disabled, builder: (column) => ColumnOrderings(column));
}

class $$ProjectsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ProjectsTable> {
  $$ProjectsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate, builder: (column) => column);

  GeneratedColumn<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => column);

  GeneratedColumn<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String> get label =>
      $composableBuilder(column: $table.label, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<bool> get disabled =>
      $composableBuilder(column: $table.disabled, builder: (column) => column);

  Expression<T> activitiesRefs<T extends Object>(
      Expression<T> Function($$ActivitiesTableAnnotationComposer a) f) {
    final $$ActivitiesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.activities,
        getReferencedColumn: (t) => t.project,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ActivitiesTableAnnotationComposer(
              $db: $db,
              $table: $db.activities,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$ProjectsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ProjectsTable,
    Project,
    $$ProjectsTableFilterComposer,
    $$ProjectsTableOrderingComposer,
    $$ProjectsTableAnnotationComposer,
    $$ProjectsTableCreateCompanionBuilder,
    $$ProjectsTableUpdateCompanionBuilder,
    (Project, $$ProjectsTableReferences),
    Project,
    PrefetchHooks Function({bool activitiesRefs})> {
  $$ProjectsTableTableManager(_$AppDatabase db, $ProjectsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ProjectsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ProjectsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ProjectsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> displayName = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>> translations = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<bool> disabled = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ProjectsCompanion(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            displayName: displayName,
            label: label,
            translations: translations,
            name: name,
            code: code,
            disabled: disabled,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> displayName = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>> translations = const Value.absent(),
            required String name,
            Value<String?> code = const Value.absent(),
            Value<bool> disabled = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ProjectsCompanion.insert(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            displayName: displayName,
            label: label,
            translations: translations,
            name: name,
            code: code,
            disabled: disabled,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $$ProjectsTableReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: ({activitiesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (activitiesRefs) db.activities],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (activitiesRefs)
                    await $_getPrefetchedData<Project, $ProjectsTable,
                            Activity>(
                        currentTable: table,
                        referencedTable:
                            $$ProjectsTableReferences._activitiesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ProjectsTableReferences(db, table, p0)
                                .activitiesRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.project == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$ProjectsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ProjectsTable,
    Project,
    $$ProjectsTableFilterComposer,
    $$ProjectsTableOrderingComposer,
    $$ProjectsTableAnnotationComposer,
    $$ProjectsTableCreateCompanionBuilder,
    $$ProjectsTableUpdateCompanionBuilder,
    (Project, $$ProjectsTableReferences),
    Project,
    PrefetchHooks Function({bool activitiesRefs})>;
typedef $$ActivitiesTableCreateCompanionBuilder = ActivitiesCompanion Function({
  required String id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> displayName,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>> translations,
  required String name,
  Value<String?> code,
  required String project,
  Value<bool> disabled,
  Value<DateTime?> startDate,
  Value<DateTime?> endDate,
  Value<String?> description,
  Value<int> rowid,
});
typedef $$ActivitiesTableUpdateCompanionBuilder = ActivitiesCompanion Function({
  Value<String> id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> displayName,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>> translations,
  Value<String> name,
  Value<String?> code,
  Value<String> project,
  Value<bool> disabled,
  Value<DateTime?> startDate,
  Value<DateTime?> endDate,
  Value<String?> description,
  Value<int> rowid,
});

final class $$ActivitiesTableReferences
    extends BaseReferences<_$AppDatabase, $ActivitiesTable, Activity> {
  $$ActivitiesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ProjectsTable _projectTable(_$AppDatabase db) => db.projects
      .createAlias($_aliasNameGenerator(db.activities.project, db.projects.id));

  $$ProjectsTableProcessedTableManager get project {
    final $_column = $_itemColumn<String>('project')!;

    final manager = $$ProjectsTableTableManager($_db, $_db.projects)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_projectTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$TeamsTable, List<Team>> _activityTeamsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.teams,
          aliasName: $_aliasNameGenerator(db.activities.id, db.teams.activity));

  $$TeamsTableProcessedTableManager get activityTeams {
    final manager = $$TeamsTableTableManager($_db, $_db.teams)
        .filter((f) => f.activity.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_activityTeamsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$ManagedTeamsTable, List<ManagedTeam>>
      _activityManagedTeamsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.managedTeams,
              aliasName: $_aliasNameGenerator(
                  db.activities.id, db.managedTeams.activity));

  $$ManagedTeamsTableProcessedTableManager get activityManagedTeams {
    final manager = $$ManagedTeamsTableTableManager($_db, $_db.managedTeams)
        .filter((f) => f.activity.id.sqlEquals($_itemColumn<String>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_activityManagedTeamsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$FlowTypesTable, List<FlowType>>
      _activityFlowsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
          db.flowTypes,
          aliasName:
              $_aliasNameGenerator(db.activities.id, db.flowTypes.activity));

  $$FlowTypesTableProcessedTableManager get activityFlows {
    final manager = $$FlowTypesTableTableManager($_db, $_db.flowTypes)
        .filter((f) => f.activity.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_activityFlowsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$FlowInstancesTable, List<FlowInstance>>
      _flowInstancesTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.flowInstances,
              aliasName: $_aliasNameGenerator(
                  db.activities.id, db.flowInstances.activity));

  $$FlowInstancesTableProcessedTableManager get flowInstances {
    final manager = $$FlowInstancesTableTableManager($_db, $_db.flowInstances)
        .filter((f) => f.activity.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_flowInstancesTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$ActivitiesTableFilterComposer
    extends Composer<_$AppDatabase, $ActivitiesTable> {
  $$ActivitiesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<Map<String, dynamic>?, Map<String, dynamic>,
          String>
      get label => $composableBuilder(
          column: $table.label,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnWithTypeConverterFilters<List<Translation>, List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get disabled => $composableBuilder(
      column: $table.disabled, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get startDate => $composableBuilder(
      column: $table.startDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get endDate => $composableBuilder(
      column: $table.endDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnFilters(column));

  $$ProjectsTableFilterComposer get project {
    final $$ProjectsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.project,
        referencedTable: $db.projects,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ProjectsTableFilterComposer(
              $db: $db,
              $table: $db.projects,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> activityTeams(
      Expression<bool> Function($$TeamsTableFilterComposer f) f) {
    final $$TeamsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.teams,
        getReferencedColumn: (t) => t.activity,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$TeamsTableFilterComposer(
              $db: $db,
              $table: $db.teams,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> activityManagedTeams(
      Expression<bool> Function($$ManagedTeamsTableFilterComposer f) f) {
    final $$ManagedTeamsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.managedTeams,
        getReferencedColumn: (t) => t.activity,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ManagedTeamsTableFilterComposer(
              $db: $db,
              $table: $db.managedTeams,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> activityFlows(
      Expression<bool> Function($$FlowTypesTableFilterComposer f) f) {
    final $$FlowTypesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.flowTypes,
        getReferencedColumn: (t) => t.activity,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowTypesTableFilterComposer(
              $db: $db,
              $table: $db.flowTypes,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> flowInstances(
      Expression<bool> Function($$FlowInstancesTableFilterComposer f) f) {
    final $$FlowInstancesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.flowInstances,
        getReferencedColumn: (t) => t.activity,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowInstancesTableFilterComposer(
              $db: $db,
              $table: $db.flowInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$ActivitiesTableOrderingComposer
    extends Composer<_$AppDatabase, $ActivitiesTable> {
  $$ActivitiesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get label => $composableBuilder(
      column: $table.label, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get translations => $composableBuilder(
      column: $table.translations,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get disabled => $composableBuilder(
      column: $table.disabled, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get startDate => $composableBuilder(
      column: $table.startDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get endDate => $composableBuilder(
      column: $table.endDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnOrderings(column));

  $$ProjectsTableOrderingComposer get project {
    final $$ProjectsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.project,
        referencedTable: $db.projects,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ProjectsTableOrderingComposer(
              $db: $db,
              $table: $db.projects,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ActivitiesTableAnnotationComposer
    extends Composer<_$AppDatabase, $ActivitiesTable> {
  $$ActivitiesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate, builder: (column) => column);

  GeneratedColumn<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => column);

  GeneratedColumn<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String> get label =>
      $composableBuilder(column: $table.label, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<bool> get disabled =>
      $composableBuilder(column: $table.disabled, builder: (column) => column);

  GeneratedColumn<DateTime> get startDate =>
      $composableBuilder(column: $table.startDate, builder: (column) => column);

  GeneratedColumn<DateTime> get endDate =>
      $composableBuilder(column: $table.endDate, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => column);

  $$ProjectsTableAnnotationComposer get project {
    final $$ProjectsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.project,
        referencedTable: $db.projects,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ProjectsTableAnnotationComposer(
              $db: $db,
              $table: $db.projects,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> activityTeams<T extends Object>(
      Expression<T> Function($$TeamsTableAnnotationComposer a) f) {
    final $$TeamsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.teams,
        getReferencedColumn: (t) => t.activity,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$TeamsTableAnnotationComposer(
              $db: $db,
              $table: $db.teams,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> activityManagedTeams<T extends Object>(
      Expression<T> Function($$ManagedTeamsTableAnnotationComposer a) f) {
    final $$ManagedTeamsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.managedTeams,
        getReferencedColumn: (t) => t.activity,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ManagedTeamsTableAnnotationComposer(
              $db: $db,
              $table: $db.managedTeams,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> activityFlows<T extends Object>(
      Expression<T> Function($$FlowTypesTableAnnotationComposer a) f) {
    final $$FlowTypesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.flowTypes,
        getReferencedColumn: (t) => t.activity,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowTypesTableAnnotationComposer(
              $db: $db,
              $table: $db.flowTypes,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> flowInstances<T extends Object>(
      Expression<T> Function($$FlowInstancesTableAnnotationComposer a) f) {
    final $$FlowInstancesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.flowInstances,
        getReferencedColumn: (t) => t.activity,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowInstancesTableAnnotationComposer(
              $db: $db,
              $table: $db.flowInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$ActivitiesTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ActivitiesTable,
    Activity,
    $$ActivitiesTableFilterComposer,
    $$ActivitiesTableOrderingComposer,
    $$ActivitiesTableAnnotationComposer,
    $$ActivitiesTableCreateCompanionBuilder,
    $$ActivitiesTableUpdateCompanionBuilder,
    (Activity, $$ActivitiesTableReferences),
    Activity,
    PrefetchHooks Function(
        {bool project,
        bool activityTeams,
        bool activityManagedTeams,
        bool activityFlows,
        bool flowInstances})> {
  $$ActivitiesTableTableManager(_$AppDatabase db, $ActivitiesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ActivitiesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ActivitiesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ActivitiesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> displayName = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>> translations = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<String> project = const Value.absent(),
            Value<bool> disabled = const Value.absent(),
            Value<DateTime?> startDate = const Value.absent(),
            Value<DateTime?> endDate = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ActivitiesCompanion(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            displayName: displayName,
            label: label,
            translations: translations,
            name: name,
            code: code,
            project: project,
            disabled: disabled,
            startDate: startDate,
            endDate: endDate,
            description: description,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> displayName = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>> translations = const Value.absent(),
            required String name,
            Value<String?> code = const Value.absent(),
            required String project,
            Value<bool> disabled = const Value.absent(),
            Value<DateTime?> startDate = const Value.absent(),
            Value<DateTime?> endDate = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ActivitiesCompanion.insert(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            displayName: displayName,
            label: label,
            translations: translations,
            name: name,
            code: code,
            project: project,
            disabled: disabled,
            startDate: startDate,
            endDate: endDate,
            description: description,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$ActivitiesTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {project = false,
              activityTeams = false,
              activityManagedTeams = false,
              activityFlows = false,
              flowInstances = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (activityTeams) db.teams,
                if (activityManagedTeams) db.managedTeams,
                if (activityFlows) db.flowTypes,
                if (flowInstances) db.flowInstances
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (project) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.project,
                    referencedTable:
                        $$ActivitiesTableReferences._projectTable(db),
                    referencedColumn:
                        $$ActivitiesTableReferences._projectTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (activityTeams)
                    await $_getPrefetchedData<Activity, $ActivitiesTable, Team>(
                        currentTable: table,
                        referencedTable:
                            $$ActivitiesTableReferences._activityTeamsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ActivitiesTableReferences(db, table, p0)
                                .activityTeams,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.activity == item.id),
                        typedResults: items),
                  if (activityManagedTeams)
                    await $_getPrefetchedData<Activity, $ActivitiesTable,
                            ManagedTeam>(
                        currentTable: table,
                        referencedTable: $$ActivitiesTableReferences
                            ._activityManagedTeamsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ActivitiesTableReferences(db, table, p0)
                                .activityManagedTeams,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.activity == item.id),
                        typedResults: items),
                  if (activityFlows)
                    await $_getPrefetchedData<Activity, $ActivitiesTable,
                            FlowType>(
                        currentTable: table,
                        referencedTable:
                            $$ActivitiesTableReferences._activityFlowsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ActivitiesTableReferences(db, table, p0)
                                .activityFlows,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.activity == item.id),
                        typedResults: items),
                  if (flowInstances)
                    await $_getPrefetchedData<Activity, $ActivitiesTable,
                            FlowInstance>(
                        currentTable: table,
                        referencedTable:
                            $$ActivitiesTableReferences._flowInstancesTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ActivitiesTableReferences(db, table, p0)
                                .flowInstances,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.activity == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$ActivitiesTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ActivitiesTable,
    Activity,
    $$ActivitiesTableFilterComposer,
    $$ActivitiesTableOrderingComposer,
    $$ActivitiesTableAnnotationComposer,
    $$ActivitiesTableCreateCompanionBuilder,
    $$ActivitiesTableUpdateCompanionBuilder,
    (Activity, $$ActivitiesTableReferences),
    Activity,
    PrefetchHooks Function(
        {bool project,
        bool activityTeams,
        bool activityManagedTeams,
        bool activityFlows,
        bool flowInstances})>;
typedef $$TeamsTableCreateCompanionBuilder = TeamsCompanion Function({
  required String id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> code,
  Value<bool?> disabled,
  required String activity,
  required String user,
  Value<int> rowid,
});
typedef $$TeamsTableUpdateCompanionBuilder = TeamsCompanion Function({
  Value<String> id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> code,
  Value<bool?> disabled,
  Value<String> activity,
  Value<String> user,
  Value<int> rowid,
});

final class $$TeamsTableReferences
    extends BaseReferences<_$AppDatabase, $TeamsTable, Team> {
  $$TeamsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ActivitiesTable _activityTable(_$AppDatabase db) => db.activities
      .createAlias($_aliasNameGenerator(db.teams.activity, db.activities.id));

  $$ActivitiesTableProcessedTableManager get activity {
    final $_column = $_itemColumn<String>('activity')!;

    final manager = $$ActivitiesTableTableManager($_db, $_db.activities)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_activityTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $UsersTable _userTable(_$AppDatabase db) =>
      db.users.createAlias($_aliasNameGenerator(db.teams.user, db.users.id));

  $$UsersTableProcessedTableManager get user {
    final $_column = $_itemColumn<String>('user')!;

    final manager = $$UsersTableTableManager($_db, $_db.users)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$FlowInstancesTable, List<FlowInstance>>
      _flowInstancesTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
          db.flowInstances,
          aliasName: $_aliasNameGenerator(db.teams.id, db.flowInstances.team));

  $$FlowInstancesTableProcessedTableManager get flowInstances {
    final manager = $$FlowInstancesTableTableManager($_db, $_db.flowInstances)
        .filter((f) => f.team.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_flowInstancesTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$DataSubmissionsTable, List<DataSubmission>>
      _teamDataInstancesTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.dataSubmissions,
              aliasName:
                  $_aliasNameGenerator(db.teams.id, db.dataSubmissions.team));

  $$DataSubmissionsTableProcessedTableManager get teamDataInstances {
    final manager =
        $$DataSubmissionsTableTableManager($_db, $_db.dataSubmissions)
            .filter((f) => f.team.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_teamDataInstancesTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$UserFormPermissionsTable,
      List<UserFormPermission>> _teamFormPermissionsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.userFormPermissions,
          aliasName:
              $_aliasNameGenerator(db.teams.id, db.userFormPermissions.team));

  $$UserFormPermissionsTableProcessedTableManager get teamFormPermissions {
    final manager =
        $$UserFormPermissionsTableTableManager($_db, $_db.userFormPermissions)
            .filter((f) => f.team.id.sqlEquals($_itemColumn<String>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_teamFormPermissionsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$TeamsTableFilterComposer extends Composer<_$AppDatabase, $TeamsTable> {
  $$TeamsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get disabled => $composableBuilder(
      column: $table.disabled, builder: (column) => ColumnFilters(column));

  $$ActivitiesTableFilterComposer get activity {
    final $$ActivitiesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.activity,
        referencedTable: $db.activities,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ActivitiesTableFilterComposer(
              $db: $db,
              $table: $db.activities,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$UsersTableFilterComposer get user {
    final $$UsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.user,
        referencedTable: $db.users,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$UsersTableFilterComposer(
              $db: $db,
              $table: $db.users,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> flowInstances(
      Expression<bool> Function($$FlowInstancesTableFilterComposer f) f) {
    final $$FlowInstancesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.flowInstances,
        getReferencedColumn: (t) => t.team,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowInstancesTableFilterComposer(
              $db: $db,
              $table: $db.flowInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> teamDataInstances(
      Expression<bool> Function($$DataSubmissionsTableFilterComposer f) f) {
    final $$DataSubmissionsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.team,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableFilterComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> teamFormPermissions(
      Expression<bool> Function($$UserFormPermissionsTableFilterComposer f) f) {
    final $$UserFormPermissionsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.userFormPermissions,
        getReferencedColumn: (t) => t.team,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$UserFormPermissionsTableFilterComposer(
              $db: $db,
              $table: $db.userFormPermissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$TeamsTableOrderingComposer
    extends Composer<_$AppDatabase, $TeamsTable> {
  $$TeamsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get disabled => $composableBuilder(
      column: $table.disabled, builder: (column) => ColumnOrderings(column));

  $$ActivitiesTableOrderingComposer get activity {
    final $$ActivitiesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.activity,
        referencedTable: $db.activities,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ActivitiesTableOrderingComposer(
              $db: $db,
              $table: $db.activities,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$UsersTableOrderingComposer get user {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.user,
        referencedTable: $db.users,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$UsersTableOrderingComposer(
              $db: $db,
              $table: $db.users,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$TeamsTableAnnotationComposer
    extends Composer<_$AppDatabase, $TeamsTable> {
  $$TeamsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate, builder: (column) => column);

  GeneratedColumn<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<bool> get disabled =>
      $composableBuilder(column: $table.disabled, builder: (column) => column);

  $$ActivitiesTableAnnotationComposer get activity {
    final $$ActivitiesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.activity,
        referencedTable: $db.activities,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ActivitiesTableAnnotationComposer(
              $db: $db,
              $table: $db.activities,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$UsersTableAnnotationComposer get user {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.user,
        referencedTable: $db.users,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$UsersTableAnnotationComposer(
              $db: $db,
              $table: $db.users,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> flowInstances<T extends Object>(
      Expression<T> Function($$FlowInstancesTableAnnotationComposer a) f) {
    final $$FlowInstancesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.flowInstances,
        getReferencedColumn: (t) => t.team,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowInstancesTableAnnotationComposer(
              $db: $db,
              $table: $db.flowInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> teamDataInstances<T extends Object>(
      Expression<T> Function($$DataSubmissionsTableAnnotationComposer a) f) {
    final $$DataSubmissionsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.team,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableAnnotationComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> teamFormPermissions<T extends Object>(
      Expression<T> Function($$UserFormPermissionsTableAnnotationComposer a)
          f) {
    final $$UserFormPermissionsTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.userFormPermissions,
            getReferencedColumn: (t) => t.team,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$UserFormPermissionsTableAnnotationComposer(
                  $db: $db,
                  $table: $db.userFormPermissions,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$TeamsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $TeamsTable,
    Team,
    $$TeamsTableFilterComposer,
    $$TeamsTableOrderingComposer,
    $$TeamsTableAnnotationComposer,
    $$TeamsTableCreateCompanionBuilder,
    $$TeamsTableUpdateCompanionBuilder,
    (Team, $$TeamsTableReferences),
    Team,
    PrefetchHooks Function(
        {bool activity,
        bool user,
        bool flowInstances,
        bool teamDataInstances,
        bool teamFormPermissions})> {
  $$TeamsTableTableManager(_$AppDatabase db, $TeamsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$TeamsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$TeamsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$TeamsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<bool?> disabled = const Value.absent(),
            Value<String> activity = const Value.absent(),
            Value<String> user = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              TeamsCompanion(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            code: code,
            disabled: disabled,
            activity: activity,
            user: user,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<bool?> disabled = const Value.absent(),
            required String activity,
            required String user,
            Value<int> rowid = const Value.absent(),
          }) =>
              TeamsCompanion.insert(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            code: code,
            disabled: disabled,
            activity: activity,
            user: user,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $$TeamsTableReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: (
              {activity = false,
              user = false,
              flowInstances = false,
              teamDataInstances = false,
              teamFormPermissions = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (flowInstances) db.flowInstances,
                if (teamDataInstances) db.dataSubmissions,
                if (teamFormPermissions) db.userFormPermissions
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (activity) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.activity,
                    referencedTable: $$TeamsTableReferences._activityTable(db),
                    referencedColumn:
                        $$TeamsTableReferences._activityTable(db).id,
                  ) as T;
                }
                if (user) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.user,
                    referencedTable: $$TeamsTableReferences._userTable(db),
                    referencedColumn: $$TeamsTableReferences._userTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (flowInstances)
                    await $_getPrefetchedData<Team, $TeamsTable, FlowInstance>(
                        currentTable: table,
                        referencedTable:
                            $$TeamsTableReferences._flowInstancesTable(db),
                        managerFromTypedResult: (p0) =>
                            $$TeamsTableReferences(db, table, p0).flowInstances,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) =>
                                referencedItems.where((e) => e.team == item.id),
                        typedResults: items),
                  if (teamDataInstances)
                    await $_getPrefetchedData<Team, $TeamsTable,
                            DataSubmission>(
                        currentTable: table,
                        referencedTable:
                            $$TeamsTableReferences._teamDataInstancesTable(db),
                        managerFromTypedResult: (p0) =>
                            $$TeamsTableReferences(db, table, p0)
                                .teamDataInstances,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) =>
                                referencedItems.where((e) => e.team == item.id),
                        typedResults: items),
                  if (teamFormPermissions)
                    await $_getPrefetchedData<Team, $TeamsTable,
                            UserFormPermission>(
                        currentTable: table,
                        referencedTable: $$TeamsTableReferences
                            ._teamFormPermissionsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$TeamsTableReferences(db, table, p0)
                                .teamFormPermissions,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) =>
                                referencedItems.where((e) => e.team == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$TeamsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $TeamsTable,
    Team,
    $$TeamsTableFilterComposer,
    $$TeamsTableOrderingComposer,
    $$TeamsTableAnnotationComposer,
    $$TeamsTableCreateCompanionBuilder,
    $$TeamsTableUpdateCompanionBuilder,
    (Team, $$TeamsTableReferences),
    Team,
    PrefetchHooks Function(
        {bool activity,
        bool user,
        bool flowInstances,
        bool teamDataInstances,
        bool teamFormPermissions})>;
typedef $$ManagedTeamsTableCreateCompanionBuilder = ManagedTeamsCompanion
    Function({
  required String id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> code,
  Value<bool?> disabled,
  required String activity,
  required String user,
  Value<List<dynamic>> teamUsers,
  Value<int> rowid,
});
typedef $$ManagedTeamsTableUpdateCompanionBuilder = ManagedTeamsCompanion
    Function({
  Value<String> id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> code,
  Value<bool?> disabled,
  Value<String> activity,
  Value<String> user,
  Value<List<dynamic>> teamUsers,
  Value<int> rowid,
});

final class $$ManagedTeamsTableReferences
    extends BaseReferences<_$AppDatabase, $ManagedTeamsTable, ManagedTeam> {
  $$ManagedTeamsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ActivitiesTable _activityTable(_$AppDatabase db) =>
      db.activities.createAlias(
          $_aliasNameGenerator(db.managedTeams.activity, db.activities.id));

  $$ActivitiesTableProcessedTableManager get activity {
    final $_column = $_itemColumn<String>('activity')!;

    final manager = $$ActivitiesTableTableManager($_db, $_db.activities)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_activityTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $UsersTable _userTable(_$AppDatabase db) => db.users
      .createAlias($_aliasNameGenerator(db.managedTeams.user, db.users.id));

  $$UsersTableProcessedTableManager get user {
    final $_column = $_itemColumn<String>('user')!;

    final manager = $$UsersTableTableManager($_db, $_db.users)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$ManagedTeamsTableFilterComposer
    extends Composer<_$AppDatabase, $ManagedTeamsTable> {
  $$ManagedTeamsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get disabled => $composableBuilder(
      column: $table.disabled, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<List<dynamic>, List<dynamic>, String>
      get teamUsers => $composableBuilder(
          column: $table.teamUsers,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  $$ActivitiesTableFilterComposer get activity {
    final $$ActivitiesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.activity,
        referencedTable: $db.activities,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ActivitiesTableFilterComposer(
              $db: $db,
              $table: $db.activities,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$UsersTableFilterComposer get user {
    final $$UsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.user,
        referencedTable: $db.users,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$UsersTableFilterComposer(
              $db: $db,
              $table: $db.users,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ManagedTeamsTableOrderingComposer
    extends Composer<_$AppDatabase, $ManagedTeamsTable> {
  $$ManagedTeamsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get disabled => $composableBuilder(
      column: $table.disabled, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get teamUsers => $composableBuilder(
      column: $table.teamUsers, builder: (column) => ColumnOrderings(column));

  $$ActivitiesTableOrderingComposer get activity {
    final $$ActivitiesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.activity,
        referencedTable: $db.activities,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ActivitiesTableOrderingComposer(
              $db: $db,
              $table: $db.activities,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$UsersTableOrderingComposer get user {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.user,
        referencedTable: $db.users,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$UsersTableOrderingComposer(
              $db: $db,
              $table: $db.users,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ManagedTeamsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ManagedTeamsTable> {
  $$ManagedTeamsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate, builder: (column) => column);

  GeneratedColumn<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<bool> get disabled =>
      $composableBuilder(column: $table.disabled, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<dynamic>, String> get teamUsers =>
      $composableBuilder(column: $table.teamUsers, builder: (column) => column);

  $$ActivitiesTableAnnotationComposer get activity {
    final $$ActivitiesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.activity,
        referencedTable: $db.activities,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ActivitiesTableAnnotationComposer(
              $db: $db,
              $table: $db.activities,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$UsersTableAnnotationComposer get user {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.user,
        referencedTable: $db.users,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$UsersTableAnnotationComposer(
              $db: $db,
              $table: $db.users,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ManagedTeamsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ManagedTeamsTable,
    ManagedTeam,
    $$ManagedTeamsTableFilterComposer,
    $$ManagedTeamsTableOrderingComposer,
    $$ManagedTeamsTableAnnotationComposer,
    $$ManagedTeamsTableCreateCompanionBuilder,
    $$ManagedTeamsTableUpdateCompanionBuilder,
    (ManagedTeam, $$ManagedTeamsTableReferences),
    ManagedTeam,
    PrefetchHooks Function({bool activity, bool user})> {
  $$ManagedTeamsTableTableManager(_$AppDatabase db, $ManagedTeamsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ManagedTeamsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ManagedTeamsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ManagedTeamsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<bool?> disabled = const Value.absent(),
            Value<String> activity = const Value.absent(),
            Value<String> user = const Value.absent(),
            Value<List<dynamic>> teamUsers = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ManagedTeamsCompanion(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            code: code,
            disabled: disabled,
            activity: activity,
            user: user,
            teamUsers: teamUsers,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<bool?> disabled = const Value.absent(),
            required String activity,
            required String user,
            Value<List<dynamic>> teamUsers = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ManagedTeamsCompanion.insert(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            code: code,
            disabled: disabled,
            activity: activity,
            user: user,
            teamUsers: teamUsers,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$ManagedTeamsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({activity = false, user = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (activity) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.activity,
                    referencedTable:
                        $$ManagedTeamsTableReferences._activityTable(db),
                    referencedColumn:
                        $$ManagedTeamsTableReferences._activityTable(db).id,
                  ) as T;
                }
                if (user) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.user,
                    referencedTable:
                        $$ManagedTeamsTableReferences._userTable(db),
                    referencedColumn:
                        $$ManagedTeamsTableReferences._userTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$ManagedTeamsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ManagedTeamsTable,
    ManagedTeam,
    $$ManagedTeamsTableFilterComposer,
    $$ManagedTeamsTableOrderingComposer,
    $$ManagedTeamsTableAnnotationComposer,
    $$ManagedTeamsTableCreateCompanionBuilder,
    $$ManagedTeamsTableUpdateCompanionBuilder,
    (ManagedTeam, $$ManagedTeamsTableReferences),
    ManagedTeam,
    PrefetchHooks Function({bool activity, bool user})>;
typedef $$FlowTypesTableCreateCompanionBuilder = FlowTypesCompanion Function({
  required String id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  required String activity,
  Value<String?> name,
  Value<PlanningMode?> planningMode,
  Value<SubmissionMode?> submissionMode,
  Value<int> rowid,
});
typedef $$FlowTypesTableUpdateCompanionBuilder = FlowTypesCompanion Function({
  Value<String> id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String> activity,
  Value<String?> name,
  Value<PlanningMode?> planningMode,
  Value<SubmissionMode?> submissionMode,
  Value<int> rowid,
});

final class $$FlowTypesTableReferences
    extends BaseReferences<_$AppDatabase, $FlowTypesTable, FlowType> {
  $$FlowTypesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ActivitiesTable _activityTable(_$AppDatabase db) =>
      db.activities.createAlias(
          $_aliasNameGenerator(db.flowTypes.activity, db.activities.id));

  $$ActivitiesTableProcessedTableManager get activity {
    final $_column = $_itemColumn<String>('activity')!;

    final manager = $$ActivitiesTableTableManager($_db, $_db.activities)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_activityTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$FlowInstancesTable, List<FlowInstance>>
      _flowInstancesTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
          db.flowInstances,
          aliasName:
              $_aliasNameGenerator(db.flowTypes.id, db.flowInstances.flowType));

  $$FlowInstancesTableProcessedTableManager get flowInstances {
    final manager = $$FlowInstancesTableTableManager($_db, $_db.flowInstances)
        .filter((f) => f.flowType.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_flowInstancesTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$StageDefinitionsTable, List<StageDefinition>>
      _flowTypeStepTypesTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.stageDefinitions,
              aliasName: $_aliasNameGenerator(
                  db.flowTypes.id, db.stageDefinitions.flowType));

  $$StageDefinitionsTableProcessedTableManager get flowTypeStepTypes {
    final manager = $$StageDefinitionsTableTableManager(
            $_db, $_db.stageDefinitions)
        .filter((f) => f.flowType.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_flowTypeStepTypesTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$DataSubmissionsTable, List<DataSubmission>>
      _dataSubmissionsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.dataSubmissions,
              aliasName: $_aliasNameGenerator(
                  db.flowTypes.id, db.dataSubmissions.flowType));

  $$DataSubmissionsTableProcessedTableManager get dataSubmissionsRefs {
    final manager = $$DataSubmissionsTableTableManager(
            $_db, $_db.dataSubmissions)
        .filter((f) => f.flowType.id.sqlEquals($_itemColumn<String>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_dataSubmissionsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$FlowTypesTableFilterComposer
    extends Composer<_$AppDatabase, $FlowTypesTable> {
  $$FlowTypesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<PlanningMode?, PlanningMode, String>
      get planningMode => $composableBuilder(
          column: $table.planningMode,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnWithTypeConverterFilters<SubmissionMode?, SubmissionMode, String>
      get submissionMode => $composableBuilder(
          column: $table.submissionMode,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  $$ActivitiesTableFilterComposer get activity {
    final $$ActivitiesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.activity,
        referencedTable: $db.activities,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ActivitiesTableFilterComposer(
              $db: $db,
              $table: $db.activities,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> flowInstances(
      Expression<bool> Function($$FlowInstancesTableFilterComposer f) f) {
    final $$FlowInstancesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.flowInstances,
        getReferencedColumn: (t) => t.flowType,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowInstancesTableFilterComposer(
              $db: $db,
              $table: $db.flowInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> flowTypeStepTypes(
      Expression<bool> Function($$StageDefinitionsTableFilterComposer f) f) {
    final $$StageDefinitionsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stageDefinitions,
        getReferencedColumn: (t) => t.flowType,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$StageDefinitionsTableFilterComposer(
              $db: $db,
              $table: $db.stageDefinitions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> dataSubmissionsRefs(
      Expression<bool> Function($$DataSubmissionsTableFilterComposer f) f) {
    final $$DataSubmissionsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.flowType,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableFilterComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$FlowTypesTableOrderingComposer
    extends Composer<_$AppDatabase, $FlowTypesTable> {
  $$FlowTypesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get planningMode => $composableBuilder(
      column: $table.planningMode,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get submissionMode => $composableBuilder(
      column: $table.submissionMode,
      builder: (column) => ColumnOrderings(column));

  $$ActivitiesTableOrderingComposer get activity {
    final $$ActivitiesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.activity,
        referencedTable: $db.activities,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ActivitiesTableOrderingComposer(
              $db: $db,
              $table: $db.activities,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$FlowTypesTableAnnotationComposer
    extends Composer<_$AppDatabase, $FlowTypesTable> {
  $$FlowTypesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate, builder: (column) => column);

  GeneratedColumn<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumnWithTypeConverter<PlanningMode?, String> get planningMode =>
      $composableBuilder(
          column: $table.planningMode, builder: (column) => column);

  GeneratedColumnWithTypeConverter<SubmissionMode?, String>
      get submissionMode => $composableBuilder(
          column: $table.submissionMode, builder: (column) => column);

  $$ActivitiesTableAnnotationComposer get activity {
    final $$ActivitiesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.activity,
        referencedTable: $db.activities,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ActivitiesTableAnnotationComposer(
              $db: $db,
              $table: $db.activities,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> flowInstances<T extends Object>(
      Expression<T> Function($$FlowInstancesTableAnnotationComposer a) f) {
    final $$FlowInstancesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.flowInstances,
        getReferencedColumn: (t) => t.flowType,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowInstancesTableAnnotationComposer(
              $db: $db,
              $table: $db.flowInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> flowTypeStepTypes<T extends Object>(
      Expression<T> Function($$StageDefinitionsTableAnnotationComposer a) f) {
    final $$StageDefinitionsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stageDefinitions,
        getReferencedColumn: (t) => t.flowType,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$StageDefinitionsTableAnnotationComposer(
              $db: $db,
              $table: $db.stageDefinitions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> dataSubmissionsRefs<T extends Object>(
      Expression<T> Function($$DataSubmissionsTableAnnotationComposer a) f) {
    final $$DataSubmissionsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.flowType,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableAnnotationComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$FlowTypesTableTableManager extends RootTableManager<
    _$AppDatabase,
    $FlowTypesTable,
    FlowType,
    $$FlowTypesTableFilterComposer,
    $$FlowTypesTableOrderingComposer,
    $$FlowTypesTableAnnotationComposer,
    $$FlowTypesTableCreateCompanionBuilder,
    $$FlowTypesTableUpdateCompanionBuilder,
    (FlowType, $$FlowTypesTableReferences),
    FlowType,
    PrefetchHooks Function(
        {bool activity,
        bool flowInstances,
        bool flowTypeStepTypes,
        bool dataSubmissionsRefs})> {
  $$FlowTypesTableTableManager(_$AppDatabase db, $FlowTypesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FlowTypesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FlowTypesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FlowTypesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String> activity = const Value.absent(),
            Value<String?> name = const Value.absent(),
            Value<PlanningMode?> planningMode = const Value.absent(),
            Value<SubmissionMode?> submissionMode = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              FlowTypesCompanion(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            activity: activity,
            name: name,
            planningMode: planningMode,
            submissionMode: submissionMode,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            required String activity,
            Value<String?> name = const Value.absent(),
            Value<PlanningMode?> planningMode = const Value.absent(),
            Value<SubmissionMode?> submissionMode = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              FlowTypesCompanion.insert(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            activity: activity,
            name: name,
            planningMode: planningMode,
            submissionMode: submissionMode,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$FlowTypesTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {activity = false,
              flowInstances = false,
              flowTypeStepTypes = false,
              dataSubmissionsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (flowInstances) db.flowInstances,
                if (flowTypeStepTypes) db.stageDefinitions,
                if (dataSubmissionsRefs) db.dataSubmissions
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (activity) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.activity,
                    referencedTable:
                        $$FlowTypesTableReferences._activityTable(db),
                    referencedColumn:
                        $$FlowTypesTableReferences._activityTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (flowInstances)
                    await $_getPrefetchedData<FlowType, $FlowTypesTable,
                            FlowInstance>(
                        currentTable: table,
                        referencedTable:
                            $$FlowTypesTableReferences._flowInstancesTable(db),
                        managerFromTypedResult: (p0) =>
                            $$FlowTypesTableReferences(db, table, p0)
                                .flowInstances,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.flowType == item.id),
                        typedResults: items),
                  if (flowTypeStepTypes)
                    await $_getPrefetchedData<FlowType, $FlowTypesTable,
                            StageDefinition>(
                        currentTable: table,
                        referencedTable: $$FlowTypesTableReferences
                            ._flowTypeStepTypesTable(db),
                        managerFromTypedResult: (p0) =>
                            $$FlowTypesTableReferences(db, table, p0)
                                .flowTypeStepTypes,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.flowType == item.id),
                        typedResults: items),
                  if (dataSubmissionsRefs)
                    await $_getPrefetchedData<FlowType, $FlowTypesTable,
                            DataSubmission>(
                        currentTable: table,
                        referencedTable: $$FlowTypesTableReferences
                            ._dataSubmissionsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$FlowTypesTableReferences(db, table, p0)
                                .dataSubmissionsRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.flowType == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$FlowTypesTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $FlowTypesTable,
    FlowType,
    $$FlowTypesTableFilterComposer,
    $$FlowTypesTableOrderingComposer,
    $$FlowTypesTableAnnotationComposer,
    $$FlowTypesTableCreateCompanionBuilder,
    $$FlowTypesTableUpdateCompanionBuilder,
    (FlowType, $$FlowTypesTableReferences),
    FlowType,
    PrefetchHooks Function(
        {bool activity,
        bool flowInstances,
        bool flowTypeStepTypes,
        bool dataSubmissionsRefs})>;
typedef $$EntityTypesTableCreateCompanionBuilder = EntityTypesCompanion
    Function({
  required String id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> displayName,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>> translations,
  Value<String?> code,
  Value<String?> name,
  required List<Template> entityAttributes,
  Value<int> rowid,
});
typedef $$EntityTypesTableUpdateCompanionBuilder = EntityTypesCompanion
    Function({
  Value<String> id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> displayName,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>> translations,
  Value<String?> code,
  Value<String?> name,
  Value<List<Template>> entityAttributes,
  Value<int> rowid,
});

final class $$EntityTypesTableReferences
    extends BaseReferences<_$AppDatabase, $EntityTypesTable, EntityType> {
  $$EntityTypesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$EntityInstancesTable, List<EntityInstance>>
      _entityInstancesTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.entityInstances,
              aliasName: $_aliasNameGenerator(
                  db.entityTypes.id, db.entityInstances.entityType));

  $$EntityInstancesTableProcessedTableManager get entityInstances {
    final manager = $$EntityInstancesTableTableManager(
            $_db, $_db.entityInstances)
        .filter((f) => f.entityType.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_entityInstancesTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$EntityTypesTableFilterComposer
    extends Composer<_$AppDatabase, $EntityTypesTable> {
  $$EntityTypesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<Map<String, dynamic>?, Map<String, dynamic>,
          String>
      get label => $composableBuilder(
          column: $table.label,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnWithTypeConverterFilters<List<Translation>, List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<List<Template>, List<Template>, String>
      get entityAttributes => $composableBuilder(
          column: $table.entityAttributes,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  Expression<bool> entityInstances(
      Expression<bool> Function($$EntityInstancesTableFilterComposer f) f) {
    final $$EntityInstancesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.entityInstances,
        getReferencedColumn: (t) => t.entityType,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$EntityInstancesTableFilterComposer(
              $db: $db,
              $table: $db.entityInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$EntityTypesTableOrderingComposer
    extends Composer<_$AppDatabase, $EntityTypesTable> {
  $$EntityTypesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get label => $composableBuilder(
      column: $table.label, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get translations => $composableBuilder(
      column: $table.translations,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get entityAttributes => $composableBuilder(
      column: $table.entityAttributes,
      builder: (column) => ColumnOrderings(column));
}

class $$EntityTypesTableAnnotationComposer
    extends Composer<_$AppDatabase, $EntityTypesTable> {
  $$EntityTypesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate, builder: (column) => column);

  GeneratedColumn<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => column);

  GeneratedColumn<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String> get label =>
      $composableBuilder(column: $table.label, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<Template>, String>
      get entityAttributes => $composableBuilder(
          column: $table.entityAttributes, builder: (column) => column);

  Expression<T> entityInstances<T extends Object>(
      Expression<T> Function($$EntityInstancesTableAnnotationComposer a) f) {
    final $$EntityInstancesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.entityInstances,
        getReferencedColumn: (t) => t.entityType,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$EntityInstancesTableAnnotationComposer(
              $db: $db,
              $table: $db.entityInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$EntityTypesTableTableManager extends RootTableManager<
    _$AppDatabase,
    $EntityTypesTable,
    EntityType,
    $$EntityTypesTableFilterComposer,
    $$EntityTypesTableOrderingComposer,
    $$EntityTypesTableAnnotationComposer,
    $$EntityTypesTableCreateCompanionBuilder,
    $$EntityTypesTableUpdateCompanionBuilder,
    (EntityType, $$EntityTypesTableReferences),
    EntityType,
    PrefetchHooks Function({bool entityInstances})> {
  $$EntityTypesTableTableManager(_$AppDatabase db, $EntityTypesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$EntityTypesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$EntityTypesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$EntityTypesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> displayName = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>> translations = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<String?> name = const Value.absent(),
            Value<List<Template>> entityAttributes = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              EntityTypesCompanion(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            displayName: displayName,
            label: label,
            translations: translations,
            code: code,
            name: name,
            entityAttributes: entityAttributes,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> displayName = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>> translations = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<String?> name = const Value.absent(),
            required List<Template> entityAttributes,
            Value<int> rowid = const Value.absent(),
          }) =>
              EntityTypesCompanion.insert(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            displayName: displayName,
            label: label,
            translations: translations,
            code: code,
            name: name,
            entityAttributes: entityAttributes,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$EntityTypesTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({entityInstances = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (entityInstances) db.entityInstances
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (entityInstances)
                    await $_getPrefetchedData<EntityType, $EntityTypesTable,
                            EntityInstance>(
                        currentTable: table,
                        referencedTable: $$EntityTypesTableReferences
                            ._entityInstancesTable(db),
                        managerFromTypedResult: (p0) =>
                            $$EntityTypesTableReferences(db, table, p0)
                                .entityInstances,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.entityType == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$EntityTypesTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $EntityTypesTable,
    EntityType,
    $$EntityTypesTableFilterComposer,
    $$EntityTypesTableOrderingComposer,
    $$EntityTypesTableAnnotationComposer,
    $$EntityTypesTableCreateCompanionBuilder,
    $$EntityTypesTableUpdateCompanionBuilder,
    (EntityType, $$EntityTypesTableReferences),
    EntityType,
    PrefetchHooks Function({bool entityInstances})>;
typedef $$EntityInstancesTableCreateCompanionBuilder = EntityInstancesCompanion
    Function({
  required String id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> displayName,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>> translations,
  Value<String?> uuid,
  required String entityType,
  Value<EntityStatus?> status,
  Value<DateTime?> updatedAtClient,
  Value<DateTime?> createdAtClient,
  Value<Map<String, dynamic>?> identityAttributes,
  required InstanceSyncStatus syncState,
  Value<int> rowid,
});
typedef $$EntityInstancesTableUpdateCompanionBuilder = EntityInstancesCompanion
    Function({
  Value<String> id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> displayName,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>> translations,
  Value<String?> uuid,
  Value<String> entityType,
  Value<EntityStatus?> status,
  Value<DateTime?> updatedAtClient,
  Value<DateTime?> createdAtClient,
  Value<Map<String, dynamic>?> identityAttributes,
  Value<InstanceSyncStatus> syncState,
  Value<int> rowid,
});

final class $$EntityInstancesTableReferences extends BaseReferences<
    _$AppDatabase, $EntityInstancesTable, EntityInstance> {
  $$EntityInstancesTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $EntityTypesTable _entityTypeTable(_$AppDatabase db) =>
      db.entityTypes.createAlias($_aliasNameGenerator(
          db.entityInstances.entityType, db.entityTypes.id));

  $$EntityTypesTableProcessedTableManager get entityType {
    final $_column = $_itemColumn<String>('entity_type')!;

    final manager = $$EntityTypesTableTableManager($_db, $_db.entityTypes)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_entityTypeTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$FlowInstancesTable, List<FlowInstance>>
      _flowInstancesTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.flowInstances,
              aliasName: $_aliasNameGenerator(
                  db.entityInstances.id, db.flowInstances.entityInstance));

  $$FlowInstancesTableProcessedTableManager get flowInstances {
    final manager = $$FlowInstancesTableTableManager($_db, $_db.flowInstances)
        .filter(
            (f) => f.entityInstance.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_flowInstancesTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$DataSubmissionsTable, List<DataSubmission>>
      _entityInstanceDataTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.dataSubmissions,
              aliasName: $_aliasNameGenerator(
                  db.entityInstances.id, db.dataSubmissions.entityInstance));

  $$DataSubmissionsTableProcessedTableManager get entityInstanceData {
    final manager =
        $$DataSubmissionsTableTableManager($_db, $_db.dataSubmissions).filter(
            (f) => f.entityInstance.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_entityInstanceDataTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$EntityAttributeValuesTable,
      List<EntityAttributeValue>> _instanceAttributeValuesTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.entityAttributeValues,
          aliasName: $_aliasNameGenerator(
              db.entityInstances.id, db.entityAttributeValues.entityInstance));

  $$EntityAttributeValuesTableProcessedTableManager
      get instanceAttributeValues {
    final manager = $$EntityAttributeValuesTableTableManager(
            $_db, $_db.entityAttributeValues)
        .filter(
            (f) => f.entityInstance.id.sqlEquals($_itemColumn<String>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_instanceAttributeValuesTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$EntityAttributeValuesTable,
      List<EntityAttributeValue>> _attributeValuesTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.entityAttributeValues,
          aliasName: $_aliasNameGenerator(
              db.entityInstances.id, db.entityAttributeValues.entityAttribute));

  $$EntityAttributeValuesTableProcessedTableManager get attributeValues {
    final manager = $$EntityAttributeValuesTableTableManager(
            $_db, $_db.entityAttributeValues)
        .filter(
            (f) => f.entityAttribute.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_attributeValuesTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$EntityInstancesTableFilterComposer
    extends Composer<_$AppDatabase, $EntityInstancesTable> {
  $$EntityInstancesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<Map<String, dynamic>?, Map<String, dynamic>,
          String>
      get label => $composableBuilder(
          column: $table.label,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnWithTypeConverterFilters<List<Translation>, List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<EntityStatus?, EntityStatus, String>
      get status => $composableBuilder(
          column: $table.status,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<DateTime> get updatedAtClient => $composableBuilder(
      column: $table.updatedAtClient,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAtClient => $composableBuilder(
      column: $table.createdAtClient,
      builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<Map<String, dynamic>?, Map<String, dynamic>,
          String>
      get identityAttributes => $composableBuilder(
          column: $table.identityAttributes,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnWithTypeConverterFilters<InstanceSyncStatus, InstanceSyncStatus, String>
      get syncState => $composableBuilder(
          column: $table.syncState,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  $$EntityTypesTableFilterComposer get entityType {
    final $$EntityTypesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.entityType,
        referencedTable: $db.entityTypes,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$EntityTypesTableFilterComposer(
              $db: $db,
              $table: $db.entityTypes,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> flowInstances(
      Expression<bool> Function($$FlowInstancesTableFilterComposer f) f) {
    final $$FlowInstancesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.flowInstances,
        getReferencedColumn: (t) => t.entityInstance,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowInstancesTableFilterComposer(
              $db: $db,
              $table: $db.flowInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> entityInstanceData(
      Expression<bool> Function($$DataSubmissionsTableFilterComposer f) f) {
    final $$DataSubmissionsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.entityInstance,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableFilterComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> instanceAttributeValues(
      Expression<bool> Function($$EntityAttributeValuesTableFilterComposer f)
          f) {
    final $$EntityAttributeValuesTableFilterComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.entityAttributeValues,
            getReferencedColumn: (t) => t.entityInstance,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$EntityAttributeValuesTableFilterComposer(
                  $db: $db,
                  $table: $db.entityAttributeValues,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<bool> attributeValues(
      Expression<bool> Function($$EntityAttributeValuesTableFilterComposer f)
          f) {
    final $$EntityAttributeValuesTableFilterComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.entityAttributeValues,
            getReferencedColumn: (t) => t.entityAttribute,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$EntityAttributeValuesTableFilterComposer(
                  $db: $db,
                  $table: $db.entityAttributeValues,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$EntityInstancesTableOrderingComposer
    extends Composer<_$AppDatabase, $EntityInstancesTable> {
  $$EntityInstancesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get label => $composableBuilder(
      column: $table.label, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get translations => $composableBuilder(
      column: $table.translations,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAtClient => $composableBuilder(
      column: $table.updatedAtClient,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAtClient => $composableBuilder(
      column: $table.createdAtClient,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get identityAttributes => $composableBuilder(
      column: $table.identityAttributes,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get syncState => $composableBuilder(
      column: $table.syncState, builder: (column) => ColumnOrderings(column));

  $$EntityTypesTableOrderingComposer get entityType {
    final $$EntityTypesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.entityType,
        referencedTable: $db.entityTypes,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$EntityTypesTableOrderingComposer(
              $db: $db,
              $table: $db.entityTypes,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$EntityInstancesTableAnnotationComposer
    extends Composer<_$AppDatabase, $EntityInstancesTable> {
  $$EntityInstancesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate, builder: (column) => column);

  GeneratedColumn<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => column);

  GeneratedColumn<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String> get label =>
      $composableBuilder(column: $table.label, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumnWithTypeConverter<EntityStatus?, String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAtClient => $composableBuilder(
      column: $table.updatedAtClient, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAtClient => $composableBuilder(
      column: $table.createdAtClient, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
      get identityAttributes => $composableBuilder(
          column: $table.identityAttributes, builder: (column) => column);

  GeneratedColumnWithTypeConverter<InstanceSyncStatus, String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  $$EntityTypesTableAnnotationComposer get entityType {
    final $$EntityTypesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.entityType,
        referencedTable: $db.entityTypes,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$EntityTypesTableAnnotationComposer(
              $db: $db,
              $table: $db.entityTypes,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> flowInstances<T extends Object>(
      Expression<T> Function($$FlowInstancesTableAnnotationComposer a) f) {
    final $$FlowInstancesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.flowInstances,
        getReferencedColumn: (t) => t.entityInstance,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowInstancesTableAnnotationComposer(
              $db: $db,
              $table: $db.flowInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> entityInstanceData<T extends Object>(
      Expression<T> Function($$DataSubmissionsTableAnnotationComposer a) f) {
    final $$DataSubmissionsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.entityInstance,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableAnnotationComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> instanceAttributeValues<T extends Object>(
      Expression<T> Function($$EntityAttributeValuesTableAnnotationComposer a)
          f) {
    final $$EntityAttributeValuesTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.entityAttributeValues,
            getReferencedColumn: (t) => t.entityInstance,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$EntityAttributeValuesTableAnnotationComposer(
                  $db: $db,
                  $table: $db.entityAttributeValues,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<T> attributeValues<T extends Object>(
      Expression<T> Function($$EntityAttributeValuesTableAnnotationComposer a)
          f) {
    final $$EntityAttributeValuesTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.entityAttributeValues,
            getReferencedColumn: (t) => t.entityAttribute,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$EntityAttributeValuesTableAnnotationComposer(
                  $db: $db,
                  $table: $db.entityAttributeValues,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$EntityInstancesTableTableManager extends RootTableManager<
    _$AppDatabase,
    $EntityInstancesTable,
    EntityInstance,
    $$EntityInstancesTableFilterComposer,
    $$EntityInstancesTableOrderingComposer,
    $$EntityInstancesTableAnnotationComposer,
    $$EntityInstancesTableCreateCompanionBuilder,
    $$EntityInstancesTableUpdateCompanionBuilder,
    (EntityInstance, $$EntityInstancesTableReferences),
    EntityInstance,
    PrefetchHooks Function(
        {bool entityType,
        bool flowInstances,
        bool entityInstanceData,
        bool instanceAttributeValues,
        bool attributeValues})> {
  $$EntityInstancesTableTableManager(
      _$AppDatabase db, $EntityInstancesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$EntityInstancesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$EntityInstancesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$EntityInstancesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> displayName = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>> translations = const Value.absent(),
            Value<String?> uuid = const Value.absent(),
            Value<String> entityType = const Value.absent(),
            Value<EntityStatus?> status = const Value.absent(),
            Value<DateTime?> updatedAtClient = const Value.absent(),
            Value<DateTime?> createdAtClient = const Value.absent(),
            Value<Map<String, dynamic>?> identityAttributes =
                const Value.absent(),
            Value<InstanceSyncStatus> syncState = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              EntityInstancesCompanion(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            displayName: displayName,
            label: label,
            translations: translations,
            uuid: uuid,
            entityType: entityType,
            status: status,
            updatedAtClient: updatedAtClient,
            createdAtClient: createdAtClient,
            identityAttributes: identityAttributes,
            syncState: syncState,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> displayName = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>> translations = const Value.absent(),
            Value<String?> uuid = const Value.absent(),
            required String entityType,
            Value<EntityStatus?> status = const Value.absent(),
            Value<DateTime?> updatedAtClient = const Value.absent(),
            Value<DateTime?> createdAtClient = const Value.absent(),
            Value<Map<String, dynamic>?> identityAttributes =
                const Value.absent(),
            required InstanceSyncStatus syncState,
            Value<int> rowid = const Value.absent(),
          }) =>
              EntityInstancesCompanion.insert(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            displayName: displayName,
            label: label,
            translations: translations,
            uuid: uuid,
            entityType: entityType,
            status: status,
            updatedAtClient: updatedAtClient,
            createdAtClient: createdAtClient,
            identityAttributes: identityAttributes,
            syncState: syncState,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$EntityInstancesTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {entityType = false,
              flowInstances = false,
              entityInstanceData = false,
              instanceAttributeValues = false,
              attributeValues = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (flowInstances) db.flowInstances,
                if (entityInstanceData) db.dataSubmissions,
                if (instanceAttributeValues) db.entityAttributeValues,
                if (attributeValues) db.entityAttributeValues
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (entityType) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.entityType,
                    referencedTable:
                        $$EntityInstancesTableReferences._entityTypeTable(db),
                    referencedColumn: $$EntityInstancesTableReferences
                        ._entityTypeTable(db)
                        .id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (flowInstances)
                    await $_getPrefetchedData<EntityInstance,
                            $EntityInstancesTable, FlowInstance>(
                        currentTable: table,
                        referencedTable: $$EntityInstancesTableReferences
                            ._flowInstancesTable(db),
                        managerFromTypedResult: (p0) =>
                            $$EntityInstancesTableReferences(db, table, p0)
                                .flowInstances,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.entityInstance == item.id),
                        typedResults: items),
                  if (entityInstanceData)
                    await $_getPrefetchedData<EntityInstance,
                            $EntityInstancesTable, DataSubmission>(
                        currentTable: table,
                        referencedTable: $$EntityInstancesTableReferences
                            ._entityInstanceDataTable(db),
                        managerFromTypedResult: (p0) =>
                            $$EntityInstancesTableReferences(db, table, p0)
                                .entityInstanceData,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.entityInstance == item.id),
                        typedResults: items),
                  if (instanceAttributeValues)
                    await $_getPrefetchedData<EntityInstance,
                            $EntityInstancesTable, EntityAttributeValue>(
                        currentTable: table,
                        referencedTable: $$EntityInstancesTableReferences
                            ._instanceAttributeValuesTable(db),
                        managerFromTypedResult: (p0) =>
                            $$EntityInstancesTableReferences(db, table, p0)
                                .instanceAttributeValues,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.entityInstance == item.id),
                        typedResults: items),
                  if (attributeValues)
                    await $_getPrefetchedData<EntityInstance,
                            $EntityInstancesTable, EntityAttributeValue>(
                        currentTable: table,
                        referencedTable: $$EntityInstancesTableReferences
                            ._attributeValuesTable(db),
                        managerFromTypedResult: (p0) =>
                            $$EntityInstancesTableReferences(db, table, p0)
                                .attributeValues,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.entityAttribute == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$EntityInstancesTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $EntityInstancesTable,
    EntityInstance,
    $$EntityInstancesTableFilterComposer,
    $$EntityInstancesTableOrderingComposer,
    $$EntityInstancesTableAnnotationComposer,
    $$EntityInstancesTableCreateCompanionBuilder,
    $$EntityInstancesTableUpdateCompanionBuilder,
    (EntityInstance, $$EntityInstancesTableReferences),
    EntityInstance,
    PrefetchHooks Function(
        {bool entityType,
        bool flowInstances,
        bool entityInstanceData,
        bool instanceAttributeValues,
        bool attributeValues})>;
typedef $$FlowInstancesTableCreateCompanionBuilder = FlowInstancesCompanion
    Function({
  required String id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  required String flowType,
  required String activity,
  required String team,
  required String orgUnit,
  Value<DateTime?> flowInstanceDate,
  Value<String?> entityInstance,
  Value<Map<String, dynamic>?> stepStates,
  required InstanceSyncStatus syncState,
  Value<AssignmentStatus?> flowStatus,
  Value<DateTime?> completedDate,
  Value<DateTime?> updatedAtClient,
  Value<int> rowid,
});
typedef $$FlowInstancesTableUpdateCompanionBuilder = FlowInstancesCompanion
    Function({
  Value<String> id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String> flowType,
  Value<String> activity,
  Value<String> team,
  Value<String> orgUnit,
  Value<DateTime?> flowInstanceDate,
  Value<String?> entityInstance,
  Value<Map<String, dynamic>?> stepStates,
  Value<InstanceSyncStatus> syncState,
  Value<AssignmentStatus?> flowStatus,
  Value<DateTime?> completedDate,
  Value<DateTime?> updatedAtClient,
  Value<int> rowid,
});

final class $$FlowInstancesTableReferences
    extends BaseReferences<_$AppDatabase, $FlowInstancesTable, FlowInstance> {
  $$FlowInstancesTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $FlowTypesTable _flowTypeTable(_$AppDatabase db) =>
      db.flowTypes.createAlias(
          $_aliasNameGenerator(db.flowInstances.flowType, db.flowTypes.id));

  $$FlowTypesTableProcessedTableManager get flowType {
    final $_column = $_itemColumn<String>('flow_type')!;

    final manager = $$FlowTypesTableTableManager($_db, $_db.flowTypes)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_flowTypeTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $ActivitiesTable _activityTable(_$AppDatabase db) =>
      db.activities.createAlias(
          $_aliasNameGenerator(db.flowInstances.activity, db.activities.id));

  $$ActivitiesTableProcessedTableManager get activity {
    final $_column = $_itemColumn<String>('activity')!;

    final manager = $$ActivitiesTableTableManager($_db, $_db.activities)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_activityTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $TeamsTable _teamTable(_$AppDatabase db) => db.teams
      .createAlias($_aliasNameGenerator(db.flowInstances.team, db.teams.id));

  $$TeamsTableProcessedTableManager get team {
    final $_column = $_itemColumn<String>('team')!;

    final manager = $$TeamsTableTableManager($_db, $_db.teams)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_teamTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $OrgUnitsTable _orgUnitTable(_$AppDatabase db) =>
      db.orgUnits.createAlias(
          $_aliasNameGenerator(db.flowInstances.orgUnit, db.orgUnits.id));

  $$OrgUnitsTableProcessedTableManager get orgUnit {
    final $_column = $_itemColumn<String>('org_unit')!;

    final manager = $$OrgUnitsTableTableManager($_db, $_db.orgUnits)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_orgUnitTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $EntityInstancesTable _entityInstanceTable(_$AppDatabase db) =>
      db.entityInstances.createAlias($_aliasNameGenerator(
          db.flowInstances.entityInstance, db.entityInstances.id));

  $$EntityInstancesTableProcessedTableManager? get entityInstance {
    final $_column = $_itemColumn<String>('entity_instance');
    if ($_column == null) return null;
    final manager =
        $$EntityInstancesTableTableManager($_db, $_db.entityInstances)
            .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_entityInstanceTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$AssignmentFormsTable, List<AssignmentForm>>
      _assignmentFormsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.assignmentForms,
              aliasName: $_aliasNameGenerator(
                  db.flowInstances.id, db.assignmentForms.assignment));

  $$AssignmentFormsTableProcessedTableManager get assignmentForms {
    final manager = $$AssignmentFormsTableTableManager(
            $_db, $_db.assignmentForms)
        .filter((f) => f.assignment.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_assignmentFormsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$DataSubmissionsTable, List<DataSubmission>>
      _dataSubmissionsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.dataSubmissions,
              aliasName: $_aliasNameGenerator(
                  db.flowInstances.id, db.dataSubmissions.flowInstance));

  $$DataSubmissionsTableProcessedTableManager get dataSubmissionsRefs {
    final manager =
        $$DataSubmissionsTableTableManager($_db, $_db.dataSubmissions).filter(
            (f) => f.flowInstance.id.sqlEquals($_itemColumn<String>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_dataSubmissionsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$FlowInstancesTableFilterComposer
    extends Composer<_$AppDatabase, $FlowInstancesTable> {
  $$FlowInstancesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get flowInstanceDate => $composableBuilder(
      column: $table.flowInstanceDate,
      builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<Map<String, dynamic>?, Map<String, dynamic>,
          String>
      get stepStates => $composableBuilder(
          column: $table.stepStates,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnWithTypeConverterFilters<InstanceSyncStatus, InstanceSyncStatus, String>
      get syncState => $composableBuilder(
          column: $table.syncState,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnWithTypeConverterFilters<AssignmentStatus?, AssignmentStatus, String>
      get flowStatus => $composableBuilder(
          column: $table.flowStatus,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<DateTime> get completedDate => $composableBuilder(
      column: $table.completedDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAtClient => $composableBuilder(
      column: $table.updatedAtClient,
      builder: (column) => ColumnFilters(column));

  $$FlowTypesTableFilterComposer get flowType {
    final $$FlowTypesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.flowType,
        referencedTable: $db.flowTypes,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowTypesTableFilterComposer(
              $db: $db,
              $table: $db.flowTypes,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$ActivitiesTableFilterComposer get activity {
    final $$ActivitiesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.activity,
        referencedTable: $db.activities,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ActivitiesTableFilterComposer(
              $db: $db,
              $table: $db.activities,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$TeamsTableFilterComposer get team {
    final $$TeamsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.team,
        referencedTable: $db.teams,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$TeamsTableFilterComposer(
              $db: $db,
              $table: $db.teams,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$OrgUnitsTableFilterComposer get orgUnit {
    final $$OrgUnitsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orgUnit,
        referencedTable: $db.orgUnits,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrgUnitsTableFilterComposer(
              $db: $db,
              $table: $db.orgUnits,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$EntityInstancesTableFilterComposer get entityInstance {
    final $$EntityInstancesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.entityInstance,
        referencedTable: $db.entityInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$EntityInstancesTableFilterComposer(
              $db: $db,
              $table: $db.entityInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> assignmentForms(
      Expression<bool> Function($$AssignmentFormsTableFilterComposer f) f) {
    final $$AssignmentFormsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.assignmentForms,
        getReferencedColumn: (t) => t.assignment,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$AssignmentFormsTableFilterComposer(
              $db: $db,
              $table: $db.assignmentForms,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> dataSubmissionsRefs(
      Expression<bool> Function($$DataSubmissionsTableFilterComposer f) f) {
    final $$DataSubmissionsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.flowInstance,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableFilterComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$FlowInstancesTableOrderingComposer
    extends Composer<_$AppDatabase, $FlowInstancesTable> {
  $$FlowInstancesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get flowInstanceDate => $composableBuilder(
      column: $table.flowInstanceDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get stepStates => $composableBuilder(
      column: $table.stepStates, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get syncState => $composableBuilder(
      column: $table.syncState, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get flowStatus => $composableBuilder(
      column: $table.flowStatus, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get completedDate => $composableBuilder(
      column: $table.completedDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAtClient => $composableBuilder(
      column: $table.updatedAtClient,
      builder: (column) => ColumnOrderings(column));

  $$FlowTypesTableOrderingComposer get flowType {
    final $$FlowTypesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.flowType,
        referencedTable: $db.flowTypes,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowTypesTableOrderingComposer(
              $db: $db,
              $table: $db.flowTypes,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$ActivitiesTableOrderingComposer get activity {
    final $$ActivitiesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.activity,
        referencedTable: $db.activities,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ActivitiesTableOrderingComposer(
              $db: $db,
              $table: $db.activities,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$TeamsTableOrderingComposer get team {
    final $$TeamsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.team,
        referencedTable: $db.teams,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$TeamsTableOrderingComposer(
              $db: $db,
              $table: $db.teams,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$OrgUnitsTableOrderingComposer get orgUnit {
    final $$OrgUnitsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orgUnit,
        referencedTable: $db.orgUnits,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrgUnitsTableOrderingComposer(
              $db: $db,
              $table: $db.orgUnits,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$EntityInstancesTableOrderingComposer get entityInstance {
    final $$EntityInstancesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.entityInstance,
        referencedTable: $db.entityInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$EntityInstancesTableOrderingComposer(
              $db: $db,
              $table: $db.entityInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$FlowInstancesTableAnnotationComposer
    extends Composer<_$AppDatabase, $FlowInstancesTable> {
  $$FlowInstancesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate, builder: (column) => column);

  GeneratedColumn<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => column);

  GeneratedColumn<DateTime> get flowInstanceDate => $composableBuilder(
      column: $table.flowInstanceDate, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
      get stepStates => $composableBuilder(
          column: $table.stepStates, builder: (column) => column);

  GeneratedColumnWithTypeConverter<InstanceSyncStatus, String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  GeneratedColumnWithTypeConverter<AssignmentStatus?, String> get flowStatus =>
      $composableBuilder(
          column: $table.flowStatus, builder: (column) => column);

  GeneratedColumn<DateTime> get completedDate => $composableBuilder(
      column: $table.completedDate, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAtClient => $composableBuilder(
      column: $table.updatedAtClient, builder: (column) => column);

  $$FlowTypesTableAnnotationComposer get flowType {
    final $$FlowTypesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.flowType,
        referencedTable: $db.flowTypes,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowTypesTableAnnotationComposer(
              $db: $db,
              $table: $db.flowTypes,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$ActivitiesTableAnnotationComposer get activity {
    final $$ActivitiesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.activity,
        referencedTable: $db.activities,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ActivitiesTableAnnotationComposer(
              $db: $db,
              $table: $db.activities,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$TeamsTableAnnotationComposer get team {
    final $$TeamsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.team,
        referencedTable: $db.teams,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$TeamsTableAnnotationComposer(
              $db: $db,
              $table: $db.teams,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$OrgUnitsTableAnnotationComposer get orgUnit {
    final $$OrgUnitsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orgUnit,
        referencedTable: $db.orgUnits,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrgUnitsTableAnnotationComposer(
              $db: $db,
              $table: $db.orgUnits,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$EntityInstancesTableAnnotationComposer get entityInstance {
    final $$EntityInstancesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.entityInstance,
        referencedTable: $db.entityInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$EntityInstancesTableAnnotationComposer(
              $db: $db,
              $table: $db.entityInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> assignmentForms<T extends Object>(
      Expression<T> Function($$AssignmentFormsTableAnnotationComposer a) f) {
    final $$AssignmentFormsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.assignmentForms,
        getReferencedColumn: (t) => t.assignment,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$AssignmentFormsTableAnnotationComposer(
              $db: $db,
              $table: $db.assignmentForms,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> dataSubmissionsRefs<T extends Object>(
      Expression<T> Function($$DataSubmissionsTableAnnotationComposer a) f) {
    final $$DataSubmissionsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.flowInstance,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableAnnotationComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$FlowInstancesTableTableManager extends RootTableManager<
    _$AppDatabase,
    $FlowInstancesTable,
    FlowInstance,
    $$FlowInstancesTableFilterComposer,
    $$FlowInstancesTableOrderingComposer,
    $$FlowInstancesTableAnnotationComposer,
    $$FlowInstancesTableCreateCompanionBuilder,
    $$FlowInstancesTableUpdateCompanionBuilder,
    (FlowInstance, $$FlowInstancesTableReferences),
    FlowInstance,
    PrefetchHooks Function(
        {bool flowType,
        bool activity,
        bool team,
        bool orgUnit,
        bool entityInstance,
        bool assignmentForms,
        bool dataSubmissionsRefs})> {
  $$FlowInstancesTableTableManager(_$AppDatabase db, $FlowInstancesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FlowInstancesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FlowInstancesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FlowInstancesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String> flowType = const Value.absent(),
            Value<String> activity = const Value.absent(),
            Value<String> team = const Value.absent(),
            Value<String> orgUnit = const Value.absent(),
            Value<DateTime?> flowInstanceDate = const Value.absent(),
            Value<String?> entityInstance = const Value.absent(),
            Value<Map<String, dynamic>?> stepStates = const Value.absent(),
            Value<InstanceSyncStatus> syncState = const Value.absent(),
            Value<AssignmentStatus?> flowStatus = const Value.absent(),
            Value<DateTime?> completedDate = const Value.absent(),
            Value<DateTime?> updatedAtClient = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              FlowInstancesCompanion(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            flowType: flowType,
            activity: activity,
            team: team,
            orgUnit: orgUnit,
            flowInstanceDate: flowInstanceDate,
            entityInstance: entityInstance,
            stepStates: stepStates,
            syncState: syncState,
            flowStatus: flowStatus,
            completedDate: completedDate,
            updatedAtClient: updatedAtClient,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            required String flowType,
            required String activity,
            required String team,
            required String orgUnit,
            Value<DateTime?> flowInstanceDate = const Value.absent(),
            Value<String?> entityInstance = const Value.absent(),
            Value<Map<String, dynamic>?> stepStates = const Value.absent(),
            required InstanceSyncStatus syncState,
            Value<AssignmentStatus?> flowStatus = const Value.absent(),
            Value<DateTime?> completedDate = const Value.absent(),
            Value<DateTime?> updatedAtClient = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              FlowInstancesCompanion.insert(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            flowType: flowType,
            activity: activity,
            team: team,
            orgUnit: orgUnit,
            flowInstanceDate: flowInstanceDate,
            entityInstance: entityInstance,
            stepStates: stepStates,
            syncState: syncState,
            flowStatus: flowStatus,
            completedDate: completedDate,
            updatedAtClient: updatedAtClient,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$FlowInstancesTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {flowType = false,
              activity = false,
              team = false,
              orgUnit = false,
              entityInstance = false,
              assignmentForms = false,
              dataSubmissionsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (assignmentForms) db.assignmentForms,
                if (dataSubmissionsRefs) db.dataSubmissions
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (flowType) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.flowType,
                    referencedTable:
                        $$FlowInstancesTableReferences._flowTypeTable(db),
                    referencedColumn:
                        $$FlowInstancesTableReferences._flowTypeTable(db).id,
                  ) as T;
                }
                if (activity) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.activity,
                    referencedTable:
                        $$FlowInstancesTableReferences._activityTable(db),
                    referencedColumn:
                        $$FlowInstancesTableReferences._activityTable(db).id,
                  ) as T;
                }
                if (team) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.team,
                    referencedTable:
                        $$FlowInstancesTableReferences._teamTable(db),
                    referencedColumn:
                        $$FlowInstancesTableReferences._teamTable(db).id,
                  ) as T;
                }
                if (orgUnit) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.orgUnit,
                    referencedTable:
                        $$FlowInstancesTableReferences._orgUnitTable(db),
                    referencedColumn:
                        $$FlowInstancesTableReferences._orgUnitTable(db).id,
                  ) as T;
                }
                if (entityInstance) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.entityInstance,
                    referencedTable:
                        $$FlowInstancesTableReferences._entityInstanceTable(db),
                    referencedColumn: $$FlowInstancesTableReferences
                        ._entityInstanceTable(db)
                        .id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (assignmentForms)
                    await $_getPrefetchedData<FlowInstance, $FlowInstancesTable, AssignmentForm>(
                        currentTable: table,
                        referencedTable: $$FlowInstancesTableReferences
                            ._assignmentFormsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$FlowInstancesTableReferences(db, table, p0)
                                .assignmentForms,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.assignment == item.id),
                        typedResults: items),
                  if (dataSubmissionsRefs)
                    await $_getPrefetchedData<FlowInstance, $FlowInstancesTable, DataSubmission>(
                        currentTable: table,
                        referencedTable: $$FlowInstancesTableReferences
                            ._dataSubmissionsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$FlowInstancesTableReferences(db, table, p0)
                                .dataSubmissionsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.flowInstance == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$FlowInstancesTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $FlowInstancesTable,
    FlowInstance,
    $$FlowInstancesTableFilterComposer,
    $$FlowInstancesTableOrderingComposer,
    $$FlowInstancesTableAnnotationComposer,
    $$FlowInstancesTableCreateCompanionBuilder,
    $$FlowInstancesTableUpdateCompanionBuilder,
    (FlowInstance, $$FlowInstancesTableReferences),
    FlowInstance,
    PrefetchHooks Function(
        {bool flowType,
        bool activity,
        bool team,
        bool orgUnit,
        bool entityInstance,
        bool assignmentForms,
        bool dataSubmissionsRefs})>;
typedef $$FormTemplatesTableCreateCompanionBuilder = FormTemplatesCompanion
    Function({
  required String id,
  required String formVersion,
  required int versionNumber,
  required String name,
  Value<Map<String, dynamic>?> label,
  Value<String?> description,
  Value<int> rowid,
});
typedef $$FormTemplatesTableUpdateCompanionBuilder = FormTemplatesCompanion
    Function({
  Value<String> id,
  Value<String> formVersion,
  Value<int> versionNumber,
  Value<String> name,
  Value<Map<String, dynamic>?> label,
  Value<String?> description,
  Value<int> rowid,
});

final class $$FormTemplatesTableReferences
    extends BaseReferences<_$AppDatabase, $FormTemplatesTable, FormTemplate> {
  $$FormTemplatesTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$AssignmentFormsTable, List<AssignmentForm>>
      _formAssignmentsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.assignmentForms,
              aliasName: $_aliasNameGenerator(
                  db.formTemplates.id, db.assignmentForms.form));

  $$AssignmentFormsTableProcessedTableManager get formAssignments {
    final manager =
        $$AssignmentFormsTableTableManager($_db, $_db.assignmentForms)
            .filter((f) => f.form.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_formAssignmentsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$FormTemplateVersionsTable,
      List<FormTemplateVersion>> _formTemplateVersionsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.formTemplateVersions,
          aliasName: $_aliasNameGenerator(
              db.formTemplates.id, db.formTemplateVersions.template));

  $$FormTemplateVersionsTableProcessedTableManager get formTemplateVersions {
    final manager = $$FormTemplateVersionsTableTableManager(
            $_db, $_db.formTemplateVersions)
        .filter((f) => f.template.id.sqlEquals($_itemColumn<String>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_formTemplateVersionsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$StageDefinitionsTable, List<StageDefinition>>
      _stageDefinitionsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.stageDefinitions,
              aliasName: $_aliasNameGenerator(
                  db.formTemplates.id, db.stageDefinitions.dataTemplate));

  $$StageDefinitionsTableProcessedTableManager get stageDefinitionsRefs {
    final manager =
        $$StageDefinitionsTableTableManager($_db, $_db.stageDefinitions).filter(
            (f) => f.dataTemplate.id.sqlEquals($_itemColumn<String>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_stageDefinitionsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$DataSubmissionsTable, List<DataSubmission>>
      _templateDataTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.dataSubmissions,
              aliasName: $_aliasNameGenerator(
                  db.formTemplates.id, db.dataSubmissions.dataTemplate));

  $$DataSubmissionsTableProcessedTableManager get templateData {
    final manager =
        $$DataSubmissionsTableTableManager($_db, $_db.dataSubmissions).filter(
            (f) => f.dataTemplate.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_templateDataTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$UserFormPermissionsTable,
      List<UserFormPermission>> _formPermissionsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.userFormPermissions,
          aliasName: $_aliasNameGenerator(
              db.formTemplates.id, db.userFormPermissions.form));

  $$UserFormPermissionsTableProcessedTableManager get formPermissions {
    final manager =
        $$UserFormPermissionsTableTableManager($_db, $_db.userFormPermissions)
            .filter((f) => f.form.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_formPermissionsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$FormTemplatesTableFilterComposer
    extends Composer<_$AppDatabase, $FormTemplatesTable> {
  $$FormTemplatesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get formVersion => $composableBuilder(
      column: $table.formVersion, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get versionNumber => $composableBuilder(
      column: $table.versionNumber, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<Map<String, dynamic>?, Map<String, dynamic>,
          String>
      get label => $composableBuilder(
          column: $table.label,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnFilters(column));

  Expression<bool> formAssignments(
      Expression<bool> Function($$AssignmentFormsTableFilterComposer f) f) {
    final $$AssignmentFormsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.assignmentForms,
        getReferencedColumn: (t) => t.form,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$AssignmentFormsTableFilterComposer(
              $db: $db,
              $table: $db.assignmentForms,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> formTemplateVersions(
      Expression<bool> Function($$FormTemplateVersionsTableFilterComposer f)
          f) {
    final $$FormTemplateVersionsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.formTemplateVersions,
        getReferencedColumn: (t) => t.template,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FormTemplateVersionsTableFilterComposer(
              $db: $db,
              $table: $db.formTemplateVersions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> stageDefinitionsRefs(
      Expression<bool> Function($$StageDefinitionsTableFilterComposer f) f) {
    final $$StageDefinitionsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stageDefinitions,
        getReferencedColumn: (t) => t.dataTemplate,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$StageDefinitionsTableFilterComposer(
              $db: $db,
              $table: $db.stageDefinitions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> templateData(
      Expression<bool> Function($$DataSubmissionsTableFilterComposer f) f) {
    final $$DataSubmissionsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.dataTemplate,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableFilterComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> formPermissions(
      Expression<bool> Function($$UserFormPermissionsTableFilterComposer f) f) {
    final $$UserFormPermissionsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.userFormPermissions,
        getReferencedColumn: (t) => t.form,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$UserFormPermissionsTableFilterComposer(
              $db: $db,
              $table: $db.userFormPermissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$FormTemplatesTableOrderingComposer
    extends Composer<_$AppDatabase, $FormTemplatesTable> {
  $$FormTemplatesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get formVersion => $composableBuilder(
      column: $table.formVersion, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get versionNumber => $composableBuilder(
      column: $table.versionNumber,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get label => $composableBuilder(
      column: $table.label, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnOrderings(column));
}

class $$FormTemplatesTableAnnotationComposer
    extends Composer<_$AppDatabase, $FormTemplatesTable> {
  $$FormTemplatesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get formVersion => $composableBuilder(
      column: $table.formVersion, builder: (column) => column);

  GeneratedColumn<int> get versionNumber => $composableBuilder(
      column: $table.versionNumber, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String> get label =>
      $composableBuilder(column: $table.label, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => column);

  Expression<T> formAssignments<T extends Object>(
      Expression<T> Function($$AssignmentFormsTableAnnotationComposer a) f) {
    final $$AssignmentFormsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.assignmentForms,
        getReferencedColumn: (t) => t.form,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$AssignmentFormsTableAnnotationComposer(
              $db: $db,
              $table: $db.assignmentForms,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> formTemplateVersions<T extends Object>(
      Expression<T> Function($$FormTemplateVersionsTableAnnotationComposer a)
          f) {
    final $$FormTemplateVersionsTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.formTemplateVersions,
            getReferencedColumn: (t) => t.template,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$FormTemplateVersionsTableAnnotationComposer(
                  $db: $db,
                  $table: $db.formTemplateVersions,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<T> stageDefinitionsRefs<T extends Object>(
      Expression<T> Function($$StageDefinitionsTableAnnotationComposer a) f) {
    final $$StageDefinitionsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stageDefinitions,
        getReferencedColumn: (t) => t.dataTemplate,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$StageDefinitionsTableAnnotationComposer(
              $db: $db,
              $table: $db.stageDefinitions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> templateData<T extends Object>(
      Expression<T> Function($$DataSubmissionsTableAnnotationComposer a) f) {
    final $$DataSubmissionsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.dataTemplate,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableAnnotationComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> formPermissions<T extends Object>(
      Expression<T> Function($$UserFormPermissionsTableAnnotationComposer a)
          f) {
    final $$UserFormPermissionsTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.userFormPermissions,
            getReferencedColumn: (t) => t.form,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$UserFormPermissionsTableAnnotationComposer(
                  $db: $db,
                  $table: $db.userFormPermissions,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$FormTemplatesTableTableManager extends RootTableManager<
    _$AppDatabase,
    $FormTemplatesTable,
    FormTemplate,
    $$FormTemplatesTableFilterComposer,
    $$FormTemplatesTableOrderingComposer,
    $$FormTemplatesTableAnnotationComposer,
    $$FormTemplatesTableCreateCompanionBuilder,
    $$FormTemplatesTableUpdateCompanionBuilder,
    (FormTemplate, $$FormTemplatesTableReferences),
    FormTemplate,
    PrefetchHooks Function(
        {bool formAssignments,
        bool formTemplateVersions,
        bool stageDefinitionsRefs,
        bool templateData,
        bool formPermissions})> {
  $$FormTemplatesTableTableManager(_$AppDatabase db, $FormTemplatesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FormTemplatesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FormTemplatesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FormTemplatesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<String> formVersion = const Value.absent(),
            Value<int> versionNumber = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              FormTemplatesCompanion(
            id: id,
            formVersion: formVersion,
            versionNumber: versionNumber,
            name: name,
            label: label,
            description: description,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            required String formVersion,
            required int versionNumber,
            required String name,
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              FormTemplatesCompanion.insert(
            id: id,
            formVersion: formVersion,
            versionNumber: versionNumber,
            name: name,
            label: label,
            description: description,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$FormTemplatesTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {formAssignments = false,
              formTemplateVersions = false,
              stageDefinitionsRefs = false,
              templateData = false,
              formPermissions = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (formAssignments) db.assignmentForms,
                if (formTemplateVersions) db.formTemplateVersions,
                if (stageDefinitionsRefs) db.stageDefinitions,
                if (templateData) db.dataSubmissions,
                if (formPermissions) db.userFormPermissions
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (formAssignments)
                    await $_getPrefetchedData<FormTemplate, $FormTemplatesTable, AssignmentForm>(
                        currentTable: table,
                        referencedTable: $$FormTemplatesTableReferences
                            ._formAssignmentsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$FormTemplatesTableReferences(db, table, p0)
                                .formAssignments,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) =>
                                referencedItems.where((e) => e.form == item.id),
                        typedResults: items),
                  if (formTemplateVersions)
                    await $_getPrefetchedData<FormTemplate, $FormTemplatesTable,
                            FormTemplateVersion>(
                        currentTable: table,
                        referencedTable: $$FormTemplatesTableReferences
                            ._formTemplateVersionsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$FormTemplatesTableReferences(db, table, p0)
                                .formTemplateVersions,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.template == item.id),
                        typedResults: items),
                  if (stageDefinitionsRefs)
                    await $_getPrefetchedData<FormTemplate, $FormTemplatesTable,
                            StageDefinition>(
                        currentTable: table,
                        referencedTable: $$FormTemplatesTableReferences
                            ._stageDefinitionsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$FormTemplatesTableReferences(db, table, p0)
                                .stageDefinitionsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.dataTemplate == item.id),
                        typedResults: items),
                  if (templateData)
                    await $_getPrefetchedData<FormTemplate, $FormTemplatesTable,
                            DataSubmission>(
                        currentTable: table,
                        referencedTable: $$FormTemplatesTableReferences
                            ._templateDataTable(db),
                        managerFromTypedResult: (p0) =>
                            $$FormTemplatesTableReferences(db, table, p0)
                                .templateData,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.dataTemplate == item.id),
                        typedResults: items),
                  if (formPermissions)
                    await $_getPrefetchedData<FormTemplate, $FormTemplatesTable,
                            UserFormPermission>(
                        currentTable: table,
                        referencedTable: $$FormTemplatesTableReferences
                            ._formPermissionsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$FormTemplatesTableReferences(db, table, p0)
                                .formPermissions,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) =>
                                referencedItems.where((e) => e.form == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$FormTemplatesTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $FormTemplatesTable,
    FormTemplate,
    $$FormTemplatesTableFilterComposer,
    $$FormTemplatesTableOrderingComposer,
    $$FormTemplatesTableAnnotationComposer,
    $$FormTemplatesTableCreateCompanionBuilder,
    $$FormTemplatesTableUpdateCompanionBuilder,
    (FormTemplate, $$FormTemplatesTableReferences),
    FormTemplate,
    PrefetchHooks Function(
        {bool formAssignments,
        bool formTemplateVersions,
        bool stageDefinitionsRefs,
        bool templateData,
        bool formPermissions})>;
typedef $$AssignmentFormsTableCreateCompanionBuilder = AssignmentFormsCompanion
    Function({
  required String assignment,
  required String form,
  Value<bool?> canAddSubmissions,
  Value<bool?> canViewSubmissions,
  Value<bool?> canEditSubmissions,
  Value<bool?> canDeleteSubmissions,
  Value<int> rowid,
});
typedef $$AssignmentFormsTableUpdateCompanionBuilder = AssignmentFormsCompanion
    Function({
  Value<String> assignment,
  Value<String> form,
  Value<bool?> canAddSubmissions,
  Value<bool?> canViewSubmissions,
  Value<bool?> canEditSubmissions,
  Value<bool?> canDeleteSubmissions,
  Value<int> rowid,
});

final class $$AssignmentFormsTableReferences extends BaseReferences<
    _$AppDatabase, $AssignmentFormsTable, AssignmentForm> {
  $$AssignmentFormsTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $FlowInstancesTable _assignmentTable(_$AppDatabase db) =>
      db.flowInstances.createAlias($_aliasNameGenerator(
          db.assignmentForms.assignment, db.flowInstances.id));

  $$FlowInstancesTableProcessedTableManager get assignment {
    final $_column = $_itemColumn<String>('assignment')!;

    final manager = $$FlowInstancesTableTableManager($_db, $_db.flowInstances)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_assignmentTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $FormTemplatesTable _formTable(_$AppDatabase db) =>
      db.formTemplates.createAlias(
          $_aliasNameGenerator(db.assignmentForms.form, db.formTemplates.id));

  $$FormTemplatesTableProcessedTableManager get form {
    final $_column = $_itemColumn<String>('form')!;

    final manager = $$FormTemplatesTableTableManager($_db, $_db.formTemplates)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_formTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$AssignmentFormsTableFilterComposer
    extends Composer<_$AppDatabase, $AssignmentFormsTable> {
  $$AssignmentFormsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get canAddSubmissions => $composableBuilder(
      column: $table.canAddSubmissions,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get canViewSubmissions => $composableBuilder(
      column: $table.canViewSubmissions,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get canEditSubmissions => $composableBuilder(
      column: $table.canEditSubmissions,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get canDeleteSubmissions => $composableBuilder(
      column: $table.canDeleteSubmissions,
      builder: (column) => ColumnFilters(column));

  $$FlowInstancesTableFilterComposer get assignment {
    final $$FlowInstancesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.assignment,
        referencedTable: $db.flowInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowInstancesTableFilterComposer(
              $db: $db,
              $table: $db.flowInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$FormTemplatesTableFilterComposer get form {
    final $$FormTemplatesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.form,
        referencedTable: $db.formTemplates,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FormTemplatesTableFilterComposer(
              $db: $db,
              $table: $db.formTemplates,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$AssignmentFormsTableOrderingComposer
    extends Composer<_$AppDatabase, $AssignmentFormsTable> {
  $$AssignmentFormsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get canAddSubmissions => $composableBuilder(
      column: $table.canAddSubmissions,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get canViewSubmissions => $composableBuilder(
      column: $table.canViewSubmissions,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get canEditSubmissions => $composableBuilder(
      column: $table.canEditSubmissions,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get canDeleteSubmissions => $composableBuilder(
      column: $table.canDeleteSubmissions,
      builder: (column) => ColumnOrderings(column));

  $$FlowInstancesTableOrderingComposer get assignment {
    final $$FlowInstancesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.assignment,
        referencedTable: $db.flowInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowInstancesTableOrderingComposer(
              $db: $db,
              $table: $db.flowInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$FormTemplatesTableOrderingComposer get form {
    final $$FormTemplatesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.form,
        referencedTable: $db.formTemplates,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FormTemplatesTableOrderingComposer(
              $db: $db,
              $table: $db.formTemplates,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$AssignmentFormsTableAnnotationComposer
    extends Composer<_$AppDatabase, $AssignmentFormsTable> {
  $$AssignmentFormsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get canAddSubmissions => $composableBuilder(
      column: $table.canAddSubmissions, builder: (column) => column);

  GeneratedColumn<bool> get canViewSubmissions => $composableBuilder(
      column: $table.canViewSubmissions, builder: (column) => column);

  GeneratedColumn<bool> get canEditSubmissions => $composableBuilder(
      column: $table.canEditSubmissions, builder: (column) => column);

  GeneratedColumn<bool> get canDeleteSubmissions => $composableBuilder(
      column: $table.canDeleteSubmissions, builder: (column) => column);

  $$FlowInstancesTableAnnotationComposer get assignment {
    final $$FlowInstancesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.assignment,
        referencedTable: $db.flowInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowInstancesTableAnnotationComposer(
              $db: $db,
              $table: $db.flowInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$FormTemplatesTableAnnotationComposer get form {
    final $$FormTemplatesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.form,
        referencedTable: $db.formTemplates,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FormTemplatesTableAnnotationComposer(
              $db: $db,
              $table: $db.formTemplates,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$AssignmentFormsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $AssignmentFormsTable,
    AssignmentForm,
    $$AssignmentFormsTableFilterComposer,
    $$AssignmentFormsTableOrderingComposer,
    $$AssignmentFormsTableAnnotationComposer,
    $$AssignmentFormsTableCreateCompanionBuilder,
    $$AssignmentFormsTableUpdateCompanionBuilder,
    (AssignmentForm, $$AssignmentFormsTableReferences),
    AssignmentForm,
    PrefetchHooks Function({bool assignment, bool form})> {
  $$AssignmentFormsTableTableManager(
      _$AppDatabase db, $AssignmentFormsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AssignmentFormsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AssignmentFormsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AssignmentFormsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> assignment = const Value.absent(),
            Value<String> form = const Value.absent(),
            Value<bool?> canAddSubmissions = const Value.absent(),
            Value<bool?> canViewSubmissions = const Value.absent(),
            Value<bool?> canEditSubmissions = const Value.absent(),
            Value<bool?> canDeleteSubmissions = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              AssignmentFormsCompanion(
            assignment: assignment,
            form: form,
            canAddSubmissions: canAddSubmissions,
            canViewSubmissions: canViewSubmissions,
            canEditSubmissions: canEditSubmissions,
            canDeleteSubmissions: canDeleteSubmissions,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String assignment,
            required String form,
            Value<bool?> canAddSubmissions = const Value.absent(),
            Value<bool?> canViewSubmissions = const Value.absent(),
            Value<bool?> canEditSubmissions = const Value.absent(),
            Value<bool?> canDeleteSubmissions = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              AssignmentFormsCompanion.insert(
            assignment: assignment,
            form: form,
            canAddSubmissions: canAddSubmissions,
            canViewSubmissions: canViewSubmissions,
            canEditSubmissions: canEditSubmissions,
            canDeleteSubmissions: canDeleteSubmissions,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$AssignmentFormsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({assignment = false, form = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (assignment) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.assignment,
                    referencedTable:
                        $$AssignmentFormsTableReferences._assignmentTable(db),
                    referencedColumn: $$AssignmentFormsTableReferences
                        ._assignmentTable(db)
                        .id,
                  ) as T;
                }
                if (form) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.form,
                    referencedTable:
                        $$AssignmentFormsTableReferences._formTable(db),
                    referencedColumn:
                        $$AssignmentFormsTableReferences._formTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$AssignmentFormsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $AssignmentFormsTable,
    AssignmentForm,
    $$AssignmentFormsTableFilterComposer,
    $$AssignmentFormsTableOrderingComposer,
    $$AssignmentFormsTableAnnotationComposer,
    $$AssignmentFormsTableCreateCompanionBuilder,
    $$AssignmentFormsTableUpdateCompanionBuilder,
    (AssignmentForm, $$AssignmentFormsTableReferences),
    AssignmentForm,
    PrefetchHooks Function({bool assignment, bool form})>;
typedef $$MetadataSubmissionsTableCreateCompanionBuilder
    = MetadataSubmissionsCompanion Function({
  required String id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  required MetadataResourceType resourceType,
  required String metadataSchema,
  required int serialNumber,
  required int version,
  required String resourceId,
  Value<Map<String, dynamic>?> formData,
  Value<String?> createdBy,
  Value<String?> lastModifiedBy,
  Value<int> rowid,
});
typedef $$MetadataSubmissionsTableUpdateCompanionBuilder
    = MetadataSubmissionsCompanion Function({
  Value<String> id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<MetadataResourceType> resourceType,
  Value<String> metadataSchema,
  Value<int> serialNumber,
  Value<int> version,
  Value<String> resourceId,
  Value<Map<String, dynamic>?> formData,
  Value<String?> createdBy,
  Value<String?> lastModifiedBy,
  Value<int> rowid,
});

class $$MetadataSubmissionsTableFilterComposer
    extends Composer<_$AppDatabase, $MetadataSubmissionsTable> {
  $$MetadataSubmissionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<MetadataResourceType, MetadataResourceType,
          String>
      get resourceType => $composableBuilder(
          column: $table.resourceType,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<String> get metadataSchema => $composableBuilder(
      column: $table.metadataSchema,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get serialNumber => $composableBuilder(
      column: $table.serialNumber, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get version => $composableBuilder(
      column: $table.version, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get resourceId => $composableBuilder(
      column: $table.resourceId, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<Map<String, dynamic>?, Map<String, dynamic>,
          String>
      get formData => $composableBuilder(
          column: $table.formData,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<String> get createdBy => $composableBuilder(
      column: $table.createdBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get lastModifiedBy => $composableBuilder(
      column: $table.lastModifiedBy,
      builder: (column) => ColumnFilters(column));
}

class $$MetadataSubmissionsTableOrderingComposer
    extends Composer<_$AppDatabase, $MetadataSubmissionsTable> {
  $$MetadataSubmissionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get resourceType => $composableBuilder(
      column: $table.resourceType,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get metadataSchema => $composableBuilder(
      column: $table.metadataSchema,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get serialNumber => $composableBuilder(
      column: $table.serialNumber,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get version => $composableBuilder(
      column: $table.version, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get resourceId => $composableBuilder(
      column: $table.resourceId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get formData => $composableBuilder(
      column: $table.formData, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get createdBy => $composableBuilder(
      column: $table.createdBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get lastModifiedBy => $composableBuilder(
      column: $table.lastModifiedBy,
      builder: (column) => ColumnOrderings(column));
}

class $$MetadataSubmissionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $MetadataSubmissionsTable> {
  $$MetadataSubmissionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate, builder: (column) => column);

  GeneratedColumn<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => column);

  GeneratedColumnWithTypeConverter<MetadataResourceType, String>
      get resourceType => $composableBuilder(
          column: $table.resourceType, builder: (column) => column);

  GeneratedColumn<String> get metadataSchema => $composableBuilder(
      column: $table.metadataSchema, builder: (column) => column);

  GeneratedColumn<int> get serialNumber => $composableBuilder(
      column: $table.serialNumber, builder: (column) => column);

  GeneratedColumn<int> get version =>
      $composableBuilder(column: $table.version, builder: (column) => column);

  GeneratedColumn<String> get resourceId => $composableBuilder(
      column: $table.resourceId, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
      get formData => $composableBuilder(
          column: $table.formData, builder: (column) => column);

  GeneratedColumn<String> get createdBy =>
      $composableBuilder(column: $table.createdBy, builder: (column) => column);

  GeneratedColumn<String> get lastModifiedBy => $composableBuilder(
      column: $table.lastModifiedBy, builder: (column) => column);
}

class $$MetadataSubmissionsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $MetadataSubmissionsTable,
    MetadataSubmission,
    $$MetadataSubmissionsTableFilterComposer,
    $$MetadataSubmissionsTableOrderingComposer,
    $$MetadataSubmissionsTableAnnotationComposer,
    $$MetadataSubmissionsTableCreateCompanionBuilder,
    $$MetadataSubmissionsTableUpdateCompanionBuilder,
    (
      MetadataSubmission,
      BaseReferences<_$AppDatabase, $MetadataSubmissionsTable,
          MetadataSubmission>
    ),
    MetadataSubmission,
    PrefetchHooks Function()> {
  $$MetadataSubmissionsTableTableManager(
      _$AppDatabase db, $MetadataSubmissionsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$MetadataSubmissionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$MetadataSubmissionsTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$MetadataSubmissionsTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<MetadataResourceType> resourceType = const Value.absent(),
            Value<String> metadataSchema = const Value.absent(),
            Value<int> serialNumber = const Value.absent(),
            Value<int> version = const Value.absent(),
            Value<String> resourceId = const Value.absent(),
            Value<Map<String, dynamic>?> formData = const Value.absent(),
            Value<String?> createdBy = const Value.absent(),
            Value<String?> lastModifiedBy = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              MetadataSubmissionsCompanion(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            resourceType: resourceType,
            metadataSchema: metadataSchema,
            serialNumber: serialNumber,
            version: version,
            resourceId: resourceId,
            formData: formData,
            createdBy: createdBy,
            lastModifiedBy: lastModifiedBy,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            required MetadataResourceType resourceType,
            required String metadataSchema,
            required int serialNumber,
            required int version,
            required String resourceId,
            Value<Map<String, dynamic>?> formData = const Value.absent(),
            Value<String?> createdBy = const Value.absent(),
            Value<String?> lastModifiedBy = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              MetadataSubmissionsCompanion.insert(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            resourceType: resourceType,
            metadataSchema: metadataSchema,
            serialNumber: serialNumber,
            version: version,
            resourceId: resourceId,
            formData: formData,
            createdBy: createdBy,
            lastModifiedBy: lastModifiedBy,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$MetadataSubmissionsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $MetadataSubmissionsTable,
    MetadataSubmission,
    $$MetadataSubmissionsTableFilterComposer,
    $$MetadataSubmissionsTableOrderingComposer,
    $$MetadataSubmissionsTableAnnotationComposer,
    $$MetadataSubmissionsTableCreateCompanionBuilder,
    $$MetadataSubmissionsTableUpdateCompanionBuilder,
    (
      MetadataSubmission,
      BaseReferences<_$AppDatabase, $MetadataSubmissionsTable,
          MetadataSubmission>
    ),
    MetadataSubmission,
    PrefetchHooks Function()>;
typedef $$FormTemplateVersionsTableCreateCompanionBuilder
    = FormTemplateVersionsCompanion Function({
  required String id,
  required String template,
  required int versionNumber,
  required List<Template> fields,
  required List<Template> sections,
  Value<int> rowid,
});
typedef $$FormTemplateVersionsTableUpdateCompanionBuilder
    = FormTemplateVersionsCompanion Function({
  Value<String> id,
  Value<String> template,
  Value<int> versionNumber,
  Value<List<Template>> fields,
  Value<List<Template>> sections,
  Value<int> rowid,
});

final class $$FormTemplateVersionsTableReferences extends BaseReferences<
    _$AppDatabase, $FormTemplateVersionsTable, FormTemplateVersion> {
  $$FormTemplateVersionsTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $FormTemplatesTable _templateTable(_$AppDatabase db) =>
      db.formTemplates.createAlias($_aliasNameGenerator(
          db.formTemplateVersions.template, db.formTemplates.id));

  $$FormTemplatesTableProcessedTableManager get template {
    final $_column = $_itemColumn<String>('template')!;

    final manager = $$FormTemplatesTableTableManager($_db, $_db.formTemplates)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_templateTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$DataSubmissionsTable, List<DataSubmission>>
      _templateVerDataTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
          db.dataSubmissions,
          aliasName: $_aliasNameGenerator(
              db.formTemplateVersions.id, db.dataSubmissions.dataTemplateVer));

  $$DataSubmissionsTableProcessedTableManager get templateVerData {
    final manager =
        $$DataSubmissionsTableTableManager($_db, $_db.dataSubmissions).filter(
            (f) => f.dataTemplateVer.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_templateVerDataTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$FormTemplateVersionsTableFilterComposer
    extends Composer<_$AppDatabase, $FormTemplateVersionsTable> {
  $$FormTemplateVersionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get versionNumber => $composableBuilder(
      column: $table.versionNumber, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<List<Template>, List<Template>, String>
      get fields => $composableBuilder(
          column: $table.fields,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnWithTypeConverterFilters<List<Template>, List<Template>, String>
      get sections => $composableBuilder(
          column: $table.sections,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  $$FormTemplatesTableFilterComposer get template {
    final $$FormTemplatesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.template,
        referencedTable: $db.formTemplates,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FormTemplatesTableFilterComposer(
              $db: $db,
              $table: $db.formTemplates,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> templateVerData(
      Expression<bool> Function($$DataSubmissionsTableFilterComposer f) f) {
    final $$DataSubmissionsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.dataTemplateVer,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableFilterComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$FormTemplateVersionsTableOrderingComposer
    extends Composer<_$AppDatabase, $FormTemplateVersionsTable> {
  $$FormTemplateVersionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get versionNumber => $composableBuilder(
      column: $table.versionNumber,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get fields => $composableBuilder(
      column: $table.fields, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get sections => $composableBuilder(
      column: $table.sections, builder: (column) => ColumnOrderings(column));

  $$FormTemplatesTableOrderingComposer get template {
    final $$FormTemplatesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.template,
        referencedTable: $db.formTemplates,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FormTemplatesTableOrderingComposer(
              $db: $db,
              $table: $db.formTemplates,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$FormTemplateVersionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $FormTemplateVersionsTable> {
  $$FormTemplateVersionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get versionNumber => $composableBuilder(
      column: $table.versionNumber, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<Template>, String> get fields =>
      $composableBuilder(column: $table.fields, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<Template>, String> get sections =>
      $composableBuilder(column: $table.sections, builder: (column) => column);

  $$FormTemplatesTableAnnotationComposer get template {
    final $$FormTemplatesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.template,
        referencedTable: $db.formTemplates,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FormTemplatesTableAnnotationComposer(
              $db: $db,
              $table: $db.formTemplates,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> templateVerData<T extends Object>(
      Expression<T> Function($$DataSubmissionsTableAnnotationComposer a) f) {
    final $$DataSubmissionsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.dataTemplateVer,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableAnnotationComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$FormTemplateVersionsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $FormTemplateVersionsTable,
    FormTemplateVersion,
    $$FormTemplateVersionsTableFilterComposer,
    $$FormTemplateVersionsTableOrderingComposer,
    $$FormTemplateVersionsTableAnnotationComposer,
    $$FormTemplateVersionsTableCreateCompanionBuilder,
    $$FormTemplateVersionsTableUpdateCompanionBuilder,
    (FormTemplateVersion, $$FormTemplateVersionsTableReferences),
    FormTemplateVersion,
    PrefetchHooks Function({bool template, bool templateVerData})> {
  $$FormTemplateVersionsTableTableManager(
      _$AppDatabase db, $FormTemplateVersionsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FormTemplateVersionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FormTemplateVersionsTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FormTemplateVersionsTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<String> template = const Value.absent(),
            Value<int> versionNumber = const Value.absent(),
            Value<List<Template>> fields = const Value.absent(),
            Value<List<Template>> sections = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              FormTemplateVersionsCompanion(
            id: id,
            template: template,
            versionNumber: versionNumber,
            fields: fields,
            sections: sections,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            required String template,
            required int versionNumber,
            required List<Template> fields,
            required List<Template> sections,
            Value<int> rowid = const Value.absent(),
          }) =>
              FormTemplateVersionsCompanion.insert(
            id: id,
            template: template,
            versionNumber: versionNumber,
            fields: fields,
            sections: sections,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$FormTemplateVersionsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({template = false, templateVerData = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (templateVerData) db.dataSubmissions
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (template) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.template,
                    referencedTable: $$FormTemplateVersionsTableReferences
                        ._templateTable(db),
                    referencedColumn: $$FormTemplateVersionsTableReferences
                        ._templateTable(db)
                        .id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (templateVerData)
                    await $_getPrefetchedData<FormTemplateVersion,
                            $FormTemplateVersionsTable, DataSubmission>(
                        currentTable: table,
                        referencedTable: $$FormTemplateVersionsTableReferences
                            ._templateVerDataTable(db),
                        managerFromTypedResult: (p0) =>
                            $$FormTemplateVersionsTableReferences(db, table, p0)
                                .templateVerData,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.dataTemplateVer == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$FormTemplateVersionsTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $FormTemplateVersionsTable,
        FormTemplateVersion,
        $$FormTemplateVersionsTableFilterComposer,
        $$FormTemplateVersionsTableOrderingComposer,
        $$FormTemplateVersionsTableAnnotationComposer,
        $$FormTemplateVersionsTableCreateCompanionBuilder,
        $$FormTemplateVersionsTableUpdateCompanionBuilder,
        (FormTemplateVersion, $$FormTemplateVersionsTableReferences),
        FormTemplateVersion,
        PrefetchHooks Function({bool template, bool templateVerData})>;
typedef $$StageDefinitionsTableCreateCompanionBuilder
    = StageDefinitionsCompanion Function({
  required String id,
  required String name,
  Value<String?> code,
  Value<String?> stepLabel,
  Value<String?> description,
  Value<bool?> openAfterFLowRun,
  required bool repeatable,
  required int stepOrder,
  required String flowType,
  required String dataTemplate,
  Value<int> rowid,
});
typedef $$StageDefinitionsTableUpdateCompanionBuilder
    = StageDefinitionsCompanion Function({
  Value<String> id,
  Value<String> name,
  Value<String?> code,
  Value<String?> stepLabel,
  Value<String?> description,
  Value<bool?> openAfterFLowRun,
  Value<bool> repeatable,
  Value<int> stepOrder,
  Value<String> flowType,
  Value<String> dataTemplate,
  Value<int> rowid,
});

final class $$StageDefinitionsTableReferences extends BaseReferences<
    _$AppDatabase, $StageDefinitionsTable, StageDefinition> {
  $$StageDefinitionsTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $FlowTypesTable _flowTypeTable(_$AppDatabase db) =>
      db.flowTypes.createAlias(
          $_aliasNameGenerator(db.stageDefinitions.flowType, db.flowTypes.id));

  $$FlowTypesTableProcessedTableManager get flowType {
    final $_column = $_itemColumn<String>('flow_type')!;

    final manager = $$FlowTypesTableTableManager($_db, $_db.flowTypes)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_flowTypeTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $FormTemplatesTable _dataTemplateTable(_$AppDatabase db) =>
      db.formTemplates.createAlias($_aliasNameGenerator(
          db.stageDefinitions.dataTemplate, db.formTemplates.id));

  $$FormTemplatesTableProcessedTableManager get dataTemplate {
    final $_column = $_itemColumn<String>('data_template')!;

    final manager = $$FormTemplatesTableTableManager($_db, $_db.formTemplates)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_dataTemplateTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$DataSubmissionsTable, List<DataSubmission>>
      _stageDataTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.dataSubmissions,
              aliasName: $_aliasNameGenerator(
                  db.stageDefinitions.id, db.dataSubmissions.stageDefinition));

  $$DataSubmissionsTableProcessedTableManager get stageData {
    final manager =
        $$DataSubmissionsTableTableManager($_db, $_db.dataSubmissions).filter(
            (f) => f.stageDefinition.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_stageDataTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$StageDefinitionsTableFilterComposer
    extends Composer<_$AppDatabase, $StageDefinitionsTable> {
  $$StageDefinitionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get stepLabel => $composableBuilder(
      column: $table.stepLabel, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get openAfterFLowRun => $composableBuilder(
      column: $table.openAfterFLowRun,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get repeatable => $composableBuilder(
      column: $table.repeatable, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get stepOrder => $composableBuilder(
      column: $table.stepOrder, builder: (column) => ColumnFilters(column));

  $$FlowTypesTableFilterComposer get flowType {
    final $$FlowTypesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.flowType,
        referencedTable: $db.flowTypes,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowTypesTableFilterComposer(
              $db: $db,
              $table: $db.flowTypes,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$FormTemplatesTableFilterComposer get dataTemplate {
    final $$FormTemplatesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.dataTemplate,
        referencedTable: $db.formTemplates,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FormTemplatesTableFilterComposer(
              $db: $db,
              $table: $db.formTemplates,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> stageData(
      Expression<bool> Function($$DataSubmissionsTableFilterComposer f) f) {
    final $$DataSubmissionsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.stageDefinition,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableFilterComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$StageDefinitionsTableOrderingComposer
    extends Composer<_$AppDatabase, $StageDefinitionsTable> {
  $$StageDefinitionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get stepLabel => $composableBuilder(
      column: $table.stepLabel, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get openAfterFLowRun => $composableBuilder(
      column: $table.openAfterFLowRun,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get repeatable => $composableBuilder(
      column: $table.repeatable, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get stepOrder => $composableBuilder(
      column: $table.stepOrder, builder: (column) => ColumnOrderings(column));

  $$FlowTypesTableOrderingComposer get flowType {
    final $$FlowTypesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.flowType,
        referencedTable: $db.flowTypes,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowTypesTableOrderingComposer(
              $db: $db,
              $table: $db.flowTypes,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$FormTemplatesTableOrderingComposer get dataTemplate {
    final $$FormTemplatesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.dataTemplate,
        referencedTable: $db.formTemplates,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FormTemplatesTableOrderingComposer(
              $db: $db,
              $table: $db.formTemplates,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$StageDefinitionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $StageDefinitionsTable> {
  $$StageDefinitionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get stepLabel =>
      $composableBuilder(column: $table.stepLabel, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => column);

  GeneratedColumn<bool> get openAfterFLowRun => $composableBuilder(
      column: $table.openAfterFLowRun, builder: (column) => column);

  GeneratedColumn<bool> get repeatable => $composableBuilder(
      column: $table.repeatable, builder: (column) => column);

  GeneratedColumn<int> get stepOrder =>
      $composableBuilder(column: $table.stepOrder, builder: (column) => column);

  $$FlowTypesTableAnnotationComposer get flowType {
    final $$FlowTypesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.flowType,
        referencedTable: $db.flowTypes,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowTypesTableAnnotationComposer(
              $db: $db,
              $table: $db.flowTypes,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$FormTemplatesTableAnnotationComposer get dataTemplate {
    final $$FormTemplatesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.dataTemplate,
        referencedTable: $db.formTemplates,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FormTemplatesTableAnnotationComposer(
              $db: $db,
              $table: $db.formTemplates,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> stageData<T extends Object>(
      Expression<T> Function($$DataSubmissionsTableAnnotationComposer a) f) {
    final $$DataSubmissionsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.stageDefinition,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableAnnotationComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$StageDefinitionsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $StageDefinitionsTable,
    StageDefinition,
    $$StageDefinitionsTableFilterComposer,
    $$StageDefinitionsTableOrderingComposer,
    $$StageDefinitionsTableAnnotationComposer,
    $$StageDefinitionsTableCreateCompanionBuilder,
    $$StageDefinitionsTableUpdateCompanionBuilder,
    (StageDefinition, $$StageDefinitionsTableReferences),
    StageDefinition,
    PrefetchHooks Function(
        {bool flowType, bool dataTemplate, bool stageData})> {
  $$StageDefinitionsTableTableManager(
      _$AppDatabase db, $StageDefinitionsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$StageDefinitionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$StageDefinitionsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$StageDefinitionsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<String?> stepLabel = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<bool?> openAfterFLowRun = const Value.absent(),
            Value<bool> repeatable = const Value.absent(),
            Value<int> stepOrder = const Value.absent(),
            Value<String> flowType = const Value.absent(),
            Value<String> dataTemplate = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              StageDefinitionsCompanion(
            id: id,
            name: name,
            code: code,
            stepLabel: stepLabel,
            description: description,
            openAfterFLowRun: openAfterFLowRun,
            repeatable: repeatable,
            stepOrder: stepOrder,
            flowType: flowType,
            dataTemplate: dataTemplate,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            required String name,
            Value<String?> code = const Value.absent(),
            Value<String?> stepLabel = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<bool?> openAfterFLowRun = const Value.absent(),
            required bool repeatable,
            required int stepOrder,
            required String flowType,
            required String dataTemplate,
            Value<int> rowid = const Value.absent(),
          }) =>
              StageDefinitionsCompanion.insert(
            id: id,
            name: name,
            code: code,
            stepLabel: stepLabel,
            description: description,
            openAfterFLowRun: openAfterFLowRun,
            repeatable: repeatable,
            stepOrder: stepOrder,
            flowType: flowType,
            dataTemplate: dataTemplate,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$StageDefinitionsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {flowType = false, dataTemplate = false, stageData = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (stageData) db.dataSubmissions],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (flowType) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.flowType,
                    referencedTable:
                        $$StageDefinitionsTableReferences._flowTypeTable(db),
                    referencedColumn:
                        $$StageDefinitionsTableReferences._flowTypeTable(db).id,
                  ) as T;
                }
                if (dataTemplate) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.dataTemplate,
                    referencedTable: $$StageDefinitionsTableReferences
                        ._dataTemplateTable(db),
                    referencedColumn: $$StageDefinitionsTableReferences
                        ._dataTemplateTable(db)
                        .id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (stageData)
                    await $_getPrefetchedData<StageDefinition,
                            $StageDefinitionsTable, DataSubmission>(
                        currentTable: table,
                        referencedTable: $$StageDefinitionsTableReferences
                            ._stageDataTable(db),
                        managerFromTypedResult: (p0) =>
                            $$StageDefinitionsTableReferences(db, table, p0)
                                .stageData,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.stageDefinition == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$StageDefinitionsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $StageDefinitionsTable,
    StageDefinition,
    $$StageDefinitionsTableFilterComposer,
    $$StageDefinitionsTableOrderingComposer,
    $$StageDefinitionsTableAnnotationComposer,
    $$StageDefinitionsTableCreateCompanionBuilder,
    $$StageDefinitionsTableUpdateCompanionBuilder,
    (StageDefinition, $$StageDefinitionsTableReferences),
    StageDefinition,
    PrefetchHooks Function({bool flowType, bool dataTemplate, bool stageData})>;
typedef $$DataSubmissionsTableCreateCompanionBuilder = DataSubmissionsCompanion
    Function({
  required String id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<bool> deleted,
  Value<DateTime?> deletedAt,
  required String dataTemplate,
  required String dataTemplateVer,
  Value<String?> flowInstance,
  required String flowType,
  Value<String?> team,
  Value<String?> orgUnit,
  Value<String?> stageDefinition,
  Value<String?> entityInstance,
  Value<DateTime> startEntryTime,
  Value<DateTime?> finishedEntryTime,
  Value<Map<String, dynamic>?> formData,
  Value<DateTime?> updatedAtClient,
  required InstanceSyncStatus syncState,
  Value<DateTime?> lastSyncDate,
  Value<String?> lastSyncMessage,
  required bool isToUpdate,
  Value<int> rowid,
});
typedef $$DataSubmissionsTableUpdateCompanionBuilder = DataSubmissionsCompanion
    Function({
  Value<String> id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<bool> deleted,
  Value<DateTime?> deletedAt,
  Value<String> dataTemplate,
  Value<String> dataTemplateVer,
  Value<String?> flowInstance,
  Value<String> flowType,
  Value<String?> team,
  Value<String?> orgUnit,
  Value<String?> stageDefinition,
  Value<String?> entityInstance,
  Value<DateTime> startEntryTime,
  Value<DateTime?> finishedEntryTime,
  Value<Map<String, dynamic>?> formData,
  Value<DateTime?> updatedAtClient,
  Value<InstanceSyncStatus> syncState,
  Value<DateTime?> lastSyncDate,
  Value<String?> lastSyncMessage,
  Value<bool> isToUpdate,
  Value<int> rowid,
});

final class $$DataSubmissionsTableReferences extends BaseReferences<
    _$AppDatabase, $DataSubmissionsTable, DataSubmission> {
  $$DataSubmissionsTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $FormTemplatesTable _dataTemplateTable(_$AppDatabase db) =>
      db.formTemplates.createAlias($_aliasNameGenerator(
          db.dataSubmissions.dataTemplate, db.formTemplates.id));

  $$FormTemplatesTableProcessedTableManager get dataTemplate {
    final $_column = $_itemColumn<String>('data_template')!;

    final manager = $$FormTemplatesTableTableManager($_db, $_db.formTemplates)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_dataTemplateTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $FormTemplateVersionsTable _dataTemplateVerTable(_$AppDatabase db) =>
      db.formTemplateVersions.createAlias($_aliasNameGenerator(
          db.dataSubmissions.dataTemplateVer, db.formTemplateVersions.id));

  $$FormTemplateVersionsTableProcessedTableManager get dataTemplateVer {
    final $_column = $_itemColumn<String>('data_template_ver')!;

    final manager =
        $$FormTemplateVersionsTableTableManager($_db, $_db.formTemplateVersions)
            .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_dataTemplateVerTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $FlowInstancesTable _flowInstanceTable(_$AppDatabase db) =>
      db.flowInstances.createAlias($_aliasNameGenerator(
          db.dataSubmissions.flowInstance, db.flowInstances.id));

  $$FlowInstancesTableProcessedTableManager? get flowInstance {
    final $_column = $_itemColumn<String>('flow_instance');
    if ($_column == null) return null;
    final manager = $$FlowInstancesTableTableManager($_db, $_db.flowInstances)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_flowInstanceTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $FlowTypesTable _flowTypeTable(_$AppDatabase db) =>
      db.flowTypes.createAlias(
          $_aliasNameGenerator(db.dataSubmissions.flowType, db.flowTypes.id));

  $$FlowTypesTableProcessedTableManager get flowType {
    final $_column = $_itemColumn<String>('flow_type')!;

    final manager = $$FlowTypesTableTableManager($_db, $_db.flowTypes)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_flowTypeTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $TeamsTable _teamTable(_$AppDatabase db) => db.teams
      .createAlias($_aliasNameGenerator(db.dataSubmissions.team, db.teams.id));

  $$TeamsTableProcessedTableManager? get team {
    final $_column = $_itemColumn<String>('team');
    if ($_column == null) return null;
    final manager = $$TeamsTableTableManager($_db, $_db.teams)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_teamTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $OrgUnitsTable _orgUnitTable(_$AppDatabase db) =>
      db.orgUnits.createAlias(
          $_aliasNameGenerator(db.dataSubmissions.orgUnit, db.orgUnits.id));

  $$OrgUnitsTableProcessedTableManager? get orgUnit {
    final $_column = $_itemColumn<String>('org_unit');
    if ($_column == null) return null;
    final manager = $$OrgUnitsTableTableManager($_db, $_db.orgUnits)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_orgUnitTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $StageDefinitionsTable _stageDefinitionTable(_$AppDatabase db) =>
      db.stageDefinitions.createAlias($_aliasNameGenerator(
          db.dataSubmissions.stageDefinition, db.stageDefinitions.id));

  $$StageDefinitionsTableProcessedTableManager? get stageDefinition {
    final $_column = $_itemColumn<String>('stage_definition');
    if ($_column == null) return null;
    final manager =
        $$StageDefinitionsTableTableManager($_db, $_db.stageDefinitions)
            .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_stageDefinitionTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $EntityInstancesTable _entityInstanceTable(_$AppDatabase db) =>
      db.entityInstances.createAlias($_aliasNameGenerator(
          db.dataSubmissions.entityInstance, db.entityInstances.id));

  $$EntityInstancesTableProcessedTableManager? get entityInstance {
    final $_column = $_itemColumn<String>('entity_instance');
    if ($_column == null) return null;
    final manager =
        $$EntityInstancesTableTableManager($_db, $_db.entityInstances)
            .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_entityInstanceTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$RepeatInstancesTable, List<RepeatInstance>>
      _repeatInstancesRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.repeatInstances,
              aliasName: $_aliasNameGenerator(
                  db.dataSubmissions.id, db.repeatInstances.submission));

  $$RepeatInstancesTableProcessedTableManager get repeatInstancesRefs {
    final manager = $$RepeatInstancesTableTableManager(
            $_db, $_db.repeatInstances)
        .filter((f) => f.submission.id.sqlEquals($_itemColumn<String>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_repeatInstancesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$DataValuesTable, List<DataValue>>
      _dataInstanceValuesTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.dataValues,
              aliasName: $_aliasNameGenerator(
                  db.dataSubmissions.id, db.dataValues.dataInstance));

  $$DataValuesTableProcessedTableManager get dataInstanceValues {
    final manager = $$DataValuesTableTableManager($_db, $_db.dataValues).filter(
        (f) => f.dataInstance.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_dataInstanceValuesTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$DataSubmissionsTableFilterComposer
    extends Composer<_$AppDatabase, $DataSubmissionsTable> {
  $$DataSubmissionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get deleted => $composableBuilder(
      column: $table.deleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
      column: $table.deletedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get startEntryTime => $composableBuilder(
      column: $table.startEntryTime,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get finishedEntryTime => $composableBuilder(
      column: $table.finishedEntryTime,
      builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<Map<String, dynamic>?, Map<String, dynamic>,
          String>
      get formData => $composableBuilder(
          column: $table.formData,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<DateTime> get updatedAtClient => $composableBuilder(
      column: $table.updatedAtClient,
      builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<InstanceSyncStatus, InstanceSyncStatus, String>
      get syncState => $composableBuilder(
          column: $table.syncState,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<DateTime> get lastSyncDate => $composableBuilder(
      column: $table.lastSyncDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get lastSyncMessage => $composableBuilder(
      column: $table.lastSyncMessage,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isToUpdate => $composableBuilder(
      column: $table.isToUpdate, builder: (column) => ColumnFilters(column));

  $$FormTemplatesTableFilterComposer get dataTemplate {
    final $$FormTemplatesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.dataTemplate,
        referencedTable: $db.formTemplates,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FormTemplatesTableFilterComposer(
              $db: $db,
              $table: $db.formTemplates,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$FormTemplateVersionsTableFilterComposer get dataTemplateVer {
    final $$FormTemplateVersionsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.dataTemplateVer,
        referencedTable: $db.formTemplateVersions,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FormTemplateVersionsTableFilterComposer(
              $db: $db,
              $table: $db.formTemplateVersions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$FlowInstancesTableFilterComposer get flowInstance {
    final $$FlowInstancesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.flowInstance,
        referencedTable: $db.flowInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowInstancesTableFilterComposer(
              $db: $db,
              $table: $db.flowInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$FlowTypesTableFilterComposer get flowType {
    final $$FlowTypesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.flowType,
        referencedTable: $db.flowTypes,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowTypesTableFilterComposer(
              $db: $db,
              $table: $db.flowTypes,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$TeamsTableFilterComposer get team {
    final $$TeamsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.team,
        referencedTable: $db.teams,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$TeamsTableFilterComposer(
              $db: $db,
              $table: $db.teams,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$OrgUnitsTableFilterComposer get orgUnit {
    final $$OrgUnitsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orgUnit,
        referencedTable: $db.orgUnits,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrgUnitsTableFilterComposer(
              $db: $db,
              $table: $db.orgUnits,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$StageDefinitionsTableFilterComposer get stageDefinition {
    final $$StageDefinitionsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.stageDefinition,
        referencedTable: $db.stageDefinitions,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$StageDefinitionsTableFilterComposer(
              $db: $db,
              $table: $db.stageDefinitions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$EntityInstancesTableFilterComposer get entityInstance {
    final $$EntityInstancesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.entityInstance,
        referencedTable: $db.entityInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$EntityInstancesTableFilterComposer(
              $db: $db,
              $table: $db.entityInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> repeatInstancesRefs(
      Expression<bool> Function($$RepeatInstancesTableFilterComposer f) f) {
    final $$RepeatInstancesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.repeatInstances,
        getReferencedColumn: (t) => t.submission,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$RepeatInstancesTableFilterComposer(
              $db: $db,
              $table: $db.repeatInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> dataInstanceValues(
      Expression<bool> Function($$DataValuesTableFilterComposer f) f) {
    final $$DataValuesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataValues,
        getReferencedColumn: (t) => t.dataInstance,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataValuesTableFilterComposer(
              $db: $db,
              $table: $db.dataValues,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$DataSubmissionsTableOrderingComposer
    extends Composer<_$AppDatabase, $DataSubmissionsTable> {
  $$DataSubmissionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get deleted => $composableBuilder(
      column: $table.deleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
      column: $table.deletedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get startEntryTime => $composableBuilder(
      column: $table.startEntryTime,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get finishedEntryTime => $composableBuilder(
      column: $table.finishedEntryTime,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get formData => $composableBuilder(
      column: $table.formData, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAtClient => $composableBuilder(
      column: $table.updatedAtClient,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get syncState => $composableBuilder(
      column: $table.syncState, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastSyncDate => $composableBuilder(
      column: $table.lastSyncDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get lastSyncMessage => $composableBuilder(
      column: $table.lastSyncMessage,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isToUpdate => $composableBuilder(
      column: $table.isToUpdate, builder: (column) => ColumnOrderings(column));

  $$FormTemplatesTableOrderingComposer get dataTemplate {
    final $$FormTemplatesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.dataTemplate,
        referencedTable: $db.formTemplates,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FormTemplatesTableOrderingComposer(
              $db: $db,
              $table: $db.formTemplates,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$FormTemplateVersionsTableOrderingComposer get dataTemplateVer {
    final $$FormTemplateVersionsTableOrderingComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.dataTemplateVer,
            referencedTable: $db.formTemplateVersions,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$FormTemplateVersionsTableOrderingComposer(
                  $db: $db,
                  $table: $db.formTemplateVersions,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return composer;
  }

  $$FlowInstancesTableOrderingComposer get flowInstance {
    final $$FlowInstancesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.flowInstance,
        referencedTable: $db.flowInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowInstancesTableOrderingComposer(
              $db: $db,
              $table: $db.flowInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$FlowTypesTableOrderingComposer get flowType {
    final $$FlowTypesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.flowType,
        referencedTable: $db.flowTypes,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowTypesTableOrderingComposer(
              $db: $db,
              $table: $db.flowTypes,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$TeamsTableOrderingComposer get team {
    final $$TeamsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.team,
        referencedTable: $db.teams,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$TeamsTableOrderingComposer(
              $db: $db,
              $table: $db.teams,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$OrgUnitsTableOrderingComposer get orgUnit {
    final $$OrgUnitsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orgUnit,
        referencedTable: $db.orgUnits,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrgUnitsTableOrderingComposer(
              $db: $db,
              $table: $db.orgUnits,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$StageDefinitionsTableOrderingComposer get stageDefinition {
    final $$StageDefinitionsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.stageDefinition,
        referencedTable: $db.stageDefinitions,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$StageDefinitionsTableOrderingComposer(
              $db: $db,
              $table: $db.stageDefinitions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$EntityInstancesTableOrderingComposer get entityInstance {
    final $$EntityInstancesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.entityInstance,
        referencedTable: $db.entityInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$EntityInstancesTableOrderingComposer(
              $db: $db,
              $table: $db.entityInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$DataSubmissionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $DataSubmissionsTable> {
  $$DataSubmissionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate, builder: (column) => column);

  GeneratedColumn<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => column);

  GeneratedColumn<bool> get deleted =>
      $composableBuilder(column: $table.deleted, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get startEntryTime => $composableBuilder(
      column: $table.startEntryTime, builder: (column) => column);

  GeneratedColumn<DateTime> get finishedEntryTime => $composableBuilder(
      column: $table.finishedEntryTime, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
      get formData => $composableBuilder(
          column: $table.formData, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAtClient => $composableBuilder(
      column: $table.updatedAtClient, builder: (column) => column);

  GeneratedColumnWithTypeConverter<InstanceSyncStatus, String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncDate => $composableBuilder(
      column: $table.lastSyncDate, builder: (column) => column);

  GeneratedColumn<String> get lastSyncMessage => $composableBuilder(
      column: $table.lastSyncMessage, builder: (column) => column);

  GeneratedColumn<bool> get isToUpdate => $composableBuilder(
      column: $table.isToUpdate, builder: (column) => column);

  $$FormTemplatesTableAnnotationComposer get dataTemplate {
    final $$FormTemplatesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.dataTemplate,
        referencedTable: $db.formTemplates,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FormTemplatesTableAnnotationComposer(
              $db: $db,
              $table: $db.formTemplates,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$FormTemplateVersionsTableAnnotationComposer get dataTemplateVer {
    final $$FormTemplateVersionsTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.dataTemplateVer,
            referencedTable: $db.formTemplateVersions,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$FormTemplateVersionsTableAnnotationComposer(
                  $db: $db,
                  $table: $db.formTemplateVersions,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return composer;
  }

  $$FlowInstancesTableAnnotationComposer get flowInstance {
    final $$FlowInstancesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.flowInstance,
        referencedTable: $db.flowInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowInstancesTableAnnotationComposer(
              $db: $db,
              $table: $db.flowInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$FlowTypesTableAnnotationComposer get flowType {
    final $$FlowTypesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.flowType,
        referencedTable: $db.flowTypes,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FlowTypesTableAnnotationComposer(
              $db: $db,
              $table: $db.flowTypes,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$TeamsTableAnnotationComposer get team {
    final $$TeamsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.team,
        referencedTable: $db.teams,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$TeamsTableAnnotationComposer(
              $db: $db,
              $table: $db.teams,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$OrgUnitsTableAnnotationComposer get orgUnit {
    final $$OrgUnitsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orgUnit,
        referencedTable: $db.orgUnits,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrgUnitsTableAnnotationComposer(
              $db: $db,
              $table: $db.orgUnits,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$StageDefinitionsTableAnnotationComposer get stageDefinition {
    final $$StageDefinitionsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.stageDefinition,
        referencedTable: $db.stageDefinitions,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$StageDefinitionsTableAnnotationComposer(
              $db: $db,
              $table: $db.stageDefinitions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$EntityInstancesTableAnnotationComposer get entityInstance {
    final $$EntityInstancesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.entityInstance,
        referencedTable: $db.entityInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$EntityInstancesTableAnnotationComposer(
              $db: $db,
              $table: $db.entityInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> repeatInstancesRefs<T extends Object>(
      Expression<T> Function($$RepeatInstancesTableAnnotationComposer a) f) {
    final $$RepeatInstancesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.repeatInstances,
        getReferencedColumn: (t) => t.submission,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$RepeatInstancesTableAnnotationComposer(
              $db: $db,
              $table: $db.repeatInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> dataInstanceValues<T extends Object>(
      Expression<T> Function($$DataValuesTableAnnotationComposer a) f) {
    final $$DataValuesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataValues,
        getReferencedColumn: (t) => t.dataInstance,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataValuesTableAnnotationComposer(
              $db: $db,
              $table: $db.dataValues,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$DataSubmissionsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $DataSubmissionsTable,
    DataSubmission,
    $$DataSubmissionsTableFilterComposer,
    $$DataSubmissionsTableOrderingComposer,
    $$DataSubmissionsTableAnnotationComposer,
    $$DataSubmissionsTableCreateCompanionBuilder,
    $$DataSubmissionsTableUpdateCompanionBuilder,
    (DataSubmission, $$DataSubmissionsTableReferences),
    DataSubmission,
    PrefetchHooks Function(
        {bool dataTemplate,
        bool dataTemplateVer,
        bool flowInstance,
        bool flowType,
        bool team,
        bool orgUnit,
        bool stageDefinition,
        bool entityInstance,
        bool repeatInstancesRefs,
        bool dataInstanceValues})> {
  $$DataSubmissionsTableTableManager(
      _$AppDatabase db, $DataSubmissionsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DataSubmissionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DataSubmissionsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DataSubmissionsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<bool> deleted = const Value.absent(),
            Value<DateTime?> deletedAt = const Value.absent(),
            Value<String> dataTemplate = const Value.absent(),
            Value<String> dataTemplateVer = const Value.absent(),
            Value<String?> flowInstance = const Value.absent(),
            Value<String> flowType = const Value.absent(),
            Value<String?> team = const Value.absent(),
            Value<String?> orgUnit = const Value.absent(),
            Value<String?> stageDefinition = const Value.absent(),
            Value<String?> entityInstance = const Value.absent(),
            Value<DateTime> startEntryTime = const Value.absent(),
            Value<DateTime?> finishedEntryTime = const Value.absent(),
            Value<Map<String, dynamic>?> formData = const Value.absent(),
            Value<DateTime?> updatedAtClient = const Value.absent(),
            Value<InstanceSyncStatus> syncState = const Value.absent(),
            Value<DateTime?> lastSyncDate = const Value.absent(),
            Value<String?> lastSyncMessage = const Value.absent(),
            Value<bool> isToUpdate = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DataSubmissionsCompanion(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            deleted: deleted,
            deletedAt: deletedAt,
            dataTemplate: dataTemplate,
            dataTemplateVer: dataTemplateVer,
            flowInstance: flowInstance,
            flowType: flowType,
            team: team,
            orgUnit: orgUnit,
            stageDefinition: stageDefinition,
            entityInstance: entityInstance,
            startEntryTime: startEntryTime,
            finishedEntryTime: finishedEntryTime,
            formData: formData,
            updatedAtClient: updatedAtClient,
            syncState: syncState,
            lastSyncDate: lastSyncDate,
            lastSyncMessage: lastSyncMessage,
            isToUpdate: isToUpdate,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<bool> deleted = const Value.absent(),
            Value<DateTime?> deletedAt = const Value.absent(),
            required String dataTemplate,
            required String dataTemplateVer,
            Value<String?> flowInstance = const Value.absent(),
            required String flowType,
            Value<String?> team = const Value.absent(),
            Value<String?> orgUnit = const Value.absent(),
            Value<String?> stageDefinition = const Value.absent(),
            Value<String?> entityInstance = const Value.absent(),
            Value<DateTime> startEntryTime = const Value.absent(),
            Value<DateTime?> finishedEntryTime = const Value.absent(),
            Value<Map<String, dynamic>?> formData = const Value.absent(),
            Value<DateTime?> updatedAtClient = const Value.absent(),
            required InstanceSyncStatus syncState,
            Value<DateTime?> lastSyncDate = const Value.absent(),
            Value<String?> lastSyncMessage = const Value.absent(),
            required bool isToUpdate,
            Value<int> rowid = const Value.absent(),
          }) =>
              DataSubmissionsCompanion.insert(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            deleted: deleted,
            deletedAt: deletedAt,
            dataTemplate: dataTemplate,
            dataTemplateVer: dataTemplateVer,
            flowInstance: flowInstance,
            flowType: flowType,
            team: team,
            orgUnit: orgUnit,
            stageDefinition: stageDefinition,
            entityInstance: entityInstance,
            startEntryTime: startEntryTime,
            finishedEntryTime: finishedEntryTime,
            formData: formData,
            updatedAtClient: updatedAtClient,
            syncState: syncState,
            lastSyncDate: lastSyncDate,
            lastSyncMessage: lastSyncMessage,
            isToUpdate: isToUpdate,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$DataSubmissionsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {dataTemplate = false,
              dataTemplateVer = false,
              flowInstance = false,
              flowType = false,
              team = false,
              orgUnit = false,
              stageDefinition = false,
              entityInstance = false,
              repeatInstancesRefs = false,
              dataInstanceValues = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (repeatInstancesRefs) db.repeatInstances,
                if (dataInstanceValues) db.dataValues
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (dataTemplate) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.dataTemplate,
                    referencedTable:
                        $$DataSubmissionsTableReferences._dataTemplateTable(db),
                    referencedColumn: $$DataSubmissionsTableReferences
                        ._dataTemplateTable(db)
                        .id,
                  ) as T;
                }
                if (dataTemplateVer) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.dataTemplateVer,
                    referencedTable: $$DataSubmissionsTableReferences
                        ._dataTemplateVerTable(db),
                    referencedColumn: $$DataSubmissionsTableReferences
                        ._dataTemplateVerTable(db)
                        .id,
                  ) as T;
                }
                if (flowInstance) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.flowInstance,
                    referencedTable:
                        $$DataSubmissionsTableReferences._flowInstanceTable(db),
                    referencedColumn: $$DataSubmissionsTableReferences
                        ._flowInstanceTable(db)
                        .id,
                  ) as T;
                }
                if (flowType) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.flowType,
                    referencedTable:
                        $$DataSubmissionsTableReferences._flowTypeTable(db),
                    referencedColumn:
                        $$DataSubmissionsTableReferences._flowTypeTable(db).id,
                  ) as T;
                }
                if (team) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.team,
                    referencedTable:
                        $$DataSubmissionsTableReferences._teamTable(db),
                    referencedColumn:
                        $$DataSubmissionsTableReferences._teamTable(db).id,
                  ) as T;
                }
                if (orgUnit) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.orgUnit,
                    referencedTable:
                        $$DataSubmissionsTableReferences._orgUnitTable(db),
                    referencedColumn:
                        $$DataSubmissionsTableReferences._orgUnitTable(db).id,
                  ) as T;
                }
                if (stageDefinition) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.stageDefinition,
                    referencedTable: $$DataSubmissionsTableReferences
                        ._stageDefinitionTable(db),
                    referencedColumn: $$DataSubmissionsTableReferences
                        ._stageDefinitionTable(db)
                        .id,
                  ) as T;
                }
                if (entityInstance) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.entityInstance,
                    referencedTable: $$DataSubmissionsTableReferences
                        ._entityInstanceTable(db),
                    referencedColumn: $$DataSubmissionsTableReferences
                        ._entityInstanceTable(db)
                        .id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (repeatInstancesRefs)
                    await $_getPrefetchedData<DataSubmission,
                            $DataSubmissionsTable, RepeatInstance>(
                        currentTable: table,
                        referencedTable: $$DataSubmissionsTableReferences
                            ._repeatInstancesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$DataSubmissionsTableReferences(db, table, p0)
                                .repeatInstancesRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.submission == item.id),
                        typedResults: items),
                  if (dataInstanceValues)
                    await $_getPrefetchedData<DataSubmission,
                            $DataSubmissionsTable, DataValue>(
                        currentTable: table,
                        referencedTable: $$DataSubmissionsTableReferences
                            ._dataInstanceValuesTable(db),
                        managerFromTypedResult: (p0) =>
                            $$DataSubmissionsTableReferences(db, table, p0)
                                .dataInstanceValues,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.dataInstance == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$DataSubmissionsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $DataSubmissionsTable,
    DataSubmission,
    $$DataSubmissionsTableFilterComposer,
    $$DataSubmissionsTableOrderingComposer,
    $$DataSubmissionsTableAnnotationComposer,
    $$DataSubmissionsTableCreateCompanionBuilder,
    $$DataSubmissionsTableUpdateCompanionBuilder,
    (DataSubmission, $$DataSubmissionsTableReferences),
    DataSubmission,
    PrefetchHooks Function(
        {bool dataTemplate,
        bool dataTemplateVer,
        bool flowInstance,
        bool flowType,
        bool team,
        bool orgUnit,
        bool stageDefinition,
        bool entityInstance,
        bool repeatInstancesRefs,
        bool dataInstanceValues})>;
typedef $$RepeatInstancesTableCreateCompanionBuilder = RepeatInstancesCompanion
    Function({
  required String id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  required String templatePath,
  required String submission,
  Value<String?> parent,
  required int repeatIndex,
  Value<int> rowid,
});
typedef $$RepeatInstancesTableUpdateCompanionBuilder = RepeatInstancesCompanion
    Function({
  Value<String> id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String> templatePath,
  Value<String> submission,
  Value<String?> parent,
  Value<int> repeatIndex,
  Value<int> rowid,
});

final class $$RepeatInstancesTableReferences extends BaseReferences<
    _$AppDatabase, $RepeatInstancesTable, RepeatInstance> {
  $$RepeatInstancesTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $DataSubmissionsTable _submissionTable(_$AppDatabase db) =>
      db.dataSubmissions.createAlias($_aliasNameGenerator(
          db.repeatInstances.submission, db.dataSubmissions.id));

  $$DataSubmissionsTableProcessedTableManager get submission {
    final $_column = $_itemColumn<String>('submission')!;

    final manager =
        $$DataSubmissionsTableTableManager($_db, $_db.dataSubmissions)
            .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_submissionTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $RepeatInstancesTable _parentTable(_$AppDatabase db) =>
      db.repeatInstances.createAlias($_aliasNameGenerator(
          db.repeatInstances.parent, db.repeatInstances.id));

  $$RepeatInstancesTableProcessedTableManager? get parent {
    final $_column = $_itemColumn<String>('parent');
    if ($_column == null) return null;
    final manager =
        $$RepeatInstancesTableTableManager($_db, $_db.repeatInstances)
            .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_parentTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$RepeatInstancesTableFilterComposer
    extends Composer<_$AppDatabase, $RepeatInstancesTable> {
  $$RepeatInstancesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get templatePath => $composableBuilder(
      column: $table.templatePath, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get repeatIndex => $composableBuilder(
      column: $table.repeatIndex, builder: (column) => ColumnFilters(column));

  $$DataSubmissionsTableFilterComposer get submission {
    final $$DataSubmissionsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.submission,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableFilterComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$RepeatInstancesTableFilterComposer get parent {
    final $$RepeatInstancesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.parent,
        referencedTable: $db.repeatInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$RepeatInstancesTableFilterComposer(
              $db: $db,
              $table: $db.repeatInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$RepeatInstancesTableOrderingComposer
    extends Composer<_$AppDatabase, $RepeatInstancesTable> {
  $$RepeatInstancesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get templatePath => $composableBuilder(
      column: $table.templatePath,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get repeatIndex => $composableBuilder(
      column: $table.repeatIndex, builder: (column) => ColumnOrderings(column));

  $$DataSubmissionsTableOrderingComposer get submission {
    final $$DataSubmissionsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.submission,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableOrderingComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$RepeatInstancesTableOrderingComposer get parent {
    final $$RepeatInstancesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.parent,
        referencedTable: $db.repeatInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$RepeatInstancesTableOrderingComposer(
              $db: $db,
              $table: $db.repeatInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$RepeatInstancesTableAnnotationComposer
    extends Composer<_$AppDatabase, $RepeatInstancesTable> {
  $$RepeatInstancesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate, builder: (column) => column);

  GeneratedColumn<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => column);

  GeneratedColumn<String> get templatePath => $composableBuilder(
      column: $table.templatePath, builder: (column) => column);

  GeneratedColumn<int> get repeatIndex => $composableBuilder(
      column: $table.repeatIndex, builder: (column) => column);

  $$DataSubmissionsTableAnnotationComposer get submission {
    final $$DataSubmissionsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.submission,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableAnnotationComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$RepeatInstancesTableAnnotationComposer get parent {
    final $$RepeatInstancesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.parent,
        referencedTable: $db.repeatInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$RepeatInstancesTableAnnotationComposer(
              $db: $db,
              $table: $db.repeatInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$RepeatInstancesTableTableManager extends RootTableManager<
    _$AppDatabase,
    $RepeatInstancesTable,
    RepeatInstance,
    $$RepeatInstancesTableFilterComposer,
    $$RepeatInstancesTableOrderingComposer,
    $$RepeatInstancesTableAnnotationComposer,
    $$RepeatInstancesTableCreateCompanionBuilder,
    $$RepeatInstancesTableUpdateCompanionBuilder,
    (RepeatInstance, $$RepeatInstancesTableReferences),
    RepeatInstance,
    PrefetchHooks Function({bool submission, bool parent})> {
  $$RepeatInstancesTableTableManager(
      _$AppDatabase db, $RepeatInstancesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RepeatInstancesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$RepeatInstancesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$RepeatInstancesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String> templatePath = const Value.absent(),
            Value<String> submission = const Value.absent(),
            Value<String?> parent = const Value.absent(),
            Value<int> repeatIndex = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              RepeatInstancesCompanion(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            templatePath: templatePath,
            submission: submission,
            parent: parent,
            repeatIndex: repeatIndex,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            required String templatePath,
            required String submission,
            Value<String?> parent = const Value.absent(),
            required int repeatIndex,
            Value<int> rowid = const Value.absent(),
          }) =>
              RepeatInstancesCompanion.insert(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            templatePath: templatePath,
            submission: submission,
            parent: parent,
            repeatIndex: repeatIndex,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$RepeatInstancesTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({submission = false, parent = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (submission) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.submission,
                    referencedTable:
                        $$RepeatInstancesTableReferences._submissionTable(db),
                    referencedColumn: $$RepeatInstancesTableReferences
                        ._submissionTable(db)
                        .id,
                  ) as T;
                }
                if (parent) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.parent,
                    referencedTable:
                        $$RepeatInstancesTableReferences._parentTable(db),
                    referencedColumn:
                        $$RepeatInstancesTableReferences._parentTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$RepeatInstancesTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $RepeatInstancesTable,
    RepeatInstance,
    $$RepeatInstancesTableFilterComposer,
    $$RepeatInstancesTableOrderingComposer,
    $$RepeatInstancesTableAnnotationComposer,
    $$RepeatInstancesTableCreateCompanionBuilder,
    $$RepeatInstancesTableUpdateCompanionBuilder,
    (RepeatInstance, $$RepeatInstancesTableReferences),
    RepeatInstance,
    PrefetchHooks Function({bool submission, bool parent})>;
typedef $$DataOptionSetsTableCreateCompanionBuilder = DataOptionSetsCompanion
    Function({
  required String id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> displayName,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>> translations,
  required String name,
  Value<String?> code,
  Value<List<FormOption>> options,
  Value<int> rowid,
});
typedef $$DataOptionSetsTableUpdateCompanionBuilder = DataOptionSetsCompanion
    Function({
  Value<String> id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> displayName,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>> translations,
  Value<String> name,
  Value<String?> code,
  Value<List<FormOption>> options,
  Value<int> rowid,
});

final class $$DataOptionSetsTableReferences
    extends BaseReferences<_$AppDatabase, $DataOptionSetsTable, DataOptionSet> {
  $$DataOptionSetsTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$DataElementsTable, List<DataElement>>
      _dataElementsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.dataElements,
              aliasName: $_aliasNameGenerator(
                  db.dataOptionSets.id, db.dataElements.optionSet));

  $$DataElementsTableProcessedTableManager get dataElementsRefs {
    final manager = $$DataElementsTableTableManager($_db, $_db.dataElements)
        .filter((f) => f.optionSet.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_dataElementsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$DataOptionsTable, List<DataOption>>
      _dataOptionsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.dataOptions,
              aliasName: $_aliasNameGenerator(
                  db.dataOptionSets.id, db.dataOptions.optionSet));

  $$DataOptionsTableProcessedTableManager get dataOptionsRefs {
    final manager = $$DataOptionsTableTableManager($_db, $_db.dataOptions)
        .filter((f) => f.optionSet.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_dataOptionsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$EntityAttributesTable, List<EntityAttribute>>
      _entityAttributesRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.entityAttributes,
              aliasName: $_aliasNameGenerator(
                  db.dataOptionSets.id, db.entityAttributes.optionSet));

  $$EntityAttributesTableProcessedTableManager get entityAttributesRefs {
    final manager = $$EntityAttributesTableTableManager(
            $_db, $_db.entityAttributes)
        .filter((f) => f.optionSet.id.sqlEquals($_itemColumn<String>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_entityAttributesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$DataOptionSetsTableFilterComposer
    extends Composer<_$AppDatabase, $DataOptionSetsTable> {
  $$DataOptionSetsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<Map<String, dynamic>?, Map<String, dynamic>,
          String>
      get label => $composableBuilder(
          column: $table.label,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnWithTypeConverterFilters<List<Translation>, List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<List<FormOption>, List<FormOption>, String>
      get options => $composableBuilder(
          column: $table.options,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  Expression<bool> dataElementsRefs(
      Expression<bool> Function($$DataElementsTableFilterComposer f) f) {
    final $$DataElementsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataElements,
        getReferencedColumn: (t) => t.optionSet,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataElementsTableFilterComposer(
              $db: $db,
              $table: $db.dataElements,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> dataOptionsRefs(
      Expression<bool> Function($$DataOptionsTableFilterComposer f) f) {
    final $$DataOptionsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataOptions,
        getReferencedColumn: (t) => t.optionSet,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataOptionsTableFilterComposer(
              $db: $db,
              $table: $db.dataOptions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> entityAttributesRefs(
      Expression<bool> Function($$EntityAttributesTableFilterComposer f) f) {
    final $$EntityAttributesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.entityAttributes,
        getReferencedColumn: (t) => t.optionSet,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$EntityAttributesTableFilterComposer(
              $db: $db,
              $table: $db.entityAttributes,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$DataOptionSetsTableOrderingComposer
    extends Composer<_$AppDatabase, $DataOptionSetsTable> {
  $$DataOptionSetsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get label => $composableBuilder(
      column: $table.label, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get translations => $composableBuilder(
      column: $table.translations,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get options => $composableBuilder(
      column: $table.options, builder: (column) => ColumnOrderings(column));
}

class $$DataOptionSetsTableAnnotationComposer
    extends Composer<_$AppDatabase, $DataOptionSetsTable> {
  $$DataOptionSetsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate, builder: (column) => column);

  GeneratedColumn<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => column);

  GeneratedColumn<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String> get label =>
      $composableBuilder(column: $table.label, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<FormOption>, String> get options =>
      $composableBuilder(column: $table.options, builder: (column) => column);

  Expression<T> dataElementsRefs<T extends Object>(
      Expression<T> Function($$DataElementsTableAnnotationComposer a) f) {
    final $$DataElementsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataElements,
        getReferencedColumn: (t) => t.optionSet,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataElementsTableAnnotationComposer(
              $db: $db,
              $table: $db.dataElements,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> dataOptionsRefs<T extends Object>(
      Expression<T> Function($$DataOptionsTableAnnotationComposer a) f) {
    final $$DataOptionsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataOptions,
        getReferencedColumn: (t) => t.optionSet,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataOptionsTableAnnotationComposer(
              $db: $db,
              $table: $db.dataOptions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> entityAttributesRefs<T extends Object>(
      Expression<T> Function($$EntityAttributesTableAnnotationComposer a) f) {
    final $$EntityAttributesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.entityAttributes,
        getReferencedColumn: (t) => t.optionSet,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$EntityAttributesTableAnnotationComposer(
              $db: $db,
              $table: $db.entityAttributes,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$DataOptionSetsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $DataOptionSetsTable,
    DataOptionSet,
    $$DataOptionSetsTableFilterComposer,
    $$DataOptionSetsTableOrderingComposer,
    $$DataOptionSetsTableAnnotationComposer,
    $$DataOptionSetsTableCreateCompanionBuilder,
    $$DataOptionSetsTableUpdateCompanionBuilder,
    (DataOptionSet, $$DataOptionSetsTableReferences),
    DataOptionSet,
    PrefetchHooks Function(
        {bool dataElementsRefs,
        bool dataOptionsRefs,
        bool entityAttributesRefs})> {
  $$DataOptionSetsTableTableManager(
      _$AppDatabase db, $DataOptionSetsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DataOptionSetsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DataOptionSetsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DataOptionSetsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> displayName = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>> translations = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<List<FormOption>> options = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DataOptionSetsCompanion(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            displayName: displayName,
            label: label,
            translations: translations,
            name: name,
            code: code,
            options: options,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> displayName = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>> translations = const Value.absent(),
            required String name,
            Value<String?> code = const Value.absent(),
            Value<List<FormOption>> options = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DataOptionSetsCompanion.insert(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            displayName: displayName,
            label: label,
            translations: translations,
            name: name,
            code: code,
            options: options,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$DataOptionSetsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {dataElementsRefs = false,
              dataOptionsRefs = false,
              entityAttributesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (dataElementsRefs) db.dataElements,
                if (dataOptionsRefs) db.dataOptions,
                if (entityAttributesRefs) db.entityAttributes
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (dataElementsRefs)
                    await $_getPrefetchedData<DataOptionSet,
                            $DataOptionSetsTable, DataElement>(
                        currentTable: table,
                        referencedTable: $$DataOptionSetsTableReferences
                            ._dataElementsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$DataOptionSetsTableReferences(db, table, p0)
                                .dataElementsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.optionSet == item.id),
                        typedResults: items),
                  if (dataOptionsRefs)
                    await $_getPrefetchedData<DataOptionSet,
                            $DataOptionSetsTable, DataOption>(
                        currentTable: table,
                        referencedTable: $$DataOptionSetsTableReferences
                            ._dataOptionsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$DataOptionSetsTableReferences(db, table, p0)
                                .dataOptionsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.optionSet == item.id),
                        typedResults: items),
                  if (entityAttributesRefs)
                    await $_getPrefetchedData<DataOptionSet,
                            $DataOptionSetsTable, EntityAttribute>(
                        currentTable: table,
                        referencedTable: $$DataOptionSetsTableReferences
                            ._entityAttributesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$DataOptionSetsTableReferences(db, table, p0)
                                .entityAttributesRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.optionSet == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$DataOptionSetsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $DataOptionSetsTable,
    DataOptionSet,
    $$DataOptionSetsTableFilterComposer,
    $$DataOptionSetsTableOrderingComposer,
    $$DataOptionSetsTableAnnotationComposer,
    $$DataOptionSetsTableCreateCompanionBuilder,
    $$DataOptionSetsTableUpdateCompanionBuilder,
    (DataOptionSet, $$DataOptionSetsTableReferences),
    DataOptionSet,
    PrefetchHooks Function(
        {bool dataElementsRefs,
        bool dataOptionsRefs,
        bool entityAttributesRefs})>;
typedef $$DataElementsTableCreateCompanionBuilder = DataElementsCompanion
    Function({
  required String id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> displayName,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>> translations,
  required String name,
  Value<String?> code,
  Value<String?> description,
  required ValueType type,
  Value<String?> optionSet,
  Value<bool?> mandatory,
  Value<String?> defaultValue,
  Value<ScannedCodeProperties?> scannedCodeProperties,
  Value<bool?> gs1Enabled,
  Value<MetadataResourceType?> resourceType,
  Value<String?> resourceMetadataSchema,
  Value<int> rowid,
});
typedef $$DataElementsTableUpdateCompanionBuilder = DataElementsCompanion
    Function({
  Value<String> id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> displayName,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>> translations,
  Value<String> name,
  Value<String?> code,
  Value<String?> description,
  Value<ValueType> type,
  Value<String?> optionSet,
  Value<bool?> mandatory,
  Value<String?> defaultValue,
  Value<ScannedCodeProperties?> scannedCodeProperties,
  Value<bool?> gs1Enabled,
  Value<MetadataResourceType?> resourceType,
  Value<String?> resourceMetadataSchema,
  Value<int> rowid,
});

final class $$DataElementsTableReferences
    extends BaseReferences<_$AppDatabase, $DataElementsTable, DataElement> {
  $$DataElementsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $DataOptionSetsTable _optionSetTable(_$AppDatabase db) =>
      db.dataOptionSets.createAlias($_aliasNameGenerator(
          db.dataElements.optionSet, db.dataOptionSets.id));

  $$DataOptionSetsTableProcessedTableManager? get optionSet {
    final $_column = $_itemColumn<String>('option_set');
    if ($_column == null) return null;
    final manager = $$DataOptionSetsTableTableManager($_db, $_db.dataOptionSets)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_optionSetTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$DataValuesTable, List<DataValue>>
      _dataValuesRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.dataValues,
              aliasName: $_aliasNameGenerator(
                  db.dataElements.id, db.dataValues.dataElement));

  $$DataValuesTableProcessedTableManager get dataValuesRefs {
    final manager = $$DataValuesTableTableManager($_db, $_db.dataValues)
        .filter((f) => f.dataElement.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_dataValuesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$DataElementsTableFilterComposer
    extends Composer<_$AppDatabase, $DataElementsTable> {
  $$DataElementsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<Map<String, dynamic>?, Map<String, dynamic>,
          String>
      get label => $composableBuilder(
          column: $table.label,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnWithTypeConverterFilters<List<Translation>, List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<ValueType, ValueType, String> get type =>
      $composableBuilder(
          column: $table.type,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<bool> get mandatory => $composableBuilder(
      column: $table.mandatory, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get defaultValue => $composableBuilder(
      column: $table.defaultValue, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<ScannedCodeProperties?, ScannedCodeProperties,
          String>
      get scannedCodeProperties => $composableBuilder(
          column: $table.scannedCodeProperties,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<bool> get gs1Enabled => $composableBuilder(
      column: $table.gs1Enabled, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<MetadataResourceType?, MetadataResourceType,
          String>
      get resourceType => $composableBuilder(
          column: $table.resourceType,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<String> get resourceMetadataSchema => $composableBuilder(
      column: $table.resourceMetadataSchema,
      builder: (column) => ColumnFilters(column));

  $$DataOptionSetsTableFilterComposer get optionSet {
    final $$DataOptionSetsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.optionSet,
        referencedTable: $db.dataOptionSets,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataOptionSetsTableFilterComposer(
              $db: $db,
              $table: $db.dataOptionSets,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> dataValuesRefs(
      Expression<bool> Function($$DataValuesTableFilterComposer f) f) {
    final $$DataValuesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataValues,
        getReferencedColumn: (t) => t.dataElement,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataValuesTableFilterComposer(
              $db: $db,
              $table: $db.dataValues,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$DataElementsTableOrderingComposer
    extends Composer<_$AppDatabase, $DataElementsTable> {
  $$DataElementsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get label => $composableBuilder(
      column: $table.label, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get translations => $composableBuilder(
      column: $table.translations,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get mandatory => $composableBuilder(
      column: $table.mandatory, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get defaultValue => $composableBuilder(
      column: $table.defaultValue,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get scannedCodeProperties => $composableBuilder(
      column: $table.scannedCodeProperties,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get gs1Enabled => $composableBuilder(
      column: $table.gs1Enabled, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get resourceType => $composableBuilder(
      column: $table.resourceType,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get resourceMetadataSchema => $composableBuilder(
      column: $table.resourceMetadataSchema,
      builder: (column) => ColumnOrderings(column));

  $$DataOptionSetsTableOrderingComposer get optionSet {
    final $$DataOptionSetsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.optionSet,
        referencedTable: $db.dataOptionSets,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataOptionSetsTableOrderingComposer(
              $db: $db,
              $table: $db.dataOptionSets,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$DataElementsTableAnnotationComposer
    extends Composer<_$AppDatabase, $DataElementsTable> {
  $$DataElementsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate, builder: (column) => column);

  GeneratedColumn<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => column);

  GeneratedColumn<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String> get label =>
      $composableBuilder(column: $table.label, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => column);

  GeneratedColumnWithTypeConverter<ValueType, String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<bool> get mandatory =>
      $composableBuilder(column: $table.mandatory, builder: (column) => column);

  GeneratedColumn<String> get defaultValue => $composableBuilder(
      column: $table.defaultValue, builder: (column) => column);

  GeneratedColumnWithTypeConverter<ScannedCodeProperties?, String>
      get scannedCodeProperties => $composableBuilder(
          column: $table.scannedCodeProperties, builder: (column) => column);

  GeneratedColumn<bool> get gs1Enabled => $composableBuilder(
      column: $table.gs1Enabled, builder: (column) => column);

  GeneratedColumnWithTypeConverter<MetadataResourceType?, String>
      get resourceType => $composableBuilder(
          column: $table.resourceType, builder: (column) => column);

  GeneratedColumn<String> get resourceMetadataSchema => $composableBuilder(
      column: $table.resourceMetadataSchema, builder: (column) => column);

  $$DataOptionSetsTableAnnotationComposer get optionSet {
    final $$DataOptionSetsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.optionSet,
        referencedTable: $db.dataOptionSets,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataOptionSetsTableAnnotationComposer(
              $db: $db,
              $table: $db.dataOptionSets,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> dataValuesRefs<T extends Object>(
      Expression<T> Function($$DataValuesTableAnnotationComposer a) f) {
    final $$DataValuesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.dataValues,
        getReferencedColumn: (t) => t.dataElement,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataValuesTableAnnotationComposer(
              $db: $db,
              $table: $db.dataValues,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$DataElementsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $DataElementsTable,
    DataElement,
    $$DataElementsTableFilterComposer,
    $$DataElementsTableOrderingComposer,
    $$DataElementsTableAnnotationComposer,
    $$DataElementsTableCreateCompanionBuilder,
    $$DataElementsTableUpdateCompanionBuilder,
    (DataElement, $$DataElementsTableReferences),
    DataElement,
    PrefetchHooks Function({bool optionSet, bool dataValuesRefs})> {
  $$DataElementsTableTableManager(_$AppDatabase db, $DataElementsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DataElementsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DataElementsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DataElementsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> displayName = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>> translations = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<ValueType> type = const Value.absent(),
            Value<String?> optionSet = const Value.absent(),
            Value<bool?> mandatory = const Value.absent(),
            Value<String?> defaultValue = const Value.absent(),
            Value<ScannedCodeProperties?> scannedCodeProperties =
                const Value.absent(),
            Value<bool?> gs1Enabled = const Value.absent(),
            Value<MetadataResourceType?> resourceType = const Value.absent(),
            Value<String?> resourceMetadataSchema = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DataElementsCompanion(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            displayName: displayName,
            label: label,
            translations: translations,
            name: name,
            code: code,
            description: description,
            type: type,
            optionSet: optionSet,
            mandatory: mandatory,
            defaultValue: defaultValue,
            scannedCodeProperties: scannedCodeProperties,
            gs1Enabled: gs1Enabled,
            resourceType: resourceType,
            resourceMetadataSchema: resourceMetadataSchema,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> displayName = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>> translations = const Value.absent(),
            required String name,
            Value<String?> code = const Value.absent(),
            Value<String?> description = const Value.absent(),
            required ValueType type,
            Value<String?> optionSet = const Value.absent(),
            Value<bool?> mandatory = const Value.absent(),
            Value<String?> defaultValue = const Value.absent(),
            Value<ScannedCodeProperties?> scannedCodeProperties =
                const Value.absent(),
            Value<bool?> gs1Enabled = const Value.absent(),
            Value<MetadataResourceType?> resourceType = const Value.absent(),
            Value<String?> resourceMetadataSchema = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DataElementsCompanion.insert(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            displayName: displayName,
            label: label,
            translations: translations,
            name: name,
            code: code,
            description: description,
            type: type,
            optionSet: optionSet,
            mandatory: mandatory,
            defaultValue: defaultValue,
            scannedCodeProperties: scannedCodeProperties,
            gs1Enabled: gs1Enabled,
            resourceType: resourceType,
            resourceMetadataSchema: resourceMetadataSchema,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$DataElementsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({optionSet = false, dataValuesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (dataValuesRefs) db.dataValues],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (optionSet) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.optionSet,
                    referencedTable:
                        $$DataElementsTableReferences._optionSetTable(db),
                    referencedColumn:
                        $$DataElementsTableReferences._optionSetTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (dataValuesRefs)
                    await $_getPrefetchedData<DataElement, $DataElementsTable,
                            DataValue>(
                        currentTable: table,
                        referencedTable: $$DataElementsTableReferences
                            ._dataValuesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$DataElementsTableReferences(db, table, p0)
                                .dataValuesRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.dataElement == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$DataElementsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $DataElementsTable,
    DataElement,
    $$DataElementsTableFilterComposer,
    $$DataElementsTableOrderingComposer,
    $$DataElementsTableAnnotationComposer,
    $$DataElementsTableCreateCompanionBuilder,
    $$DataElementsTableUpdateCompanionBuilder,
    (DataElement, $$DataElementsTableReferences),
    DataElement,
    PrefetchHooks Function({bool optionSet, bool dataValuesRefs})>;
typedef $$DataValuesTableCreateCompanionBuilder = DataValuesCompanion Function({
  required String id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  required String dataElement,
  required String dataInstance,
  Value<String?> value,
  Value<String?> comment,
  Value<int> rowid,
});
typedef $$DataValuesTableUpdateCompanionBuilder = DataValuesCompanion Function({
  Value<String> id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String> dataElement,
  Value<String> dataInstance,
  Value<String?> value,
  Value<String?> comment,
  Value<int> rowid,
});

final class $$DataValuesTableReferences
    extends BaseReferences<_$AppDatabase, $DataValuesTable, DataValue> {
  $$DataValuesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $DataElementsTable _dataElementTable(_$AppDatabase db) =>
      db.dataElements.createAlias(
          $_aliasNameGenerator(db.dataValues.dataElement, db.dataElements.id));

  $$DataElementsTableProcessedTableManager get dataElement {
    final $_column = $_itemColumn<String>('data_element')!;

    final manager = $$DataElementsTableTableManager($_db, $_db.dataElements)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_dataElementTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $DataSubmissionsTable _dataInstanceTable(_$AppDatabase db) =>
      db.dataSubmissions.createAlias($_aliasNameGenerator(
          db.dataValues.dataInstance, db.dataSubmissions.id));

  $$DataSubmissionsTableProcessedTableManager get dataInstance {
    final $_column = $_itemColumn<String>('data_instance')!;

    final manager =
        $$DataSubmissionsTableTableManager($_db, $_db.dataSubmissions)
            .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_dataInstanceTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$DataValuesTableFilterComposer
    extends Composer<_$AppDatabase, $DataValuesTable> {
  $$DataValuesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get value => $composableBuilder(
      column: $table.value, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get comment => $composableBuilder(
      column: $table.comment, builder: (column) => ColumnFilters(column));

  $$DataElementsTableFilterComposer get dataElement {
    final $$DataElementsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.dataElement,
        referencedTable: $db.dataElements,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataElementsTableFilterComposer(
              $db: $db,
              $table: $db.dataElements,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$DataSubmissionsTableFilterComposer get dataInstance {
    final $$DataSubmissionsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.dataInstance,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableFilterComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$DataValuesTableOrderingComposer
    extends Composer<_$AppDatabase, $DataValuesTable> {
  $$DataValuesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get value => $composableBuilder(
      column: $table.value, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get comment => $composableBuilder(
      column: $table.comment, builder: (column) => ColumnOrderings(column));

  $$DataElementsTableOrderingComposer get dataElement {
    final $$DataElementsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.dataElement,
        referencedTable: $db.dataElements,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataElementsTableOrderingComposer(
              $db: $db,
              $table: $db.dataElements,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$DataSubmissionsTableOrderingComposer get dataInstance {
    final $$DataSubmissionsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.dataInstance,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableOrderingComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$DataValuesTableAnnotationComposer
    extends Composer<_$AppDatabase, $DataValuesTable> {
  $$DataValuesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate, builder: (column) => column);

  GeneratedColumn<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => column);

  GeneratedColumn<String> get value =>
      $composableBuilder(column: $table.value, builder: (column) => column);

  GeneratedColumn<String> get comment =>
      $composableBuilder(column: $table.comment, builder: (column) => column);

  $$DataElementsTableAnnotationComposer get dataElement {
    final $$DataElementsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.dataElement,
        referencedTable: $db.dataElements,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataElementsTableAnnotationComposer(
              $db: $db,
              $table: $db.dataElements,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$DataSubmissionsTableAnnotationComposer get dataInstance {
    final $$DataSubmissionsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.dataInstance,
        referencedTable: $db.dataSubmissions,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataSubmissionsTableAnnotationComposer(
              $db: $db,
              $table: $db.dataSubmissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$DataValuesTableTableManager extends RootTableManager<
    _$AppDatabase,
    $DataValuesTable,
    DataValue,
    $$DataValuesTableFilterComposer,
    $$DataValuesTableOrderingComposer,
    $$DataValuesTableAnnotationComposer,
    $$DataValuesTableCreateCompanionBuilder,
    $$DataValuesTableUpdateCompanionBuilder,
    (DataValue, $$DataValuesTableReferences),
    DataValue,
    PrefetchHooks Function({bool dataElement, bool dataInstance})> {
  $$DataValuesTableTableManager(_$AppDatabase db, $DataValuesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DataValuesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DataValuesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DataValuesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String> dataElement = const Value.absent(),
            Value<String> dataInstance = const Value.absent(),
            Value<String?> value = const Value.absent(),
            Value<String?> comment = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DataValuesCompanion(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            dataElement: dataElement,
            dataInstance: dataInstance,
            value: value,
            comment: comment,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            required String dataElement,
            required String dataInstance,
            Value<String?> value = const Value.absent(),
            Value<String?> comment = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DataValuesCompanion.insert(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            dataElement: dataElement,
            dataInstance: dataInstance,
            value: value,
            comment: comment,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$DataValuesTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({dataElement = false, dataInstance = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (dataElement) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.dataElement,
                    referencedTable:
                        $$DataValuesTableReferences._dataElementTable(db),
                    referencedColumn:
                        $$DataValuesTableReferences._dataElementTable(db).id,
                  ) as T;
                }
                if (dataInstance) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.dataInstance,
                    referencedTable:
                        $$DataValuesTableReferences._dataInstanceTable(db),
                    referencedColumn:
                        $$DataValuesTableReferences._dataInstanceTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$DataValuesTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $DataValuesTable,
    DataValue,
    $$DataValuesTableFilterComposer,
    $$DataValuesTableOrderingComposer,
    $$DataValuesTableAnnotationComposer,
    $$DataValuesTableCreateCompanionBuilder,
    $$DataValuesTableUpdateCompanionBuilder,
    (DataValue, $$DataValuesTableReferences),
    DataValue,
    PrefetchHooks Function({bool dataElement, bool dataInstance})>;
typedef $$DataOptionsTableCreateCompanionBuilder = DataOptionsCompanion
    Function({
  required String id,
  required String name,
  Value<String?> code,
  required String optionSet,
  Value<int> order,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>?> translations,
  Value<int> rowid,
});
typedef $$DataOptionsTableUpdateCompanionBuilder = DataOptionsCompanion
    Function({
  Value<String> id,
  Value<String> name,
  Value<String?> code,
  Value<String> optionSet,
  Value<int> order,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>?> translations,
  Value<int> rowid,
});

final class $$DataOptionsTableReferences
    extends BaseReferences<_$AppDatabase, $DataOptionsTable, DataOption> {
  $$DataOptionsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $DataOptionSetsTable _optionSetTable(_$AppDatabase db) =>
      db.dataOptionSets.createAlias(
          $_aliasNameGenerator(db.dataOptions.optionSet, db.dataOptionSets.id));

  $$DataOptionSetsTableProcessedTableManager get optionSet {
    final $_column = $_itemColumn<String>('option_set')!;

    final manager = $$DataOptionSetsTableTableManager($_db, $_db.dataOptionSets)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_optionSetTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$DataOptionsTableFilterComposer
    extends Composer<_$AppDatabase, $DataOptionsTable> {
  $$DataOptionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get order => $composableBuilder(
      column: $table.order, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<Map<String, dynamic>?, Map<String, dynamic>,
          String>
      get label => $composableBuilder(
          column: $table.label,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnWithTypeConverterFilters<List<Translation>?, List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  $$DataOptionSetsTableFilterComposer get optionSet {
    final $$DataOptionSetsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.optionSet,
        referencedTable: $db.dataOptionSets,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataOptionSetsTableFilterComposer(
              $db: $db,
              $table: $db.dataOptionSets,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$DataOptionsTableOrderingComposer
    extends Composer<_$AppDatabase, $DataOptionsTable> {
  $$DataOptionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get order => $composableBuilder(
      column: $table.order, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get label => $composableBuilder(
      column: $table.label, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get translations => $composableBuilder(
      column: $table.translations,
      builder: (column) => ColumnOrderings(column));

  $$DataOptionSetsTableOrderingComposer get optionSet {
    final $$DataOptionSetsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.optionSet,
        referencedTable: $db.dataOptionSets,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataOptionSetsTableOrderingComposer(
              $db: $db,
              $table: $db.dataOptionSets,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$DataOptionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $DataOptionsTable> {
  $$DataOptionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<int> get order =>
      $composableBuilder(column: $table.order, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String> get label =>
      $composableBuilder(column: $table.label, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<Translation>?, String>
      get translations => $composableBuilder(
          column: $table.translations, builder: (column) => column);

  $$DataOptionSetsTableAnnotationComposer get optionSet {
    final $$DataOptionSetsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.optionSet,
        referencedTable: $db.dataOptionSets,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataOptionSetsTableAnnotationComposer(
              $db: $db,
              $table: $db.dataOptionSets,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$DataOptionsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $DataOptionsTable,
    DataOption,
    $$DataOptionsTableFilterComposer,
    $$DataOptionsTableOrderingComposer,
    $$DataOptionsTableAnnotationComposer,
    $$DataOptionsTableCreateCompanionBuilder,
    $$DataOptionsTableUpdateCompanionBuilder,
    (DataOption, $$DataOptionsTableReferences),
    DataOption,
    PrefetchHooks Function({bool optionSet})> {
  $$DataOptionsTableTableManager(_$AppDatabase db, $DataOptionsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DataOptionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DataOptionsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DataOptionsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<String> optionSet = const Value.absent(),
            Value<int> order = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>?> translations = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DataOptionsCompanion(
            id: id,
            name: name,
            code: code,
            optionSet: optionSet,
            order: order,
            label: label,
            translations: translations,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            required String name,
            Value<String?> code = const Value.absent(),
            required String optionSet,
            Value<int> order = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>?> translations = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DataOptionsCompanion.insert(
            id: id,
            name: name,
            code: code,
            optionSet: optionSet,
            order: order,
            label: label,
            translations: translations,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$DataOptionsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({optionSet = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (optionSet) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.optionSet,
                    referencedTable:
                        $$DataOptionsTableReferences._optionSetTable(db),
                    referencedColumn:
                        $$DataOptionsTableReferences._optionSetTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$DataOptionsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $DataOptionsTable,
    DataOption,
    $$DataOptionsTableFilterComposer,
    $$DataOptionsTableOrderingComposer,
    $$DataOptionsTableAnnotationComposer,
    $$DataOptionsTableCreateCompanionBuilder,
    $$DataOptionsTableUpdateCompanionBuilder,
    (DataOption, $$DataOptionsTableReferences),
    DataOption,
    PrefetchHooks Function({bool optionSet})>;
typedef $$UserFormPermissionsTableCreateCompanionBuilder
    = UserFormPermissionsCompanion Function({
  required String team,
  required String form,
  Value<DateTime?> validFrom,
  Value<DateTime?> validTo,
  required List<FormPermission> permissions,
  Value<int> rowid,
});
typedef $$UserFormPermissionsTableUpdateCompanionBuilder
    = UserFormPermissionsCompanion Function({
  Value<String> team,
  Value<String> form,
  Value<DateTime?> validFrom,
  Value<DateTime?> validTo,
  Value<List<FormPermission>> permissions,
  Value<int> rowid,
});

final class $$UserFormPermissionsTableReferences extends BaseReferences<
    _$AppDatabase, $UserFormPermissionsTable, UserFormPermission> {
  $$UserFormPermissionsTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $TeamsTable _teamTable(_$AppDatabase db) => db.teams.createAlias(
      $_aliasNameGenerator(db.userFormPermissions.team, db.teams.id));

  $$TeamsTableProcessedTableManager get team {
    final $_column = $_itemColumn<String>('team')!;

    final manager = $$TeamsTableTableManager($_db, $_db.teams)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_teamTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $FormTemplatesTable _formTable(_$AppDatabase db) =>
      db.formTemplates.createAlias($_aliasNameGenerator(
          db.userFormPermissions.form, db.formTemplates.id));

  $$FormTemplatesTableProcessedTableManager get form {
    final $_column = $_itemColumn<String>('form')!;

    final manager = $$FormTemplatesTableTableManager($_db, $_db.formTemplates)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_formTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$UserFormPermissionsTableFilterComposer
    extends Composer<_$AppDatabase, $UserFormPermissionsTable> {
  $$UserFormPermissionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<DateTime> get validFrom => $composableBuilder(
      column: $table.validFrom, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get validTo => $composableBuilder(
      column: $table.validTo, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<List<FormPermission>, List<FormPermission>,
          String>
      get permissions => $composableBuilder(
          column: $table.permissions,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  $$TeamsTableFilterComposer get team {
    final $$TeamsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.team,
        referencedTable: $db.teams,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$TeamsTableFilterComposer(
              $db: $db,
              $table: $db.teams,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$FormTemplatesTableFilterComposer get form {
    final $$FormTemplatesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.form,
        referencedTable: $db.formTemplates,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FormTemplatesTableFilterComposer(
              $db: $db,
              $table: $db.formTemplates,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$UserFormPermissionsTableOrderingComposer
    extends Composer<_$AppDatabase, $UserFormPermissionsTable> {
  $$UserFormPermissionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<DateTime> get validFrom => $composableBuilder(
      column: $table.validFrom, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get validTo => $composableBuilder(
      column: $table.validTo, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get permissions => $composableBuilder(
      column: $table.permissions, builder: (column) => ColumnOrderings(column));

  $$TeamsTableOrderingComposer get team {
    final $$TeamsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.team,
        referencedTable: $db.teams,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$TeamsTableOrderingComposer(
              $db: $db,
              $table: $db.teams,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$FormTemplatesTableOrderingComposer get form {
    final $$FormTemplatesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.form,
        referencedTable: $db.formTemplates,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FormTemplatesTableOrderingComposer(
              $db: $db,
              $table: $db.formTemplates,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$UserFormPermissionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $UserFormPermissionsTable> {
  $$UserFormPermissionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<DateTime> get validFrom =>
      $composableBuilder(column: $table.validFrom, builder: (column) => column);

  GeneratedColumn<DateTime> get validTo =>
      $composableBuilder(column: $table.validTo, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<FormPermission>, String>
      get permissions => $composableBuilder(
          column: $table.permissions, builder: (column) => column);

  $$TeamsTableAnnotationComposer get team {
    final $$TeamsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.team,
        referencedTable: $db.teams,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$TeamsTableAnnotationComposer(
              $db: $db,
              $table: $db.teams,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$FormTemplatesTableAnnotationComposer get form {
    final $$FormTemplatesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.form,
        referencedTable: $db.formTemplates,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$FormTemplatesTableAnnotationComposer(
              $db: $db,
              $table: $db.formTemplates,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$UserFormPermissionsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $UserFormPermissionsTable,
    UserFormPermission,
    $$UserFormPermissionsTableFilterComposer,
    $$UserFormPermissionsTableOrderingComposer,
    $$UserFormPermissionsTableAnnotationComposer,
    $$UserFormPermissionsTableCreateCompanionBuilder,
    $$UserFormPermissionsTableUpdateCompanionBuilder,
    (UserFormPermission, $$UserFormPermissionsTableReferences),
    UserFormPermission,
    PrefetchHooks Function({bool team, bool form})> {
  $$UserFormPermissionsTableTableManager(
      _$AppDatabase db, $UserFormPermissionsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$UserFormPermissionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$UserFormPermissionsTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$UserFormPermissionsTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> team = const Value.absent(),
            Value<String> form = const Value.absent(),
            Value<DateTime?> validFrom = const Value.absent(),
            Value<DateTime?> validTo = const Value.absent(),
            Value<List<FormPermission>> permissions = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              UserFormPermissionsCompanion(
            team: team,
            form: form,
            validFrom: validFrom,
            validTo: validTo,
            permissions: permissions,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String team,
            required String form,
            Value<DateTime?> validFrom = const Value.absent(),
            Value<DateTime?> validTo = const Value.absent(),
            required List<FormPermission> permissions,
            Value<int> rowid = const Value.absent(),
          }) =>
              UserFormPermissionsCompanion.insert(
            team: team,
            form: form,
            validFrom: validFrom,
            validTo: validTo,
            permissions: permissions,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$UserFormPermissionsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({team = false, form = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (team) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.team,
                    referencedTable:
                        $$UserFormPermissionsTableReferences._teamTable(db),
                    referencedColumn:
                        $$UserFormPermissionsTableReferences._teamTable(db).id,
                  ) as T;
                }
                if (form) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.form,
                    referencedTable:
                        $$UserFormPermissionsTableReferences._formTable(db),
                    referencedColumn:
                        $$UserFormPermissionsTableReferences._formTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$UserFormPermissionsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $UserFormPermissionsTable,
    UserFormPermission,
    $$UserFormPermissionsTableFilterComposer,
    $$UserFormPermissionsTableOrderingComposer,
    $$UserFormPermissionsTableAnnotationComposer,
    $$UserFormPermissionsTableCreateCompanionBuilder,
    $$UserFormPermissionsTableUpdateCompanionBuilder,
    (UserFormPermission, $$UserFormPermissionsTableReferences),
    UserFormPermission,
    PrefetchHooks Function({bool team, bool form})>;
typedef $$EntityAttributesTableCreateCompanionBuilder
    = EntityAttributesCompanion Function({
  required String id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> displayName,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>> translations,
  Value<String?> code,
  required String name,
  Value<String?> shortName,
  Value<String?> description,
  required ValueType valueType,
  Value<String?> optionSet,
  Value<bool?> displayWhenPlanned,
  Value<bool?> mandatory,
  Value<String?> defaultValue,
  Value<int> rowid,
});
typedef $$EntityAttributesTableUpdateCompanionBuilder
    = EntityAttributesCompanion Function({
  Value<String> id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> displayName,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>> translations,
  Value<String?> code,
  Value<String> name,
  Value<String?> shortName,
  Value<String?> description,
  Value<ValueType> valueType,
  Value<String?> optionSet,
  Value<bool?> displayWhenPlanned,
  Value<bool?> mandatory,
  Value<String?> defaultValue,
  Value<int> rowid,
});

final class $$EntityAttributesTableReferences extends BaseReferences<
    _$AppDatabase, $EntityAttributesTable, EntityAttribute> {
  $$EntityAttributesTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $DataOptionSetsTable _optionSetTable(_$AppDatabase db) =>
      db.dataOptionSets.createAlias($_aliasNameGenerator(
          db.entityAttributes.optionSet, db.dataOptionSets.id));

  $$DataOptionSetsTableProcessedTableManager? get optionSet {
    final $_column = $_itemColumn<String>('option_set');
    if ($_column == null) return null;
    final manager = $$DataOptionSetsTableTableManager($_db, $_db.dataOptionSets)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_optionSetTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$EntityAttributesTableFilterComposer
    extends Composer<_$AppDatabase, $EntityAttributesTable> {
  $$EntityAttributesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<Map<String, dynamic>?, Map<String, dynamic>,
          String>
      get label => $composableBuilder(
          column: $table.label,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnWithTypeConverterFilters<List<Translation>, List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get shortName => $composableBuilder(
      column: $table.shortName, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<ValueType, ValueType, String> get valueType =>
      $composableBuilder(
          column: $table.valueType,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<bool> get displayWhenPlanned => $composableBuilder(
      column: $table.displayWhenPlanned,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get mandatory => $composableBuilder(
      column: $table.mandatory, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get defaultValue => $composableBuilder(
      column: $table.defaultValue, builder: (column) => ColumnFilters(column));

  $$DataOptionSetsTableFilterComposer get optionSet {
    final $$DataOptionSetsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.optionSet,
        referencedTable: $db.dataOptionSets,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataOptionSetsTableFilterComposer(
              $db: $db,
              $table: $db.dataOptionSets,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$EntityAttributesTableOrderingComposer
    extends Composer<_$AppDatabase, $EntityAttributesTable> {
  $$EntityAttributesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get label => $composableBuilder(
      column: $table.label, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get translations => $composableBuilder(
      column: $table.translations,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get shortName => $composableBuilder(
      column: $table.shortName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get valueType => $composableBuilder(
      column: $table.valueType, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get displayWhenPlanned => $composableBuilder(
      column: $table.displayWhenPlanned,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get mandatory => $composableBuilder(
      column: $table.mandatory, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get defaultValue => $composableBuilder(
      column: $table.defaultValue,
      builder: (column) => ColumnOrderings(column));

  $$DataOptionSetsTableOrderingComposer get optionSet {
    final $$DataOptionSetsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.optionSet,
        referencedTable: $db.dataOptionSets,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataOptionSetsTableOrderingComposer(
              $db: $db,
              $table: $db.dataOptionSets,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$EntityAttributesTableAnnotationComposer
    extends Composer<_$AppDatabase, $EntityAttributesTable> {
  $$EntityAttributesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate, builder: (column) => column);

  GeneratedColumn<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => column);

  GeneratedColumn<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String> get label =>
      $composableBuilder(column: $table.label, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get shortName =>
      $composableBuilder(column: $table.shortName, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => column);

  GeneratedColumnWithTypeConverter<ValueType, String> get valueType =>
      $composableBuilder(column: $table.valueType, builder: (column) => column);

  GeneratedColumn<bool> get displayWhenPlanned => $composableBuilder(
      column: $table.displayWhenPlanned, builder: (column) => column);

  GeneratedColumn<bool> get mandatory =>
      $composableBuilder(column: $table.mandatory, builder: (column) => column);

  GeneratedColumn<String> get defaultValue => $composableBuilder(
      column: $table.defaultValue, builder: (column) => column);

  $$DataOptionSetsTableAnnotationComposer get optionSet {
    final $$DataOptionSetsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.optionSet,
        referencedTable: $db.dataOptionSets,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$DataOptionSetsTableAnnotationComposer(
              $db: $db,
              $table: $db.dataOptionSets,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$EntityAttributesTableTableManager extends RootTableManager<
    _$AppDatabase,
    $EntityAttributesTable,
    EntityAttribute,
    $$EntityAttributesTableFilterComposer,
    $$EntityAttributesTableOrderingComposer,
    $$EntityAttributesTableAnnotationComposer,
    $$EntityAttributesTableCreateCompanionBuilder,
    $$EntityAttributesTableUpdateCompanionBuilder,
    (EntityAttribute, $$EntityAttributesTableReferences),
    EntityAttribute,
    PrefetchHooks Function({bool optionSet})> {
  $$EntityAttributesTableTableManager(
      _$AppDatabase db, $EntityAttributesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$EntityAttributesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$EntityAttributesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$EntityAttributesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> displayName = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>> translations = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String?> shortName = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<ValueType> valueType = const Value.absent(),
            Value<String?> optionSet = const Value.absent(),
            Value<bool?> displayWhenPlanned = const Value.absent(),
            Value<bool?> mandatory = const Value.absent(),
            Value<String?> defaultValue = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              EntityAttributesCompanion(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            displayName: displayName,
            label: label,
            translations: translations,
            code: code,
            name: name,
            shortName: shortName,
            description: description,
            valueType: valueType,
            optionSet: optionSet,
            displayWhenPlanned: displayWhenPlanned,
            mandatory: mandatory,
            defaultValue: defaultValue,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> displayName = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>> translations = const Value.absent(),
            Value<String?> code = const Value.absent(),
            required String name,
            Value<String?> shortName = const Value.absent(),
            Value<String?> description = const Value.absent(),
            required ValueType valueType,
            Value<String?> optionSet = const Value.absent(),
            Value<bool?> displayWhenPlanned = const Value.absent(),
            Value<bool?> mandatory = const Value.absent(),
            Value<String?> defaultValue = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              EntityAttributesCompanion.insert(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            displayName: displayName,
            label: label,
            translations: translations,
            code: code,
            name: name,
            shortName: shortName,
            description: description,
            valueType: valueType,
            optionSet: optionSet,
            displayWhenPlanned: displayWhenPlanned,
            mandatory: mandatory,
            defaultValue: defaultValue,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$EntityAttributesTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({optionSet = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (optionSet) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.optionSet,
                    referencedTable:
                        $$EntityAttributesTableReferences._optionSetTable(db),
                    referencedColumn: $$EntityAttributesTableReferences
                        ._optionSetTable(db)
                        .id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$EntityAttributesTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $EntityAttributesTable,
    EntityAttribute,
    $$EntityAttributesTableFilterComposer,
    $$EntityAttributesTableOrderingComposer,
    $$EntityAttributesTableAnnotationComposer,
    $$EntityAttributesTableCreateCompanionBuilder,
    $$EntityAttributesTableUpdateCompanionBuilder,
    (EntityAttribute, $$EntityAttributesTableReferences),
    EntityAttribute,
    PrefetchHooks Function({bool optionSet})>;
typedef $$EntityAttributeValuesTableCreateCompanionBuilder
    = EntityAttributeValuesCompanion Function({
  required String id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> displayName,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>> translations,
  required String entityInstance,
  required String entityAttribute,
  Value<String?> value,
  required InstanceSyncStatus syncState,
  Value<int> rowid,
});
typedef $$EntityAttributeValuesTableUpdateCompanionBuilder
    = EntityAttributeValuesCompanion Function({
  Value<String> id,
  Value<DateTime?> lastModifiedDate,
  Value<DateTime?> createdDate,
  Value<String?> displayName,
  Value<Map<String, dynamic>?> label,
  Value<List<Translation>> translations,
  Value<String> entityInstance,
  Value<String> entityAttribute,
  Value<String?> value,
  Value<InstanceSyncStatus> syncState,
  Value<int> rowid,
});

final class $$EntityAttributeValuesTableReferences extends BaseReferences<
    _$AppDatabase, $EntityAttributeValuesTable, EntityAttributeValue> {
  $$EntityAttributeValuesTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $EntityInstancesTable _entityInstanceTable(_$AppDatabase db) =>
      db.entityInstances.createAlias($_aliasNameGenerator(
          db.entityAttributeValues.entityInstance, db.entityInstances.id));

  $$EntityInstancesTableProcessedTableManager get entityInstance {
    final $_column = $_itemColumn<String>('entity_instance')!;

    final manager =
        $$EntityInstancesTableTableManager($_db, $_db.entityInstances)
            .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_entityInstanceTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $EntityInstancesTable _entityAttributeTable(_$AppDatabase db) =>
      db.entityInstances.createAlias($_aliasNameGenerator(
          db.entityAttributeValues.entityAttribute, db.entityInstances.id));

  $$EntityInstancesTableProcessedTableManager get entityAttribute {
    final $_column = $_itemColumn<String>('entity_attribute')!;

    final manager =
        $$EntityInstancesTableTableManager($_db, $_db.entityInstances)
            .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_entityAttributeTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$EntityAttributeValuesTableFilterComposer
    extends Composer<_$AppDatabase, $EntityAttributeValuesTable> {
  $$EntityAttributeValuesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<Map<String, dynamic>?, Map<String, dynamic>,
          String>
      get label => $composableBuilder(
          column: $table.label,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnWithTypeConverterFilters<List<Translation>, List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<String> get value => $composableBuilder(
      column: $table.value, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<InstanceSyncStatus, InstanceSyncStatus, String>
      get syncState => $composableBuilder(
          column: $table.syncState,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  $$EntityInstancesTableFilterComposer get entityInstance {
    final $$EntityInstancesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.entityInstance,
        referencedTable: $db.entityInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$EntityInstancesTableFilterComposer(
              $db: $db,
              $table: $db.entityInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$EntityInstancesTableFilterComposer get entityAttribute {
    final $$EntityInstancesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.entityAttribute,
        referencedTable: $db.entityInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$EntityInstancesTableFilterComposer(
              $db: $db,
              $table: $db.entityInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$EntityAttributeValuesTableOrderingComposer
    extends Composer<_$AppDatabase, $EntityAttributeValuesTable> {
  $$EntityAttributeValuesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get label => $composableBuilder(
      column: $table.label, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get translations => $composableBuilder(
      column: $table.translations,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get value => $composableBuilder(
      column: $table.value, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get syncState => $composableBuilder(
      column: $table.syncState, builder: (column) => ColumnOrderings(column));

  $$EntityInstancesTableOrderingComposer get entityInstance {
    final $$EntityInstancesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.entityInstance,
        referencedTable: $db.entityInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$EntityInstancesTableOrderingComposer(
              $db: $db,
              $table: $db.entityInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$EntityInstancesTableOrderingComposer get entityAttribute {
    final $$EntityInstancesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.entityAttribute,
        referencedTable: $db.entityInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$EntityInstancesTableOrderingComposer(
              $db: $db,
              $table: $db.entityInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$EntityAttributeValuesTableAnnotationComposer
    extends Composer<_$AppDatabase, $EntityAttributeValuesTable> {
  $$EntityAttributeValuesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get lastModifiedDate => $composableBuilder(
      column: $table.lastModifiedDate, builder: (column) => column);

  GeneratedColumn<DateTime> get createdDate => $composableBuilder(
      column: $table.createdDate, builder: (column) => column);

  GeneratedColumn<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String> get label =>
      $composableBuilder(column: $table.label, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<Translation>, String>
      get translations => $composableBuilder(
          column: $table.translations, builder: (column) => column);

  GeneratedColumn<String> get value =>
      $composableBuilder(column: $table.value, builder: (column) => column);

  GeneratedColumnWithTypeConverter<InstanceSyncStatus, String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  $$EntityInstancesTableAnnotationComposer get entityInstance {
    final $$EntityInstancesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.entityInstance,
        referencedTable: $db.entityInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$EntityInstancesTableAnnotationComposer(
              $db: $db,
              $table: $db.entityInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$EntityInstancesTableAnnotationComposer get entityAttribute {
    final $$EntityInstancesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.entityAttribute,
        referencedTable: $db.entityInstances,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$EntityInstancesTableAnnotationComposer(
              $db: $db,
              $table: $db.entityInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$EntityAttributeValuesTableTableManager extends RootTableManager<
    _$AppDatabase,
    $EntityAttributeValuesTable,
    EntityAttributeValue,
    $$EntityAttributeValuesTableFilterComposer,
    $$EntityAttributeValuesTableOrderingComposer,
    $$EntityAttributeValuesTableAnnotationComposer,
    $$EntityAttributeValuesTableCreateCompanionBuilder,
    $$EntityAttributeValuesTableUpdateCompanionBuilder,
    (EntityAttributeValue, $$EntityAttributeValuesTableReferences),
    EntityAttributeValue,
    PrefetchHooks Function({bool entityInstance, bool entityAttribute})> {
  $$EntityAttributeValuesTableTableManager(
      _$AppDatabase db, $EntityAttributeValuesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$EntityAttributeValuesTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$EntityAttributeValuesTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$EntityAttributeValuesTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> displayName = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>> translations = const Value.absent(),
            Value<String> entityInstance = const Value.absent(),
            Value<String> entityAttribute = const Value.absent(),
            Value<String?> value = const Value.absent(),
            Value<InstanceSyncStatus> syncState = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              EntityAttributeValuesCompanion(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            displayName: displayName,
            label: label,
            translations: translations,
            entityInstance: entityInstance,
            entityAttribute: entityAttribute,
            value: value,
            syncState: syncState,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            Value<DateTime?> lastModifiedDate = const Value.absent(),
            Value<DateTime?> createdDate = const Value.absent(),
            Value<String?> displayName = const Value.absent(),
            Value<Map<String, dynamic>?> label = const Value.absent(),
            Value<List<Translation>> translations = const Value.absent(),
            required String entityInstance,
            required String entityAttribute,
            Value<String?> value = const Value.absent(),
            required InstanceSyncStatus syncState,
            Value<int> rowid = const Value.absent(),
          }) =>
              EntityAttributeValuesCompanion.insert(
            id: id,
            lastModifiedDate: lastModifiedDate,
            createdDate: createdDate,
            displayName: displayName,
            label: label,
            translations: translations,
            entityInstance: entityInstance,
            entityAttribute: entityAttribute,
            value: value,
            syncState: syncState,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$EntityAttributeValuesTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {entityInstance = false, entityAttribute = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (entityInstance) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.entityInstance,
                    referencedTable: $$EntityAttributeValuesTableReferences
                        ._entityInstanceTable(db),
                    referencedColumn: $$EntityAttributeValuesTableReferences
                        ._entityInstanceTable(db)
                        .id,
                  ) as T;
                }
                if (entityAttribute) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.entityAttribute,
                    referencedTable: $$EntityAttributeValuesTableReferences
                        ._entityAttributeTable(db),
                    referencedColumn: $$EntityAttributeValuesTableReferences
                        ._entityAttributeTable(db)
                        .id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$EntityAttributeValuesTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $EntityAttributeValuesTable,
        EntityAttributeValue,
        $$EntityAttributeValuesTableFilterComposer,
        $$EntityAttributeValuesTableOrderingComposer,
        $$EntityAttributeValuesTableAnnotationComposer,
        $$EntityAttributeValuesTableCreateCompanionBuilder,
        $$EntityAttributeValuesTableUpdateCompanionBuilder,
        (EntityAttributeValue, $$EntityAttributeValuesTableReferences),
        EntityAttributeValue,
        PrefetchHooks Function({bool entityInstance, bool entityAttribute})>;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$UsersTableTableManager get users =>
      $$UsersTableTableManager(_db, _db.users);
  $$OrgUnitsTableTableManager get orgUnits =>
      $$OrgUnitsTableTableManager(_db, _db.orgUnits);
  $$OuLevelsTableTableManager get ouLevels =>
      $$OuLevelsTableTableManager(_db, _db.ouLevels);
  $$ProjectsTableTableManager get projects =>
      $$ProjectsTableTableManager(_db, _db.projects);
  $$ActivitiesTableTableManager get activities =>
      $$ActivitiesTableTableManager(_db, _db.activities);
  $$TeamsTableTableManager get teams =>
      $$TeamsTableTableManager(_db, _db.teams);
  $$ManagedTeamsTableTableManager get managedTeams =>
      $$ManagedTeamsTableTableManager(_db, _db.managedTeams);
  $$FlowTypesTableTableManager get flowTypes =>
      $$FlowTypesTableTableManager(_db, _db.flowTypes);
  $$EntityTypesTableTableManager get entityTypes =>
      $$EntityTypesTableTableManager(_db, _db.entityTypes);
  $$EntityInstancesTableTableManager get entityInstances =>
      $$EntityInstancesTableTableManager(_db, _db.entityInstances);
  $$FlowInstancesTableTableManager get flowInstances =>
      $$FlowInstancesTableTableManager(_db, _db.flowInstances);
  $$FormTemplatesTableTableManager get formTemplates =>
      $$FormTemplatesTableTableManager(_db, _db.formTemplates);
  $$AssignmentFormsTableTableManager get assignmentForms =>
      $$AssignmentFormsTableTableManager(_db, _db.assignmentForms);
  $$MetadataSubmissionsTableTableManager get metadataSubmissions =>
      $$MetadataSubmissionsTableTableManager(_db, _db.metadataSubmissions);
  $$FormTemplateVersionsTableTableManager get formTemplateVersions =>
      $$FormTemplateVersionsTableTableManager(_db, _db.formTemplateVersions);
  $$StageDefinitionsTableTableManager get stageDefinitions =>
      $$StageDefinitionsTableTableManager(_db, _db.stageDefinitions);
  $$DataSubmissionsTableTableManager get dataSubmissions =>
      $$DataSubmissionsTableTableManager(_db, _db.dataSubmissions);
  $$RepeatInstancesTableTableManager get repeatInstances =>
      $$RepeatInstancesTableTableManager(_db, _db.repeatInstances);
  $$DataOptionSetsTableTableManager get dataOptionSets =>
      $$DataOptionSetsTableTableManager(_db, _db.dataOptionSets);
  $$DataElementsTableTableManager get dataElements =>
      $$DataElementsTableTableManager(_db, _db.dataElements);
  $$DataValuesTableTableManager get dataValues =>
      $$DataValuesTableTableManager(_db, _db.dataValues);
  $$DataOptionsTableTableManager get dataOptions =>
      $$DataOptionsTableTableManager(_db, _db.dataOptions);
  $$UserFormPermissionsTableTableManager get userFormPermissions =>
      $$UserFormPermissionsTableTableManager(_db, _db.userFormPermissions);
  $$EntityAttributesTableTableManager get entityAttributes =>
      $$EntityAttributesTableTableManager(_db, _db.entityAttributes);
  $$EntityAttributeValuesTableTableManager get entityAttributeValues =>
      $$EntityAttributeValuesTableTableManager(_db, _db.entityAttributeValues);
}
